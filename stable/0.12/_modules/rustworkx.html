


<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>rustworkx &mdash; rustworkx 0.12.1 documentation</title>
  

  
  
  
  

  

  
  
    

  

  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <!-- <link rel="stylesheet" href="../_static/pygments.css" type="text/css" /> -->
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/jupyter-sphinx.css" type="text/css" />
  <link rel="stylesheet" href="../_static/thebelab.css" type="text/css" />
  <link rel="stylesheet" href="../_static/style.css" type="text/css" />
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="pytorch-body">

   

    

    <div class="rst-versions" data-toggle="rst-versions" role="note" aria-label="versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    <span class="rst-current-version-label">0.12</span>
    <span class="rst-versions-dropdown-icon"></span>
  </span>
  <div class="rst-other-versions">
    <dl>
      <dt>Versions</dt>
          <dd><a class="version" href="/documentation/retworkx/index.html">Current Release</a></dd>
          <dd><a class="version" href="/documentation/retworkx/dev/index.html">Development</a></dd>
      <dt>Previous Releases</dt>
        
            <dd><a class="version" href="/documentation/retworkx/stable/0.12/index.html">0.12</a></dd>
        
    </dl>
  </div>
  <script>
    jQuery('.version').click((evt) => {
      const hash = window.location.hash
      const complete_url = evt.target.href + hash
      window.location = complete_url
      evt.preventDefault()
    })
  </script>
</div>

    <div class="table-of-contents-link-wrapper">
      <span>Table of Contents</span>
      <a href="#" class="toggle-table-of-contents" data-behavior="toggle-table-of-contents"></a>
    </div>

    <nav data-toggle="wy-nav-shift" class="pytorch-left-menu" id="pytorch-left-menu">
      <div class="pytorch-side-scroll">
        <div class="pytorch-menu pytorch-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          <div class="pytorch-left-menu-search">
            

            
              
              
                <div class="version">
                  0.12.1
                </div>
              
            

            


  


<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search Docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

            
          </div>

          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../install.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../install.html#installing-rustworkx">Installing Rustworkx</a></li>
<li class="toctree-l1"><a class="reference internal" href="../install.html#platform-support">Platform Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../install.html#using-rustworkx">Using rustworkx</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tutorial/index.html">Rustworkx Tutorials and Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../api.html">Rustworkx API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../visualization.html">Visualization</a></li>
<li class="toctree-l1"><a class="reference internal" href="../release_notes.html">Release Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../CONTRIBUTING.html">Contributing Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../networkx.html">rustworkx for NetworkX users</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <div class="pytorch-container">
      <div class="pytorch-page-level-bar" id="pytorch-page-level-bar">
        <div class="pytorch-breadcrumbs-wrapper">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="pytorch-breadcrumbs">
    
      <li>
        <a href="../index.html">
          
            Docs
          
        </a> &gt;
      </li>

        
          <li><a href="index.html">Module code</a> &gt;</li>
        
      <li>rustworkx</li>
    
    
      <li class="pytorch-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
</div>
        </div>

        <div class="pytorch-shortcuts-wrapper" id="pytorch-shortcuts-wrapper">
          Shortcuts
        </div>
      </div>

      <section data-toggle="wy-nav-shift" id="pytorch-content-wrap" class="pytorch-content-wrap">
        <div class="pytorch-content-left">
          
          <div class="rst-content style-external-links">
          
            <div role="main" class="main-content" itemscope="itemscope" itemtype="http://schema.org/Article">
             <article itemprop="articleBody" id="pytorch-article" class="pytorch-article">
              
  <h1>Source code for rustworkx</h1><div class="highlight"><pre>
<span></span><span class="c1"># This code is licensed under the Apache License, Version 2.0. You may</span>
<span class="c1"># obtain a copy of this license in the LICENSE.txt file in the root directory</span>
<span class="c1"># of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.</span>
<span class="c1">#</span>
<span class="c1"># Any modifications or derivative works of this code must retain this</span>
<span class="c1"># copyright notice, and modified files need to carry a notice indicating</span>
<span class="c1"># that they have been altered from the originals.</span>


<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">functools</span>

<span class="kn">from</span> <span class="nn">.rustworkx</span> <span class="kn">import</span> <span class="o">*</span>

<span class="c1"># flake8: noqa</span>
<span class="kn">import</span> <span class="nn">rustworkx.visit</span>

<span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">[</span><span class="s2">&quot;rustworkx.generators&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">generators</span>


<div class="viewcode-block" id="PyDAG"><a class="viewcode-back" href="../apiref/rustworkx.PyDAG.html#rustworkx.PyDAG">[docs]</a><span class="k">class</span> <span class="nc">PyDAG</span><span class="p">(</span><span class="n">PyDiGraph</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A class for creating direct acyclic graphs.</span>

<span class="sd">    PyDAG is just an alias of the PyDiGraph class and behaves identically to</span>
<span class="sd">    the :class:`~rustworkx.PyDiGraph` class and can be used interchangably</span>
<span class="sd">    with ``PyDiGraph``. It currently exists solely as a backwards</span>
<span class="sd">    compatibility alias for users of rustworkx from prior to the</span>
<span class="sd">    0.4.0 release when there was no PyDiGraph class.</span>

<span class="sd">    The PyDAG class is used to create a directed graph. It can be a</span>
<span class="sd">    multigraph (have multiple edges between nodes). Each node and edge</span>
<span class="sd">    (although rarely used for edges) is indexed by an integer id. These ids</span>
<span class="sd">    are stable for the lifetime of the graph object and on node or edge</span>
<span class="sd">    deletions you can have holes in the list of indices for the graph.</span>
<span class="sd">    Node indices will be reused on additions after removal. For example:</span>

<span class="sd">    .. jupyter-execute::</span>

<span class="sd">        import rustworkx as rx</span>

<span class="sd">        graph = rx.PyDAG()</span>
<span class="sd">        graph.add_nodes_from(list(range(5)))</span>
<span class="sd">        graph.add_nodes_from(list(range(2)))</span>
<span class="sd">        graph.remove_node(2)</span>
<span class="sd">        print(&quot;After deletion:&quot;, graph.node_indices())</span>
<span class="sd">        res_manual = graph.add_parent(6, None, None)</span>
<span class="sd">        print(&quot;After adding a new node:&quot;, graph.node_indices())</span>

<span class="sd">    Additionally, each node and edge contains an arbitrary Python object as a</span>
<span class="sd">    weight/data payload.</span>

<span class="sd">    You can use the index for access to the data payload as in the</span>
<span class="sd">    following example:</span>

<span class="sd">    .. jupyter-execute::</span>

<span class="sd">        import rustworkx as rx</span>

<span class="sd">        graph = rx.PyDAG()</span>
<span class="sd">        data_payload = &quot;An arbitrary Python object&quot;</span>
<span class="sd">        node_index = graph.add_node(data_payload)</span>
<span class="sd">        print(&quot;Node Index: %s&quot; % node_index)</span>
<span class="sd">        print(graph[node_index])</span>

<span class="sd">    The PyDAG class implements the Python mapping protocol for nodes so in</span>
<span class="sd">    addition to access you can also update the data payload with:</span>

<span class="sd">    .. jupyter-execute::</span>

<span class="sd">        import rustworkx as rx</span>

<span class="sd">        graph = rx.PyDAG()</span>
<span class="sd">        data_payload = &quot;An arbitrary Python object&quot;</span>
<span class="sd">        node_index = graph.add_node(data_payload)</span>
<span class="sd">        graph[node_index] = &quot;New Payload&quot;</span>
<span class="sd">        print(&quot;Node Index: %s&quot; % node_index)</span>
<span class="sd">        print(graph[node_index])</span>

<span class="sd">    The PyDAG class has an option for real time cycle checking which can</span>
<span class="sd">    be used to ensure any edges added to the graph does not introduce a cycle.</span>
<span class="sd">    By default the real time cycle checking feature is disabled for</span>
<span class="sd">    performance, however you can enable it by setting the ``check_cycle``</span>
<span class="sd">    attribute to True. For example::</span>

<span class="sd">        import rustworkx as rx</span>
<span class="sd">        dag = rx.PyDAG()</span>
<span class="sd">        dag.check_cycle = True</span>

<span class="sd">    or at object creation::</span>

<span class="sd">        import rustworkx as rx</span>
<span class="sd">        dag = rx.PyDAG(check_cycle=True)</span>

<span class="sd">    With check_cycle set to true any calls to :meth:`PyDAG.add_edge` will</span>
<span class="sd">    ensure that no cycles are added, ensuring that the PyDAG class truly</span>
<span class="sd">    represents a directed acyclic graph. Do note that this cycle checking on</span>
<span class="sd">    :meth:`~PyDAG.add_edge`, :meth:`~PyDigraph.add_edges_from`,</span>
<span class="sd">    :meth:`~PyDAG.add_edges_from_no_data`,</span>
<span class="sd">    :meth:`~PyDAG.extend_from_edge_list`,  and</span>
<span class="sd">    :meth:`~PyDAG.extend_from_weighted_edge_list` comes with a performance</span>
<span class="sd">    penalty that grows as the graph does.  If you&#39;re adding a node and edge at</span>
<span class="sd">    the same time, leveraging :meth:`PyDAG.add_child` or</span>
<span class="sd">    :meth:`PyDAG.add_parent` will avoid this overhead.</span>

<span class="sd">    By default a ``PyDAG`` is a multigraph (meaning there can be parallel</span>
<span class="sd">    edges between nodes) however this can be disabled by setting the</span>
<span class="sd">    ``multigraph`` kwarg to ``False`` when calling the ``PyDAG`` constructor.</span>
<span class="sd">    For example::</span>

<span class="sd">        import rustworkx as rx</span>
<span class="sd">        dag = rx.PyDAG(multigraph=False)</span>

<span class="sd">    This can only be set at ``PyDiGraph`` initialization and not adjusted after</span>
<span class="sd">    creation. When :attr:`~rustworkx.PyDiGraph.multigraph` is set to ``False``</span>
<span class="sd">    if a method call is made that would add a parallel edge it will instead</span>
<span class="sd">    update the existing edge&#39;s weight/data payload.</span>

<span class="sd">    The maximum number of nodes and edges allowed on a ``PyGraph`` object is</span>
<span class="sd">    :math:`2^{32} - 1` (4,294,967,294) each. Attempting to add more nodes or</span>
<span class="sd">    edges than this will result in an exception being raised.</span>

<span class="sd">    :param bool check_cycle: When this is set to ``True`` the created</span>
<span class="sd">        ``PyDAG`` has runtime cycle detection enabled.</span>
<span class="sd">    :param bool multgraph: When this is set to ``False`` the created</span>
<span class="sd">        ``PyDAG`` object will not be a multigraph. When ``False`` if a method</span>
<span class="sd">        call is made that would add parallel edges the the weight/weight from</span>
<span class="sd">        that method call will be used to update the existing edge in place.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">pass</span></div>


<div class="viewcode-block" id="distance_matrix"><a class="viewcode-back" href="../apiref/rustworkx.distance_matrix.html#rustworkx.distance_matrix">[docs]</a><span class="nd">@functools</span><span class="o">.</span><span class="n">singledispatch</span>
<span class="k">def</span> <span class="nf">distance_matrix</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">parallel_threshold</span><span class="o">=</span><span class="mi">300</span><span class="p">,</span> <span class="n">as_undirected</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">null_value</span><span class="o">=</span><span class="mf">0.0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Get the distance matrix for a graph</span>

<span class="sd">    This differs from functions like :func:`~rustworkx.floyd_warshall_numpy` in</span>
<span class="sd">    that the edge weight/data payload is not used and each edge is treated as a</span>
<span class="sd">    distance of 1.</span>

<span class="sd">    This function is also multithreaded and will run in parallel if the number</span>
<span class="sd">    of nodes in the graph is above the value of ``parallel_threshold`` (it</span>
<span class="sd">    defaults to 300). If the function will be running in parallel the env var</span>
<span class="sd">    ``RAYON_NUM_THREADS`` can be used to adjust how many threads will be used.</span>

<span class="sd">    :param graph: The graph to get the distance matrix for, can be either a</span>
<span class="sd">        :class:`~rustworkx.PyGraph` or :class:`~rustworkx.PyDiGraph`.</span>
<span class="sd">    :param int parallel_threshold: The number of nodes to calculate the</span>
<span class="sd">        the distance matrix in parallel at. It defaults to 300, but this can</span>
<span class="sd">        be tuned</span>
<span class="sd">    :param bool as_undirected: If set to ``True`` the input directed graph</span>
<span class="sd">        will be treat as if each edge was bidirectional/undirected in the</span>
<span class="sd">        output distance matrix.</span>
<span class="sd">    :param float null_value: An optional float that will treated as a null</span>
<span class="sd">        value. This is the default value in the output matrix and it is used</span>
<span class="sd">        to indicate the absence of an edge between 2 nodes. By default this</span>
<span class="sd">        is ``0.0``.</span>

<span class="sd">    :returns: The distance matrix</span>
<span class="sd">    :rtype: numpy.ndarray</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Invalid Input Type </span><span class="si">%s</span><span class="s2"> for graph&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">graph</span><span class="p">))</span></div>


<span class="nd">@distance_matrix</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">PyDiGraph</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_digraph_distance_matrix</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">parallel_threshold</span><span class="o">=</span><span class="mi">300</span><span class="p">,</span> <span class="n">as_undirected</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">null_value</span><span class="o">=</span><span class="mf">0.0</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">digraph_distance_matrix</span><span class="p">(</span>
        <span class="n">graph</span><span class="p">,</span>
        <span class="n">parallel_threshold</span><span class="o">=</span><span class="n">parallel_threshold</span><span class="p">,</span>
        <span class="n">as_undirected</span><span class="o">=</span><span class="n">as_undirected</span><span class="p">,</span>
        <span class="n">null_value</span><span class="o">=</span><span class="n">null_value</span><span class="p">,</span>
    <span class="p">)</span>


<span class="nd">@distance_matrix</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">PyGraph</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_graph_distance_matrix</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">parallel_threshold</span><span class="o">=</span><span class="mi">300</span><span class="p">,</span> <span class="n">null_value</span><span class="o">=</span><span class="mf">0.0</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">graph_distance_matrix</span><span class="p">(</span>
        <span class="n">graph</span><span class="p">,</span> <span class="n">parallel_threshold</span><span class="o">=</span><span class="n">parallel_threshold</span><span class="p">,</span> <span class="n">null_value</span><span class="o">=</span><span class="n">null_value</span>
    <span class="p">)</span>


<div class="viewcode-block" id="unweighted_average_shortest_path_length"><a class="viewcode-back" href="../apiref/rustworkx.unweighted_average_shortest_path_length.html#rustworkx.unweighted_average_shortest_path_length">[docs]</a><span class="nd">@functools</span><span class="o">.</span><span class="n">singledispatch</span>
<span class="k">def</span> <span class="nf">unweighted_average_shortest_path_length</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">parallel_threshold</span><span class="o">=</span><span class="mi">300</span><span class="p">,</span> <span class="n">disconnected</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Return the average shortest path length with unweighted edges.</span>

<span class="sd">    The average shortest path length is calculated as</span>

<span class="sd">    .. math::</span>

<span class="sd">        a =\sum_{s,t \in V, s \ne t} \frac{d(s, t)}{n(n-1)}</span>

<span class="sd">    where :math:`V` is the set of nodes in ``graph``, :math:`d(s, t)` is the</span>
<span class="sd">    shortest path length from :math:`s` to :math:`t`, and :math:`n` is the</span>
<span class="sd">    number of nodes in ``graph``. If ``disconnected`` is set to ``True``,</span>
<span class="sd">    the average will be taken only between connected nodes.</span>

<span class="sd">    This function is also multithreaded and will run in parallel if the number</span>
<span class="sd">    of nodes in the graph is above the value of ``parallel_threshold`` (it</span>
<span class="sd">    defaults to 300). If the function will be running in parallel the env var</span>
<span class="sd">    ``RAYON_NUM_THREADS`` can be used to adjust how many threads will be used.</span>
<span class="sd">    By default it will use all available CPUs if the environment variable is</span>
<span class="sd">    not specified.</span>

<span class="sd">    :param graph: The graph to compute the average shortest path length for,</span>
<span class="sd">        can be either a :class:`~rustworkx.PyGraph` or :class:`~rustworkx.PyDiGraph`.</span>
<span class="sd">    :param int parallel_threshold: The number of nodes to calculate the</span>
<span class="sd">        the distance matrix in parallel at. It defaults to 300, but this can</span>
<span class="sd">        be tuned to any number of nodes.</span>
<span class="sd">    :param bool as_undirected: If set to ``True`` the input directed graph</span>
<span class="sd">        will be treated as if each edge was bidirectional/undirected while</span>
<span class="sd">        finding the shortest paths. Default: ``False``.</span>
<span class="sd">    :param bool disconnected: If set to ``True`` only connected vertex pairs</span>
<span class="sd">        will be included in the calculation. If ``False``, infinity is returned</span>
<span class="sd">        for disconnected graphs. Default: ``False``.</span>

<span class="sd">    :returns: The average shortest path length. If no vertex pairs can be included</span>
<span class="sd">        in the calculation this will return NaN.</span>

<span class="sd">    :rtype: float</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Invalid Input Type </span><span class="si">%s</span><span class="s2"> for graph&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">graph</span><span class="p">))</span></div>


<span class="nd">@unweighted_average_shortest_path_length</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">PyDiGraph</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_digraph_unweighted_average_shortest_path_length</span><span class="p">(</span>
    <span class="n">graph</span><span class="p">,</span> <span class="n">parallel_threshold</span><span class="o">=</span><span class="mi">300</span><span class="p">,</span> <span class="n">as_undirected</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">disconnected</span><span class="o">=</span><span class="kc">False</span>
<span class="p">):</span>
    <span class="k">return</span> <span class="n">digraph_unweighted_average_shortest_path_length</span><span class="p">(</span>
        <span class="n">graph</span><span class="p">,</span>
        <span class="n">parallel_threshold</span><span class="o">=</span><span class="n">parallel_threshold</span><span class="p">,</span>
        <span class="n">as_undirected</span><span class="o">=</span><span class="n">as_undirected</span><span class="p">,</span>
        <span class="n">disconnected</span><span class="o">=</span><span class="n">disconnected</span><span class="p">,</span>
    <span class="p">)</span>


<span class="nd">@unweighted_average_shortest_path_length</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">PyGraph</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_graph_unweighted_shortest_path_length</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">parallel_threshold</span><span class="o">=</span><span class="mi">300</span><span class="p">,</span> <span class="n">disconnected</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">graph_unweighted_average_shortest_path_length</span><span class="p">(</span>
        <span class="n">graph</span><span class="p">,</span> <span class="n">parallel_threshold</span><span class="o">=</span><span class="n">parallel_threshold</span><span class="p">,</span> <span class="n">disconnected</span><span class="o">=</span><span class="n">disconnected</span>
    <span class="p">)</span>


<div class="viewcode-block" id="adjacency_matrix"><a class="viewcode-back" href="../apiref/rustworkx.adjacency_matrix.html#rustworkx.adjacency_matrix">[docs]</a><span class="nd">@functools</span><span class="o">.</span><span class="n">singledispatch</span>
<span class="k">def</span> <span class="nf">adjacency_matrix</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">weight_fn</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">default_weight</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">null_value</span><span class="o">=</span><span class="mf">0.0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return the adjacency matrix for a graph object</span>

<span class="sd">    In the case where there are multiple edges between nodes the value in the</span>
<span class="sd">    output matrix will be the sum of the edges&#39; weights.</span>

<span class="sd">    :param graph: The graph used to generate the adjacency matrix from. Can</span>
<span class="sd">        either be a :class:`~rustworkx.PyGraph` or :class:`~rustworkx.PyDiGraph`</span>
<span class="sd">    :param callable weight_fn: A callable object (function, lambda, etc) which</span>
<span class="sd">        will be passed the edge object and expected to return a ``float``. This</span>
<span class="sd">        tells rustworkx/rust how to extract a numerical weight as a ``float``</span>
<span class="sd">        for edge object. Some simple examples are::</span>

<span class="sd">            adjacency_matrix(graph, weight_fn: lambda x: 1)</span>

<span class="sd">        to return a weight of 1 for all edges. Also::</span>

<span class="sd">            adjacency_matrix(graph, weight_fn: lambda x: float(x))</span>

<span class="sd">        to cast the edge object as a float as the weight. If this is not</span>
<span class="sd">        specified a default value (either ``default_weight`` or 1) will be used</span>
<span class="sd">        for all edges.</span>
<span class="sd">    :param float default_weight: If ``weight_fn`` is not used this can be</span>
<span class="sd">        optionally used to specify a default weight to use for all edges.</span>
<span class="sd">    :param float null_value: An optional float that will treated as a null</span>
<span class="sd">        value. This is the default value in the output matrix and it is used</span>
<span class="sd">        to indicate the absence of an edge between 2 nodes. By default this is</span>
<span class="sd">        ``0.0``.</span>

<span class="sd">     :return: The adjacency matrix for the input dag as a numpy array</span>
<span class="sd">     :rtype: numpy.ndarray</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Invalid Input Type </span><span class="si">%s</span><span class="s2"> for graph&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">graph</span><span class="p">))</span></div>


<span class="nd">@adjacency_matrix</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">PyDiGraph</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_digraph_adjacency_matrix</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">weight_fn</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">default_weight</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">null_value</span><span class="o">=</span><span class="mf">0.0</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">digraph_adjacency_matrix</span><span class="p">(</span>
        <span class="n">graph</span><span class="p">,</span>
        <span class="n">weight_fn</span><span class="o">=</span><span class="n">weight_fn</span><span class="p">,</span>
        <span class="n">default_weight</span><span class="o">=</span><span class="n">default_weight</span><span class="p">,</span>
        <span class="n">null_value</span><span class="o">=</span><span class="n">null_value</span><span class="p">,</span>
    <span class="p">)</span>


<span class="nd">@adjacency_matrix</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">PyGraph</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_graph_adjacency_matrix</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">weight_fn</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">default_weight</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">null_value</span><span class="o">=</span><span class="mf">0.0</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">graph_adjacency_matrix</span><span class="p">(</span>
        <span class="n">graph</span><span class="p">,</span>
        <span class="n">weight_fn</span><span class="o">=</span><span class="n">weight_fn</span><span class="p">,</span>
        <span class="n">default_weight</span><span class="o">=</span><span class="n">default_weight</span><span class="p">,</span>
        <span class="n">null_value</span><span class="o">=</span><span class="n">null_value</span><span class="p">,</span>
    <span class="p">)</span>


<div class="viewcode-block" id="all_simple_paths"><a class="viewcode-back" href="../apiref/rustworkx.all_simple_paths.html#rustworkx.all_simple_paths">[docs]</a><span class="nd">@functools</span><span class="o">.</span><span class="n">singledispatch</span>
<span class="k">def</span> <span class="nf">all_simple_paths</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">from_</span><span class="p">,</span> <span class="n">to</span><span class="p">,</span> <span class="n">min_depth</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cutoff</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return all simple paths between 2 nodes in a PyGraph object</span>

<span class="sd">    A simple path is a path with no repeated nodes.</span>

<span class="sd">    :param graph: The graph to find the path in. Can either be a</span>
<span class="sd">        class:`~rustworkx.PyGraph` or :class:`~rustworkx.PyDiGraph`</span>
<span class="sd">    :param int from_: The node index to find the paths from</span>
<span class="sd">    :param int to: The node index to find the paths to</span>
<span class="sd">    :param int min_depth: The minimum depth of the path to include in the</span>
<span class="sd">        output list of paths. By default all paths are included regardless of</span>
<span class="sd">        depth, setting to 0 will behave like the default.</span>
<span class="sd">    :param int cutoff: The maximum depth of path to include in the output list</span>
<span class="sd">        of paths. By default includes all paths regardless of depth, setting to</span>
<span class="sd">        0 will behave like default.</span>

<span class="sd">    :returns: A list of lists where each inner list is a path of node indices</span>
<span class="sd">    :rtype: list</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Invalid Input Type </span><span class="si">%s</span><span class="s2"> for graph&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">graph</span><span class="p">))</span></div>


<span class="nd">@all_simple_paths</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">PyDiGraph</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_digraph_all_simple_paths</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">from_</span><span class="p">,</span> <span class="n">to</span><span class="p">,</span> <span class="n">min_depth</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cutoff</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">digraph_all_simple_paths</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">from_</span><span class="p">,</span> <span class="n">to</span><span class="p">,</span> <span class="n">min_depth</span><span class="o">=</span><span class="n">min_depth</span><span class="p">,</span> <span class="n">cutoff</span><span class="o">=</span><span class="n">cutoff</span><span class="p">)</span>


<span class="nd">@all_simple_paths</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">PyGraph</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_graph_all_simple_paths</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">from_</span><span class="p">,</span> <span class="n">to</span><span class="p">,</span> <span class="n">min_depth</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cutoff</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">graph_all_simple_paths</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">from_</span><span class="p">,</span> <span class="n">to</span><span class="p">,</span> <span class="n">min_depth</span><span class="o">=</span><span class="n">min_depth</span><span class="p">,</span> <span class="n">cutoff</span><span class="o">=</span><span class="n">cutoff</span><span class="p">)</span>


<div class="viewcode-block" id="floyd_warshall"><a class="viewcode-back" href="../apiref/rustworkx.floyd_warshall.html#rustworkx.floyd_warshall">[docs]</a><span class="nd">@functools</span><span class="o">.</span><span class="n">singledispatch</span>
<span class="k">def</span> <span class="nf">floyd_warshall</span><span class="p">(</span>
    <span class="n">graph</span><span class="p">,</span>
    <span class="n">weight_fn</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">default_weight</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
    <span class="n">parallel_threshold</span><span class="o">=</span><span class="mi">300</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Find all-pairs shortest path lengths using Floyd&#39;s algorithm</span>

<span class="sd">    Floyd&#39;s algorithm is used for finding shortest paths in dense graphs</span>
<span class="sd">    or graphs with negative weights (where Dijkstra&#39;s algorithm fails).</span>

<span class="sd">    This function is multithreaded and will launch a pool with threads equal</span>
<span class="sd">    to the number of CPUs by default if the number of nodes in the graph is</span>
<span class="sd">    above the value of ``parallel_threshold`` (it defaults to 300).</span>
<span class="sd">    You can tune the number of threads with the ``RAYON_NUM_THREADS``</span>
<span class="sd">    environment variable. For example, setting ``RAYON_NUM_THREADS=4`` would</span>
<span class="sd">    limit the thread pool to 4 threads if parallelization was enabled.</span>

<span class="sd">    :param graph: The graph to run Floyd&#39;s algorithm on. Can</span>
<span class="sd">        either be a :class:`~rustworkx.PyGraph` or :class:`~rustworkx.PyDiGraph`</span>
<span class="sd">    :param callable weight_fn: A callable object (function, lambda, etc) which</span>
<span class="sd">        will be passed the edge object and expected to return a ``float``. This</span>
<span class="sd">        tells rustworkx/rust how to extract a numerical weight as a ``float``</span>
<span class="sd">        for edge object. Some simple examples are::</span>

<span class="sd">            floyd_warshall(graph, weight_fn= lambda x: 1)</span>

<span class="sd">        to return a weight of 1 for all edges. Also::</span>

<span class="sd">            floyd_warshall(graph, weight_fn=float)</span>

<span class="sd">        to cast the edge object as a float as the weight. If this is not</span>
<span class="sd">        specified a default value (either ``default_weight`` or 1) will be used</span>
<span class="sd">        for all edges.</span>
<span class="sd">    :param float default_weight: If ``weight_fn`` is not used this can be</span>
<span class="sd">        optionally used to specify a default weight to use for all edges.</span>
<span class="sd">    :param int parallel_threshold: The number of nodes to execute</span>
<span class="sd">        the algorithm in parallel at. It defaults to 300, but this can</span>
<span class="sd">        be tuned</span>

<span class="sd">    :return: A read-only dictionary of path lengths. The keys are the source</span>
<span class="sd">        node indices and the values are a dict of the target node and the</span>
<span class="sd">        length of the shortest path to that node. For example::</span>

<span class="sd">            {</span>
<span class="sd">                0: {0: 0.0, 1: 2.0, 2: 2.0},</span>
<span class="sd">                1: {1: 0.0, 2: 1.0},</span>
<span class="sd">                2: {0: 1.0, 2: 0.0},</span>
<span class="sd">            }</span>

<span class="sd">    :rtype: AllPairsPathLengthMapping</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Invalid Input Type </span><span class="si">%s</span><span class="s2"> for graph&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">graph</span><span class="p">))</span></div>


<span class="nd">@floyd_warshall</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">PyDiGraph</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_digraph_floyd_warshall</span><span class="p">(</span>
    <span class="n">graph</span><span class="p">,</span>
    <span class="n">weight_fn</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">default_weight</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
    <span class="n">parallel_threshold</span><span class="o">=</span><span class="mi">300</span><span class="p">,</span>
<span class="p">):</span>
    <span class="k">return</span> <span class="n">digraph_floyd_warshall</span><span class="p">(</span>
        <span class="n">graph</span><span class="p">,</span>
        <span class="n">weight_fn</span><span class="o">=</span><span class="n">weight_fn</span><span class="p">,</span>
        <span class="n">default_weight</span><span class="o">=</span><span class="n">default_weight</span><span class="p">,</span>
        <span class="n">parallel_threshold</span><span class="o">=</span><span class="n">parallel_threshold</span><span class="p">,</span>
    <span class="p">)</span>


<span class="nd">@floyd_warshall</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">PyGraph</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_graph_floyd_warshall</span><span class="p">(</span>
    <span class="n">graph</span><span class="p">,</span>
    <span class="n">weight_fn</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">default_weight</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
    <span class="n">parallel_threshold</span><span class="o">=</span><span class="mi">300</span><span class="p">,</span>
<span class="p">):</span>
    <span class="k">return</span> <span class="n">graph_floyd_warshall</span><span class="p">(</span>
        <span class="n">graph</span><span class="p">,</span>
        <span class="n">weight_fn</span><span class="o">=</span><span class="n">weight_fn</span><span class="p">,</span>
        <span class="n">default_weight</span><span class="o">=</span><span class="n">default_weight</span><span class="p">,</span>
        <span class="n">parallel_threshold</span><span class="o">=</span><span class="n">parallel_threshold</span><span class="p">,</span>
    <span class="p">)</span>


<div class="viewcode-block" id="floyd_warshall_numpy"><a class="viewcode-back" href="../apiref/rustworkx.floyd_warshall_numpy.html#rustworkx.floyd_warshall_numpy">[docs]</a><span class="nd">@functools</span><span class="o">.</span><span class="n">singledispatch</span>
<span class="k">def</span> <span class="nf">floyd_warshall_numpy</span><span class="p">(</span>
    <span class="n">graph</span><span class="p">,</span>
    <span class="n">weight_fn</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">default_weight</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
    <span class="n">parallel_threshold</span><span class="o">=</span><span class="mi">300</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Find all-pairs shortest path lengths using Floyd&#39;s algorithm</span>

<span class="sd">    Floyd&#39;s algorithm is used for finding shortest paths in dense graphs</span>
<span class="sd">    or graphs with negative weights (where Dijkstra&#39;s algorithm fails).</span>

<span class="sd">    This function is multithreaded and will launch a pool with threads equal</span>
<span class="sd">    to the number of CPUs by default if the number of nodes in the graph is</span>
<span class="sd">    above the value of ``parallel_threshold`` (it defaults to 300).</span>
<span class="sd">    You can tune the number of threads with the ``RAYON_NUM_THREADS``</span>
<span class="sd">    environment variable. For example, setting ``RAYON_NUM_THREADS=4`` would</span>
<span class="sd">    limit the thread pool to 4 threads if parallelization was enabled.</span>

<span class="sd">    :param graph: The graph to run Floyd&#39;s algorithm on. Can</span>
<span class="sd">        either be a :class:`~rustworkx.PyGraph` or :class:`~rustworkx.PyDiGraph`</span>
<span class="sd">    :param callable weight_fn: A callable object (function, lambda, etc) which</span>
<span class="sd">        will be passed the edge object and expected to return a ``float``. This</span>
<span class="sd">        tells rustworkx/rust how to extract a numerical weight as a ``float``</span>
<span class="sd">        for edge object. Some simple examples are::</span>

<span class="sd">            floyd_warshall_numpy(graph, weight_fn: lambda x: 1)</span>

<span class="sd">        to return a weight of 1 for all edges. Also::</span>

<span class="sd">            floyd_warshall_numpy(graph, weight_fn: lambda x: float(x))</span>

<span class="sd">        to cast the edge object as a float as the weight. If this is not</span>
<span class="sd">        specified a default value (either ``default_weight`` or 1) will be used</span>
<span class="sd">        for all edges.</span>
<span class="sd">    :param float default_weight: If ``weight_fn`` is not used this can be</span>
<span class="sd">        optionally used to specify a default weight to use for all edges.</span>
<span class="sd">    :param int parallel_threshold: The number of nodes to execute</span>
<span class="sd">        the algorithm in parallel at. It defaults to 300, but this can</span>
<span class="sd">        be tuned</span>

<span class="sd">    :returns: A matrix of shortest path distances between nodes. If there is no</span>
<span class="sd">        path between two nodes then the corresponding matrix entry will be</span>
<span class="sd">        ``np.inf``.</span>
<span class="sd">    :rtype: numpy.ndarray</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Invalid Input Type </span><span class="si">%s</span><span class="s2"> for graph&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">graph</span><span class="p">))</span></div>


<span class="nd">@floyd_warshall_numpy</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">PyDiGraph</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_digraph_floyd_warshall_numpy</span><span class="p">(</span>
    <span class="n">graph</span><span class="p">,</span> <span class="n">weight_fn</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">default_weight</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">parallel_threshold</span><span class="o">=</span><span class="mi">300</span>
<span class="p">):</span>
    <span class="k">return</span> <span class="n">digraph_floyd_warshall_numpy</span><span class="p">(</span>
        <span class="n">graph</span><span class="p">,</span>
        <span class="n">weight_fn</span><span class="o">=</span><span class="n">weight_fn</span><span class="p">,</span>
        <span class="n">default_weight</span><span class="o">=</span><span class="n">default_weight</span><span class="p">,</span>
        <span class="n">parallel_threshold</span><span class="o">=</span><span class="n">parallel_threshold</span><span class="p">,</span>
    <span class="p">)</span>


<span class="nd">@floyd_warshall_numpy</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">PyGraph</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_graph_floyd_warshall_numpy</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">weight_fn</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">default_weight</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">parallel_threshold</span><span class="o">=</span><span class="mi">300</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">graph_floyd_warshall_numpy</span><span class="p">(</span>
        <span class="n">graph</span><span class="p">,</span>
        <span class="n">weight_fn</span><span class="o">=</span><span class="n">weight_fn</span><span class="p">,</span>
        <span class="n">default_weight</span><span class="o">=</span><span class="n">default_weight</span><span class="p">,</span>
        <span class="n">parallel_threshold</span><span class="o">=</span><span class="n">parallel_threshold</span><span class="p">,</span>
    <span class="p">)</span>


<div class="viewcode-block" id="astar_shortest_path"><a class="viewcode-back" href="../apiref/rustworkx.astar_shortest_path.html#rustworkx.astar_shortest_path">[docs]</a><span class="nd">@functools</span><span class="o">.</span><span class="n">singledispatch</span>
<span class="k">def</span> <span class="nf">astar_shortest_path</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">goal_fn</span><span class="p">,</span> <span class="n">edge_cost_fn</span><span class="p">,</span> <span class="n">estimate_cost_fn</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute the A* shortest path for a graph</span>

<span class="sd">    :param graph: The input graph to use. Can</span>
<span class="sd">        either be a :class:`~rustworkx.PyGraph` or :class:`~rustworkx.PyDiGraph`</span>
<span class="sd">    :param int node: The node index to compute the path from</span>
<span class="sd">    :param goal_fn: A python callable that will take in 1 parameter, a node&#39;s</span>
<span class="sd">        data object and will return a boolean which will be True if it is the</span>
<span class="sd">        finish node.</span>
<span class="sd">    :param edge_cost_fn: A python callable that will take in 1 parameter, an</span>
<span class="sd">        edge&#39;s data object and will return a float that represents the cost</span>
<span class="sd">        of that edge. It must be non-negative.</span>
<span class="sd">    :param estimate_cost_fn: A python callable that will take in 1 parameter, a</span>
<span class="sd">        node&#39;s data object and will return a float which represents the</span>
<span class="sd">        estimated cost for the next node. The return must be non-negative. For</span>
<span class="sd">        the algorithm to find the actual shortest path, it should be</span>
<span class="sd">        admissible, meaning that it should never overestimate the actual cost</span>
<span class="sd">        to get to the nearest goal node.</span>

<span class="sd">    :returns: The computed shortest path between node and finish as a list</span>
<span class="sd">        of node indices.</span>
<span class="sd">    :rtype: NodeIndices</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Invalid Input Type </span><span class="si">%s</span><span class="s2"> for graph&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">graph</span><span class="p">))</span></div>


<span class="nd">@astar_shortest_path</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">PyDiGraph</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_digraph_astar_shortest_path</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">goal_fn</span><span class="p">,</span> <span class="n">edge_cost_fn</span><span class="p">,</span> <span class="n">estimate_cost_fn</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">digraph_astar_shortest_path</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">goal_fn</span><span class="p">,</span> <span class="n">edge_cost_fn</span><span class="p">,</span> <span class="n">estimate_cost_fn</span><span class="p">)</span>


<span class="nd">@astar_shortest_path</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">PyGraph</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_graph_astar_shortest_path</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">goal_fn</span><span class="p">,</span> <span class="n">edge_cost_fn</span><span class="p">,</span> <span class="n">estimate_cost_fn</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">graph_astar_shortest_path</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">goal_fn</span><span class="p">,</span> <span class="n">edge_cost_fn</span><span class="p">,</span> <span class="n">estimate_cost_fn</span><span class="p">)</span>


<div class="viewcode-block" id="dijkstra_shortest_paths"><a class="viewcode-back" href="../apiref/rustworkx.dijkstra_shortest_paths.html#rustworkx.dijkstra_shortest_paths">[docs]</a><span class="nd">@functools</span><span class="o">.</span><span class="n">singledispatch</span>
<span class="k">def</span> <span class="nf">dijkstra_shortest_paths</span><span class="p">(</span>
    <span class="n">graph</span><span class="p">,</span>
    <span class="n">source</span><span class="p">,</span>
    <span class="n">target</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">weight_fn</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">default_weight</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
    <span class="n">as_undirected</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Find the shortest path from a node</span>

<span class="sd">    This function will generate the shortest path from a source node using</span>
<span class="sd">    Dijkstra&#39;s algorithm.</span>

<span class="sd">    :param graph: The input graph to use. Can either be a</span>
<span class="sd">        :class:`~rustworkx.PyGraph` or :class:`~rustworkx.PyDiGraph`</span>
<span class="sd">    :param int source: The node index to find paths from</span>
<span class="sd">    :param int target: An optional target to find a path to</span>
<span class="sd">    :param weight_fn: An optional weight function for an edge. It will accept</span>
<span class="sd">        a single argument, the edge&#39;s weight object and will return a float</span>
<span class="sd">        which will be used to represent the weight/cost of the edge</span>
<span class="sd">    :param float default_weight: If ``weight_fn`` isn&#39;t specified this optional</span>
<span class="sd">        float value will be used for the weight/cost of each edge.</span>
<span class="sd">    :param bool as_undirected: If set to true the graph will be treated as</span>
<span class="sd">        undirected for finding the shortest path. This only works with a</span>
<span class="sd">        :class:`~rustworkx.PyDiGraph` input for ``graph``</span>

<span class="sd">    :return: Dictionary of paths. The keys are destination node indices and</span>
<span class="sd">        the dict values are lists of node indices making the path.</span>
<span class="sd">    :rtype: dict</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Invalid Input Type </span><span class="si">%s</span><span class="s2"> for graph&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">graph</span><span class="p">))</span></div>


<span class="nd">@dijkstra_shortest_paths</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">PyDiGraph</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_digraph_dijkstra_shortest_path</span><span class="p">(</span>
    <span class="n">graph</span><span class="p">,</span>
    <span class="n">source</span><span class="p">,</span>
    <span class="n">target</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">weight_fn</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">default_weight</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
    <span class="n">as_undirected</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
<span class="p">):</span>
    <span class="k">return</span> <span class="n">digraph_dijkstra_shortest_paths</span><span class="p">(</span>
        <span class="n">graph</span><span class="p">,</span>
        <span class="n">source</span><span class="p">,</span>
        <span class="n">target</span><span class="o">=</span><span class="n">target</span><span class="p">,</span>
        <span class="n">weight_fn</span><span class="o">=</span><span class="n">weight_fn</span><span class="p">,</span>
        <span class="n">default_weight</span><span class="o">=</span><span class="n">default_weight</span><span class="p">,</span>
        <span class="n">as_undirected</span><span class="o">=</span><span class="n">as_undirected</span><span class="p">,</span>
    <span class="p">)</span>


<span class="nd">@dijkstra_shortest_paths</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">PyGraph</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_graph_dijkstra_shortest_path</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">weight_fn</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">default_weight</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">graph_dijkstra_shortest_paths</span><span class="p">(</span>
        <span class="n">graph</span><span class="p">,</span>
        <span class="n">source</span><span class="p">,</span>
        <span class="n">target</span><span class="o">=</span><span class="n">target</span><span class="p">,</span>
        <span class="n">weight_fn</span><span class="o">=</span><span class="n">weight_fn</span><span class="p">,</span>
        <span class="n">default_weight</span><span class="o">=</span><span class="n">default_weight</span><span class="p">,</span>
    <span class="p">)</span>


<div class="viewcode-block" id="all_pairs_dijkstra_shortest_paths"><a class="viewcode-back" href="../apiref/rustworkx.all_pairs_dijkstra_shortest_paths.html#rustworkx.all_pairs_dijkstra_shortest_paths">[docs]</a><span class="nd">@functools</span><span class="o">.</span><span class="n">singledispatch</span>
<span class="k">def</span> <span class="nf">all_pairs_dijkstra_shortest_paths</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">edge_cost_fn</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;For each node in the graph, finds the shortest paths to all others.</span>

<span class="sd">    This function will generate the shortest path from all nodes in the graph</span>
<span class="sd">    using Dijkstra&#39;s algorithm. This function is multithreaded and will run</span>
<span class="sd">    launch a thread pool with threads equal to the number of CPUs by default.</span>
<span class="sd">    You can tune the number of threads with the ``RAYON_NUM_THREADS``</span>
<span class="sd">    environment variable. For example, setting ``RAYON_NUM_THREADS=4`` would</span>
<span class="sd">    limit the thread pool to 4 threads.</span>

<span class="sd">    :param graph: The input graph to use. Can either be a</span>
<span class="sd">        :class:`~rustworkx.PyGraph` or :class:`~rustworkx.PyDiGraph`</span>
<span class="sd">    :param edge_cost_fn: A callable object that acts as a weight function for</span>
<span class="sd">        an edge. It will accept a single positional argument, the edge&#39;s weight</span>
<span class="sd">        object and will return a float which will be used to represent the</span>
<span class="sd">        weight/cost of the edge</span>

<span class="sd">    :return: A read-only dictionary of paths. The keys are source node</span>
<span class="sd">        indices and the values are a dict of target node indices and a list</span>
<span class="sd">        of node indices making the path. For example::</span>

<span class="sd">            {</span>
<span class="sd">                0: {1: [0, 1],  2: [0, 1, 2]},</span>
<span class="sd">                1: {2: [1, 2]},</span>
<span class="sd">                2: {0: [2, 0]},</span>
<span class="sd">            }</span>

<span class="sd">    :rtype: AllPairsPathMapping</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Invalid Input Type </span><span class="si">%s</span><span class="s2"> for graph&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">graph</span><span class="p">))</span></div>


<span class="nd">@all_pairs_dijkstra_shortest_paths</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">PyDiGraph</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_digraph_all_pairsdijkstra_shortest_path</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">edge_cost_fn</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">digraph_all_pairs_dijkstra_shortest_paths</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">edge_cost_fn</span><span class="p">)</span>


<span class="nd">@all_pairs_dijkstra_shortest_paths</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">PyGraph</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_graph_all_pairs_dijkstra_shortest_path</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">edge_cost_fn</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">graph_all_pairs_dijkstra_shortest_paths</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">edge_cost_fn</span><span class="p">)</span>


<div class="viewcode-block" id="all_pairs_all_simple_paths"><a class="viewcode-back" href="../apiref/rustworkx.all_pairs_all_simple_paths.html#rustworkx.all_pairs_all_simple_paths">[docs]</a><span class="nd">@functools</span><span class="o">.</span><span class="n">singledispatch</span>
<span class="k">def</span> <span class="nf">all_pairs_all_simple_paths</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">min_depth</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cutoff</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return all the simple paths between all pairs of nodes in the graph</span>

<span class="sd">    This function is multithreaded and will launch a thread pool with threads</span>
<span class="sd">    equal to the number of CPUs by default. You can tune the number of threads</span>
<span class="sd">    with the ``RAYON_NUM_THREADS`` environment variable. For example, setting</span>
<span class="sd">    ``RAYON_NUM_THREADS=4`` would limit the thread pool to 4 threads.</span>

<span class="sd">    :param graph: The graph to find all simple paths in. This can be a :class:`~rustworkx.PyGraph`</span>
<span class="sd">        or a :class:`~rustworkx.PyDiGraph`</span>
<span class="sd">    :param int min_depth: The minimum depth of the path to include in the output</span>
<span class="sd">        list of paths. By default all paths are included regardless of depth,</span>
<span class="sd">        setting to 0 will behave like the default.</span>
<span class="sd">    :param int cutoff: The maximum depth of path to include in the output list</span>
<span class="sd">        of paths. By default includes all paths regardless of depth, setting to</span>
<span class="sd">        0 will behave like default.</span>

<span class="sd">    :returns: A mapping of source node indices to a mapping of target node</span>
<span class="sd">        indices to a list of paths between the source and target nodes.</span>
<span class="sd">    :rtype: AllPairsMultiplePathMapping</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Invalid Input Type </span><span class="si">%s</span><span class="s2"> for graph&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">graph</span><span class="p">))</span></div>


<span class="nd">@all_pairs_all_simple_paths</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">PyDiGraph</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_digraph_all_pairs_all_simple_paths</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">min_depth</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cutoff</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">digraph_all_pairs_all_simple_paths</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">min_depth</span><span class="o">=</span><span class="n">min_depth</span><span class="p">,</span> <span class="n">cutoff</span><span class="o">=</span><span class="n">cutoff</span><span class="p">)</span>


<span class="nd">@all_pairs_all_simple_paths</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">PyGraph</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_graph_all_pairs_all_simple_paths</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">min_depth</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cutoff</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">graph_all_pairs_all_simple_paths</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">min_depth</span><span class="o">=</span><span class="n">min_depth</span><span class="p">,</span> <span class="n">cutoff</span><span class="o">=</span><span class="n">cutoff</span><span class="p">)</span>


<div class="viewcode-block" id="all_pairs_dijkstra_path_lengths"><a class="viewcode-back" href="../apiref/rustworkx.all_pairs_dijkstra_path_lengths.html#rustworkx.all_pairs_dijkstra_path_lengths">[docs]</a><span class="nd">@functools</span><span class="o">.</span><span class="n">singledispatch</span>
<span class="k">def</span> <span class="nf">all_pairs_dijkstra_path_lengths</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">edge_cost_fn</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;For each node in the graph, calculates the lengths of the shortest paths to all others.</span>

<span class="sd">    This function will generate the shortest path lengths from all nodes in the</span>
<span class="sd">    graph using Dijkstra&#39;s algorithm. This function is multithreaded and will</span>
<span class="sd">    launch a thread pool with threads equal to the number of CPUs by</span>
<span class="sd">    default. You can tune the number of threads with the ``RAYON_NUM_THREADS``</span>
<span class="sd">    environment variable. For example, setting ``RAYON_NUM_THREADS=4`` would</span>
<span class="sd">    limit the thread pool to 4 threads.</span>

<span class="sd">    :param graph: The input graph to use. Can either be a</span>
<span class="sd">        :class:`~rustworkx.PyGraph` or :class:`~rustworkx.PyDiGraph`</span>
<span class="sd">    :param edge_cost_fn: A callable object that acts as a weight function for</span>
<span class="sd">        an edge. It will accept a single positional argument, the edge&#39;s weight</span>
<span class="sd">        object and will return a float which will be used to represent the</span>
<span class="sd">        weight/cost of the edge</span>

<span class="sd">    :return: A read-only dictionary of path lengths. The keys are the source</span>
<span class="sd">        node indices and the values are a dict of the target node and the</span>
<span class="sd">        length of the shortest path to that node. For example::</span>

<span class="sd">            {</span>
<span class="sd">                0: {1: 2.0, 2: 2.0},</span>
<span class="sd">                1: {2: 1.0},</span>
<span class="sd">                2: {0: 1.0},</span>
<span class="sd">            }</span>

<span class="sd">    :rtype: AllPairsPathLengthMapping</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Invalid Input Type </span><span class="si">%s</span><span class="s2"> for graph&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">graph</span><span class="p">))</span></div>


<span class="nd">@all_pairs_dijkstra_path_lengths</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">PyDiGraph</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_digraph_all_pairs_dijkstra_path_lengths</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">edge_cost_fn</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">digraph_all_pairs_dijkstra_path_lengths</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">edge_cost_fn</span><span class="p">)</span>


<span class="nd">@all_pairs_dijkstra_path_lengths</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">PyGraph</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_graph_all_pairs_dijkstra_path_lengths</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">edge_cost_fn</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">graph_all_pairs_dijkstra_path_lengths</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">edge_cost_fn</span><span class="p">)</span>


<div class="viewcode-block" id="dijkstra_shortest_path_lengths"><a class="viewcode-back" href="../apiref/rustworkx.dijkstra_shortest_path_lengths.html#rustworkx.dijkstra_shortest_path_lengths">[docs]</a><span class="nd">@functools</span><span class="o">.</span><span class="n">singledispatch</span>
<span class="k">def</span> <span class="nf">dijkstra_shortest_path_lengths</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">edge_cost_fn</span><span class="p">,</span> <span class="n">goal</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute the lengths of the shortest paths for a graph object using</span>
<span class="sd">    Dijkstra&#39;s algorithm.</span>

<span class="sd">    :param graph: The input graph to use. Can either be a</span>
<span class="sd">        :class:`~rustworkx.PyGraph` or :class:`~rustworkx.PyDiGraph`</span>
<span class="sd">    :param int node: The node index to use as the source for finding the</span>
<span class="sd">        shortest paths from</span>
<span class="sd">    :param edge_cost_fn: A python callable that will take in 1 parameter, an</span>
<span class="sd">        edge&#39;s data object and will return a float that represents the</span>
<span class="sd">        cost/weight of that edge. It must be non-negative</span>
<span class="sd">    :param int goal: An optional node index to use as the end of the path.</span>
<span class="sd">        When specified the traversal will stop when the goal is reached and</span>
<span class="sd">        the output dictionary will only have a single entry with the length</span>
<span class="sd">        of the shortest path to the goal node.</span>

<span class="sd">    :returns: A dictionary of the shortest paths from the provided node where</span>
<span class="sd">        the key is the node index of the end of the path and the value is the</span>
<span class="sd">        cost/sum of the weights of path</span>
<span class="sd">    :rtype: dict</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Invalid Input Type </span><span class="si">%s</span><span class="s2"> for graph&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">graph</span><span class="p">))</span></div>


<span class="nd">@dijkstra_shortest_path_lengths</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">PyDiGraph</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_digraph_dijkstra_shortest_path_lengths</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">edge_cost_fn</span><span class="p">,</span> <span class="n">goal</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">digraph_dijkstra_shortest_path_lengths</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">edge_cost_fn</span><span class="p">,</span> <span class="n">goal</span><span class="o">=</span><span class="n">goal</span><span class="p">)</span>


<span class="nd">@dijkstra_shortest_path_lengths</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">PyGraph</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_graph_dijkstra_shortest_path_lengths</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">edge_cost_fn</span><span class="p">,</span> <span class="n">goal</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">graph_dijkstra_shortest_path_lengths</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">edge_cost_fn</span><span class="p">,</span> <span class="n">goal</span><span class="o">=</span><span class="n">goal</span><span class="p">)</span>


<div class="viewcode-block" id="k_shortest_path_lengths"><a class="viewcode-back" href="../apiref/rustworkx.k_shortest_path_lengths.html#rustworkx.k_shortest_path_lengths">[docs]</a><span class="nd">@functools</span><span class="o">.</span><span class="n">singledispatch</span>
<span class="k">def</span> <span class="nf">k_shortest_path_lengths</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">edge_cost</span><span class="p">,</span> <span class="n">goal</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute the length of the kth shortest path</span>

<span class="sd">    Computes the lengths of the kth shortest path from ``start`` to every</span>
<span class="sd">    reachable node.</span>

<span class="sd">    Computes in :math:`O(k * (|E| + |V|*log(|V|)))` time (average).</span>

<span class="sd">    :param graph: The graph to find the shortest paths in. Can either be a</span>
<span class="sd">        :class:`~rustworkx.PyGraph` or :class:`~rustworkx.PyDiGraph`</span>
<span class="sd">    :param int start: The node index to find the shortest paths from</span>
<span class="sd">    :param int k: The kth shortest path to find the lengths of</span>
<span class="sd">    :param edge_cost: A python callable that will receive an edge payload and</span>
<span class="sd">        return a float for the cost of that eedge</span>
<span class="sd">    :param int goal: An optional goal node index, if specified the output</span>
<span class="sd">        dictionary</span>

<span class="sd">    :returns: A dict of lengths where the key is the destination node index and</span>
<span class="sd">        the value is the length of the path.</span>
<span class="sd">    :rtype: dict</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Invalid Input Type </span><span class="si">%s</span><span class="s2"> for graph&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">graph</span><span class="p">))</span></div>


<span class="nd">@k_shortest_path_lengths</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">PyDiGraph</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_digraph_k_shortest_path_lengths</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">edge_cost</span><span class="p">,</span> <span class="n">goal</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">digraph_k_shortest_path_lengths</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">edge_cost</span><span class="p">,</span> <span class="n">goal</span><span class="o">=</span><span class="n">goal</span><span class="p">)</span>


<span class="nd">@k_shortest_path_lengths</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">PyGraph</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_graph_k_shortest_path_lengths</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">edge_cost</span><span class="p">,</span> <span class="n">goal</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">graph_k_shortest_path_lengths</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">edge_cost</span><span class="p">,</span> <span class="n">goal</span><span class="o">=</span><span class="n">goal</span><span class="p">)</span>


<div class="viewcode-block" id="dfs_edges"><a class="viewcode-back" href="../apiref/rustworkx.dfs_edges.html#rustworkx.dfs_edges">[docs]</a><span class="nd">@functools</span><span class="o">.</span><span class="n">singledispatch</span>
<span class="k">def</span> <span class="nf">dfs_edges</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Get an edge list of the tree edges from a depth-first traversal</span>

<span class="sd">    The pseudo-code for the DFS algorithm is listed below. The output</span>
<span class="sd">    contains the tree edges found by the procedure.</span>

<span class="sd">    ::</span>

<span class="sd">        DFS(G, v)</span>
<span class="sd">          let S be a stack</span>
<span class="sd">          label v as discovered</span>
<span class="sd">          PUSH(S, (v, iterator of G.neighbors(v)))</span>
<span class="sd">          while (S != )</span>
<span class="sd">              let (v, iterator) := LAST(S)</span>
<span class="sd">              if hasNext(iterator) then</span>
<span class="sd">                  w := next(iterator)</span>
<span class="sd">                  if w is not labeled as discovered then</span>
<span class="sd">                      label w as discovered                   # (v, w) is a tree edge</span>
<span class="sd">                      PUSH(S, (w, iterator of G.neighbors(w)))</span>
<span class="sd">              else</span>
<span class="sd">                  POP(S)</span>
<span class="sd">          end while</span>

<span class="sd">    .. note::</span>

<span class="sd">        If the input is an undirected graph with a single connected component,</span>
<span class="sd">        the output of this function is a spanning tree.</span>

<span class="sd">    :param graph: The graph to get the DFS edge list from. Can either be a</span>
<span class="sd">        :class:`~rustworkx.PyGraph` or :class:`~rustworkx.PyDiGraph`</span>
<span class="sd">    :param int source: An optional node index to use as the starting node</span>
<span class="sd">        for the depth-first search. The edge list will only return edges in</span>
<span class="sd">        the components reachable from this index. If this is not specified</span>
<span class="sd">        then a source will be chosen arbitrarly and repeated until all</span>
<span class="sd">        components of the graph are searched.</span>

<span class="sd">    :returns: A list of edges as a tuple of the form ``(source, target)`` in</span>
<span class="sd">        depth-first order</span>
<span class="sd">    :rtype: EdgeList</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Invalid Input Type </span><span class="si">%s</span><span class="s2"> for graph&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">graph</span><span class="p">))</span></div>


<span class="nd">@dfs_edges</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">PyDiGraph</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_digraph_dfs_edges</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">digraph_dfs_edges</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="n">source</span><span class="p">)</span>


<span class="nd">@dfs_edges</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">PyGraph</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_graph_dfs_edges</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">graph_dfs_edges</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="n">source</span><span class="p">)</span>


<div class="viewcode-block" id="is_isomorphic"><a class="viewcode-back" href="../apiref/rustworkx.is_isomorphic.html#rustworkx.is_isomorphic">[docs]</a><span class="nd">@functools</span><span class="o">.</span><span class="n">singledispatch</span>
<span class="k">def</span> <span class="nf">is_isomorphic</span><span class="p">(</span>
    <span class="n">first</span><span class="p">,</span>
    <span class="n">second</span><span class="p">,</span>
    <span class="n">node_matcher</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">edge_matcher</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">id_order</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">call_limit</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Determine if 2 graphs are isomorphic</span>

<span class="sd">    This checks if 2 graphs are isomorphic both structurally and also</span>
<span class="sd">    comparing the node and edge data using the provided matcher functions.</span>
<span class="sd">    The matcher functions take in 2 data objects and will compare them. A</span>
<span class="sd">    simple example that checks if they&#39;re just equal would be::</span>

<span class="sd">            graph_a = rustworkx.PyGraph()</span>
<span class="sd">            graph_b = rustworkx.PyGraph()</span>
<span class="sd">            rustworkx.is_isomorphic(graph_a, graph_b,</span>
<span class="sd">                                lambda x, y: x == y)</span>

<span class="sd">    .. note::</span>

<span class="sd">        For better performance on large graphs, consider setting</span>
<span class="sd">        `id_order=False`.</span>

<span class="sd">    :param first: The first graph to compare. Can either be a</span>
<span class="sd">        :class:`~rustworkx.PyGraph` or :class:`~rustworkx.PyDiGraph`.</span>
<span class="sd">    :param second: The second graph to compare. Can either be a</span>
<span class="sd">        :class:`~rustworkx.PyGraph` or :class:`~rustworkx.PyDiGraph`.</span>
<span class="sd">        It should be the same type as the first graph.</span>
<span class="sd">    :param callable node_matcher: A python callable object that takes 2</span>
<span class="sd">        positional one for each node data object. If the return of this</span>
<span class="sd">        function evaluates to True then the nodes passed to it are viewed</span>
<span class="sd">        as matching.</span>
<span class="sd">    :param callable edge_matcher: A python callable object that takes 2</span>
<span class="sd">        positional one for each edge data object. If the return of this</span>
<span class="sd">        function evaluates to True then the edges passed to it are viewed</span>
<span class="sd">        as matching.</span>
<span class="sd">    :param bool id_order: If set to ``False`` this function will use a</span>
<span class="sd">        heuristic matching order based on [VF2]_ paper. Otherwise it will</span>
<span class="sd">        default to matching the nodes in order specified by their ids.</span>
<span class="sd">    :param int call_limit: An optional bound on the number of states that VF2</span>
<span class="sd">        algorithm visits while searching for a solution. If it exceeds this limit,</span>
<span class="sd">        the algorithm will stop and return ``False``.</span>

<span class="sd">    :returns: ``True`` if the 2 graphs are isomorphic, ``False`` if they are</span>
<span class="sd">        not.</span>
<span class="sd">    :rtype: bool</span>

<span class="sd">    .. [VF2] VF2++  An Improved Subgraph Isomorphism Algorithm</span>
<span class="sd">        by Alpr Jttner and Pter Madarasi</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Invalid Input Type </span><span class="si">%s</span><span class="s2"> for graph&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">first</span><span class="p">))</span></div>


<span class="nd">@is_isomorphic</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">PyDiGraph</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_digraph_is_isomorphic</span><span class="p">(</span>
    <span class="n">first</span><span class="p">,</span>
    <span class="n">second</span><span class="p">,</span>
    <span class="n">node_matcher</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">edge_matcher</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">id_order</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">call_limit</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>
    <span class="k">return</span> <span class="n">digraph_is_isomorphic</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">second</span><span class="p">,</span> <span class="n">node_matcher</span><span class="p">,</span> <span class="n">edge_matcher</span><span class="p">,</span> <span class="n">id_order</span><span class="p">,</span> <span class="n">call_limit</span><span class="p">)</span>


<span class="nd">@is_isomorphic</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">PyGraph</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_graph_is_isomorphic</span><span class="p">(</span>
    <span class="n">first</span><span class="p">,</span>
    <span class="n">second</span><span class="p">,</span>
    <span class="n">node_matcher</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">edge_matcher</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">id_order</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">call_limit</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>
    <span class="k">return</span> <span class="n">graph_is_isomorphic</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">second</span><span class="p">,</span> <span class="n">node_matcher</span><span class="p">,</span> <span class="n">edge_matcher</span><span class="p">,</span> <span class="n">id_order</span><span class="p">,</span> <span class="n">call_limit</span><span class="p">)</span>


<div class="viewcode-block" id="is_isomorphic_node_match"><a class="viewcode-back" href="../apiref/rustworkx.is_isomorphic_node_match.html#rustworkx.is_isomorphic_node_match">[docs]</a><span class="nd">@functools</span><span class="o">.</span><span class="n">singledispatch</span>
<span class="k">def</span> <span class="nf">is_isomorphic_node_match</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">second</span><span class="p">,</span> <span class="n">matcher</span><span class="p">,</span> <span class="n">id_order</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Determine if 2 graphs are isomorphic</span>

<span class="sd">    This checks if 2 graphs are isomorphic both structurally and also</span>
<span class="sd">    comparing the node data using the provided matcher function. The matcher</span>
<span class="sd">    function takes in 2 node data objects and will compare them. A simple</span>
<span class="sd">    example that checks if they&#39;re just equal would be::</span>

<span class="sd">        graph_a = rustworkx.PyDAG()</span>
<span class="sd">        graph_b = rustworkx.PyDAG()</span>
<span class="sd">        rustworkx.is_isomorphic_node_match(graph_a, graph_b,</span>
<span class="sd">                                        lambda x, y: x == y)</span>

<span class="sd">    .. note::</span>

<span class="sd">        For better performance on large graphs, consider setting</span>
<span class="sd">        `id_order=False`.</span>

<span class="sd">    :param first: The first graph to compare. Can either be a</span>
<span class="sd">        :class:`~rustworkx.PyGraph` or :class:`~rustworkx.PyDiGraph`.</span>
<span class="sd">    :param second: The second graph to compare. Can either be a</span>
<span class="sd">        :class:`~rustworkx.PyGraph` or :class:`~rustworkx.PyDiGraph`.</span>
<span class="sd">        It should be the same type as the first graph.</span>
<span class="sd">    :param callable matcher: A python callable object that takes 2 positional</span>
<span class="sd">        one for each node data object. If the return of this</span>
<span class="sd">        function evaluates to True then the nodes passed to it are vieded</span>
<span class="sd">        as matching.</span>
<span class="sd">    :param bool id_order: If set to ``False`` this function will use a</span>
<span class="sd">        heuristic matching order based on [VF2]_ paper. Otherwise it will</span>
<span class="sd">        default to matching the nodes in order specified by their ids.</span>

<span class="sd">    :returns: ``True`` if the 2 graphs are isomorphic ``False`` if they are</span>
<span class="sd">        not.</span>
<span class="sd">    :rtype: bool</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Invalid Input Type </span><span class="si">%s</span><span class="s2"> for graph&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">first</span><span class="p">))</span></div>


<span class="nd">@is_isomorphic_node_match</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">PyDiGraph</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_digraph_is_isomorphic_node_match</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">second</span><span class="p">,</span> <span class="n">matcher</span><span class="p">,</span> <span class="n">id_order</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">digraph_is_isomorphic</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">second</span><span class="p">,</span> <span class="n">matcher</span><span class="p">,</span> <span class="n">id_order</span><span class="o">=</span><span class="n">id_order</span><span class="p">)</span>


<span class="nd">@is_isomorphic_node_match</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">PyGraph</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_graph_is_isomorphic_node_match</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">second</span><span class="p">,</span> <span class="n">matcher</span><span class="p">,</span> <span class="n">id_order</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">graph_is_isomorphic</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">second</span><span class="p">,</span> <span class="n">matcher</span><span class="p">,</span> <span class="n">id_order</span><span class="o">=</span><span class="n">id_order</span><span class="p">)</span>


<div class="viewcode-block" id="is_subgraph_isomorphic"><a class="viewcode-back" href="../apiref/rustworkx.is_subgraph_isomorphic.html#rustworkx.is_subgraph_isomorphic">[docs]</a><span class="nd">@functools</span><span class="o">.</span><span class="n">singledispatch</span>
<span class="k">def</span> <span class="nf">is_subgraph_isomorphic</span><span class="p">(</span>
    <span class="n">first</span><span class="p">,</span>
    <span class="n">second</span><span class="p">,</span>
    <span class="n">node_matcher</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">edge_matcher</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">id_order</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">induced</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">call_limit</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Determine if 2 graphs are subgraph isomorphic</span>

<span class="sd">    This checks if 2 graphs are subgraph isomorphic both structurally and also</span>
<span class="sd">    comparing the node and edge data using the provided matcher functions.</span>
<span class="sd">    The matcher functions take in 2 data objects and will compare them.</span>
<span class="sd">    Since there is an ambiguity in the term &#39;subgraph&#39;, do note that we check</span>
<span class="sd">    for an node-induced subgraph if argument `induced` is set to `True`. If it is</span>
<span class="sd">    set to `False`, we check for a non induced subgraph, meaning the second graph</span>
<span class="sd">    can have fewer edges than the subgraph of the first. By default it&#39;s `True`. A</span>
<span class="sd">    simple example that checks if they&#39;re just equal would be::</span>

<span class="sd">            graph_a = rustworkx.PyGraph()</span>
<span class="sd">            graph_b = rustworkx.PyGraph()</span>
<span class="sd">            rustworkx.is_subgraph_isomorphic(graph_a, graph_b,</span>
<span class="sd">                                            lambda x, y: x == y)</span>


<span class="sd">    :param first: The first graph to compare. Can either be a</span>
<span class="sd">        :class:`~rustworkx.PyGraph` or :class:`~rustworkx.PyDiGraph`.</span>
<span class="sd">    :param second: The second graph to compare. Can either be a</span>
<span class="sd">        :class:`~rustworkx.PyGraph` or :class:`~rustworkx.PyDiGraph`.</span>
<span class="sd">        It should be the same type as the first graph.</span>
<span class="sd">    :param callable node_matcher: A python callable object that takes 2</span>
<span class="sd">        positional one for each node data object. If the return of this</span>
<span class="sd">        function evaluates to True then the nodes passed to it are viewed</span>
<span class="sd">        as matching.</span>
<span class="sd">    :param callable edge_matcher: A python callable object that takes 2</span>
<span class="sd">        positional one for each edge data object. If the return of this</span>
<span class="sd">        function evaluates to True then the edges passed to it are viewed</span>
<span class="sd">        as matching.</span>
<span class="sd">    :param bool id_order: If set to ``True`` this function will match the nodes</span>
<span class="sd">        in order specified by their ids. Otherwise it will default to a heuristic</span>
<span class="sd">        matching order based on [VF2]_ paper.</span>
<span class="sd">    :param bool induced: If set to ``True`` this function will check the existence</span>
<span class="sd">        of a node-induced subgraph of first isomorphic to second graph.</span>
<span class="sd">        Default: ``True``.</span>
<span class="sd">    :param int call_limit: An optional bound on the number of states that VF2</span>
<span class="sd">        algorithm visits while searching for a solution. If it exceeds this limit,</span>
<span class="sd">        the algorithm will stop and return ``False``.</span>

<span class="sd">    :returns: ``True`` if there is a subgraph of `first` isomorphic to `second`</span>
<span class="sd">        , ``False`` if there is not.</span>
<span class="sd">    :rtype: bool</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Invalid Input Type </span><span class="si">%s</span><span class="s2"> for graph&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">first</span><span class="p">))</span></div>


<span class="nd">@is_subgraph_isomorphic</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">PyDiGraph</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_digraph_is_subgraph_isomorphic</span><span class="p">(</span>
    <span class="n">first</span><span class="p">,</span>
    <span class="n">second</span><span class="p">,</span>
    <span class="n">node_matcher</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">edge_matcher</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">id_order</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">induced</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">call_limit</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>
    <span class="k">return</span> <span class="n">digraph_is_subgraph_isomorphic</span><span class="p">(</span>
        <span class="n">first</span><span class="p">,</span> <span class="n">second</span><span class="p">,</span> <span class="n">node_matcher</span><span class="p">,</span> <span class="n">edge_matcher</span><span class="p">,</span> <span class="n">id_order</span><span class="p">,</span> <span class="n">induced</span><span class="p">,</span> <span class="n">call_limit</span>
    <span class="p">)</span>


<span class="nd">@is_subgraph_isomorphic</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">PyGraph</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_graph_is_subgraph_isomorphic</span><span class="p">(</span>
    <span class="n">first</span><span class="p">,</span>
    <span class="n">second</span><span class="p">,</span>
    <span class="n">node_matcher</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">edge_matcher</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">id_order</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">induced</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">call_limit</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>
    <span class="k">return</span> <span class="n">graph_is_subgraph_isomorphic</span><span class="p">(</span>
        <span class="n">first</span><span class="p">,</span> <span class="n">second</span><span class="p">,</span> <span class="n">node_matcher</span><span class="p">,</span> <span class="n">edge_matcher</span><span class="p">,</span> <span class="n">id_order</span><span class="p">,</span> <span class="n">induced</span><span class="p">,</span> <span class="n">call_limit</span>
    <span class="p">)</span>


<div class="viewcode-block" id="transitivity"><a class="viewcode-back" href="../apiref/rustworkx.transitivity.html#rustworkx.transitivity">[docs]</a><span class="nd">@functools</span><span class="o">.</span><span class="n">singledispatch</span>
<span class="k">def</span> <span class="nf">transitivity</span><span class="p">(</span><span class="n">graph</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute the transitivity of a graph.</span>

<span class="sd">    This function is multithreaded and will run</span>
<span class="sd">    launch a thread pool with threads equal to the number of CPUs by default.</span>
<span class="sd">    You can tune the number of threads with the ``RAYON_NUM_THREADS``</span>
<span class="sd">    environment variable. For example, setting ``RAYON_NUM_THREADS=4`` would</span>
<span class="sd">    limit the thread pool to 4 threads.</span>

<span class="sd">    .. note::</span>

<span class="sd">        The function implicitly assumes that there are no parallel edges</span>
<span class="sd">        or self loops. It may produce incorrect/unexpected results if the</span>
<span class="sd">        input graph has self loops or parallel edges.</span>

<span class="sd">    :param graph: The graph to be used. Can either be a</span>
<span class="sd">        :class:`~rustworkx.PyGraph` or :class:`~rustworkx.PyDiGraph`.</span>

<span class="sd">    :returns: Transitivity of the graph.</span>
<span class="sd">    :rtype: float</span>
<span class="sd">        raise TypeError(&quot;Invalid Input Type %s for graph&quot; % type(graph))</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Invalid Input Type </span><span class="si">%s</span><span class="s2"> for graph&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">graph</span><span class="p">))</span></div>


<span class="nd">@transitivity</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">PyDiGraph</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_digraph_transitivity</span><span class="p">(</span><span class="n">graph</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">digraph_transitivity</span><span class="p">(</span><span class="n">graph</span><span class="p">)</span>


<span class="nd">@transitivity</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">PyGraph</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_graph_transitivity</span><span class="p">(</span><span class="n">graph</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">graph_transitivity</span><span class="p">(</span><span class="n">graph</span><span class="p">)</span>


<div class="viewcode-block" id="core_number"><a class="viewcode-back" href="../apiref/rustworkx.core_number.html#rustworkx.core_number">[docs]</a><span class="nd">@functools</span><span class="o">.</span><span class="n">singledispatch</span>
<span class="k">def</span> <span class="nf">core_number</span><span class="p">(</span><span class="n">graph</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return the core number for each node in the graph.</span>

<span class="sd">    A k-core is a maximal subgraph that contains nodes of degree k or more.</span>

<span class="sd">    .. note::</span>

<span class="sd">        The function implicitly assumes that there are no parallel edges</span>
<span class="sd">        or self loops. It may produce incorrect/unexpected results if the</span>
<span class="sd">        input graph has self loops or parallel edges.</span>

<span class="sd">    :param graph: The graph to get core numbers. Can either be a</span>
<span class="sd">        :class:`~rustworkx.PyGraph` or :class:`~rustworkx.PyDiGraph`</span>

<span class="sd">    :returns: A dictionary keyed by node index to the core number</span>
<span class="sd">    :rtype: dict</span>
<span class="sd">        raise TypeError(&quot;Invalid Input Type %s for graph&quot; % type(graph))</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Invalid Input Type </span><span class="si">%s</span><span class="s2"> for graph&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">graph</span><span class="p">))</span></div>


<span class="nd">@core_number</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">PyDiGraph</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_digraph_core_number</span><span class="p">(</span><span class="n">graph</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">digraph_core_number</span><span class="p">(</span><span class="n">graph</span><span class="p">)</span>


<span class="nd">@core_number</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">PyGraph</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_graph_core_number</span><span class="p">(</span><span class="n">graph</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">graph_core_number</span><span class="p">(</span><span class="n">graph</span><span class="p">)</span>


<div class="viewcode-block" id="complement"><a class="viewcode-back" href="../apiref/rustworkx.complement.html#rustworkx.complement">[docs]</a><span class="nd">@functools</span><span class="o">.</span><span class="n">singledispatch</span>
<span class="k">def</span> <span class="nf">complement</span><span class="p">(</span><span class="n">graph</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute the complement of a graph.</span>

<span class="sd">    :param graph: The graph to be used, can be either a</span>
<span class="sd">        :class:`~rustworkx.PyGraph` or :class:`~rustworkx.PyDiGraph`.</span>

<span class="sd">    :returns: The complement of the graph.</span>
<span class="sd">    :rtype: :class:`~rustworkx.PyGraph` or :class:`~rustworkx.PyDiGraph`</span>

<span class="sd">    .. note::</span>
<span class="sd">        Parallel edges and self-loops are never created,</span>
<span class="sd">        even if the ``multigraph`` is set to ``True``</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Invalid Input Type </span><span class="si">%s</span><span class="s2"> for graph&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">graph</span><span class="p">))</span></div>


<span class="nd">@complement</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">PyDiGraph</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_digraph_complement</span><span class="p">(</span><span class="n">graph</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">digraph_complement</span><span class="p">(</span><span class="n">graph</span><span class="p">)</span>


<span class="nd">@complement</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">PyGraph</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_graph_complement</span><span class="p">(</span><span class="n">graph</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">graph_complement</span><span class="p">(</span><span class="n">graph</span><span class="p">)</span>


<div class="viewcode-block" id="random_layout"><a class="viewcode-back" href="../apiref/rustworkx.random_layout.html#rustworkx.random_layout">[docs]</a><span class="nd">@functools</span><span class="o">.</span><span class="n">singledispatch</span>
<span class="k">def</span> <span class="nf">random_layout</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Generate a random layout</span>

<span class="sd">    :param PyGraph graph: The graph to generate the layout for</span>
<span class="sd">    :param tuple center: An optional center position. This is a 2 tuple of two</span>
<span class="sd">        ``float`` values for the center position</span>
<span class="sd">    :param int seed: An optional seed to set for the random number generator.</span>

<span class="sd">    :returns: The random layout of the graph.</span>
<span class="sd">    :rtype: Pos2DMapping</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Invalid Input Type </span><span class="si">%s</span><span class="s2"> for graph&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">graph</span><span class="p">))</span></div>


<span class="nd">@random_layout</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">PyDiGraph</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_digraph_random_layout</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">digraph_random_layout</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="n">center</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="n">seed</span><span class="p">)</span>


<span class="nd">@random_layout</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">PyGraph</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_graph_random_layout</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">graph_random_layout</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="n">center</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="n">seed</span><span class="p">)</span>


<div class="viewcode-block" id="spring_layout"><a class="viewcode-back" href="../apiref/rustworkx.spring_layout.html#rustworkx.spring_layout">[docs]</a><span class="nd">@functools</span><span class="o">.</span><span class="n">singledispatch</span>
<span class="k">def</span> <span class="nf">spring_layout</span><span class="p">(</span>
    <span class="n">graph</span><span class="p">,</span>
    <span class="n">pos</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">fixed</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">k</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">repulsive_exponent</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
    <span class="n">adaptive_cooling</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">num_iter</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span>
    <span class="n">tol</span><span class="o">=</span><span class="mf">1e-6</span><span class="p">,</span>
    <span class="n">weight_fn</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">default_weight</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">scale</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">center</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Position nodes using Fruchterman-Reingold force-directed algorithm.</span>

<span class="sd">    The algorithm simulates a force-directed representation of the network</span>
<span class="sd">    treating edges as springs holding nodes close, while treating nodes</span>
<span class="sd">    as repelling objects, sometimes called an anti-gravity force.</span>
<span class="sd">    Simulation continues until the positions are close to an equilibrium.</span>

<span class="sd">    :param graph: Graph to be used. Can either be a</span>
<span class="sd">        :class:`~rustworkx.PyGraph` or :class:`~rustworkx.PyDiGraph`.</span>
<span class="sd">    :param dict pos:</span>
<span class="sd">        Initial node positions as a dictionary with node ids as keys and values</span>
<span class="sd">        as a coordinate list. If ``None``, then use random initial positions.</span>
<span class="sd">        (``default=None``)</span>
<span class="sd">    :param set fixed: Nodes to keep fixed at initial position.</span>
<span class="sd">        Error raised if fixed specified and ``pos`` is not. (``default=None``)</span>
<span class="sd">    :param float  k:</span>
<span class="sd">        Optimal distance between nodes. If ``None`` the distance is set to</span>
<span class="sd">        :math:`\\frac{1}{\\sqrt{n}}` where :math:`n` is the number of nodes.</span>
<span class="sd">        Increase this value to move nodes farther apart. (``default=None``)</span>
<span class="sd">    :param int repulsive_exponent:</span>
<span class="sd">        Repulsive force exponent. (``default=2``)</span>
<span class="sd">    :param bool adaptive_cooling:</span>
<span class="sd">        Use an adaptive cooling scheme. If set to ``False``,</span>
<span class="sd">        a linear cooling scheme is used. (``default=True``)</span>
<span class="sd">    :param int num_iter:</span>
<span class="sd">        Maximum number of iterations. (``default=50``)</span>
<span class="sd">    :param float tol:</span>
<span class="sd">        Threshold for relative error in node position changes.</span>
<span class="sd">        The iteration stops if the error is below this threshold.</span>
<span class="sd">        (``default = 1e-6``)</span>
<span class="sd">    :param weight_fn: An optional weight function for an edge. It will accept</span>
<span class="sd">        a single argument, the edge&#39;s weight object and will return a float</span>
<span class="sd">        which will be used to represent the weight of the edge.</span>
<span class="sd">    :param float (default=1) default_weight: If ``weight_fn`` isn&#39;t specified</span>
<span class="sd">        this optional float value will be used for the weight/cost of each edge</span>
<span class="sd">    :param float|None scale: Scale factor for positions.</span>
<span class="sd">        Not used unless fixed is None. If scale is ``None``, no re-scaling is</span>
<span class="sd">        performed. (``default=1.0``)</span>
<span class="sd">    :param list center: Coordinate pair around which to center</span>
<span class="sd">        the layout. Not used unless fixed is ``None``. (``default=None``)</span>
<span class="sd">    :param int seed: An optional seed to use for the random number generator</span>

<span class="sd">    :returns: A dictionary of positions keyed by node id.</span>
<span class="sd">    :rtype: dict</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Invalid Input Type </span><span class="si">%s</span><span class="s2"> for graph&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">graph</span><span class="p">))</span></div>


<span class="nd">@spring_layout</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">PyDiGraph</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_digraph_spring_layout</span><span class="p">(</span>
    <span class="n">graph</span><span class="p">,</span>
    <span class="n">pos</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">fixed</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">k</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">repulsive_exponent</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
    <span class="n">adaptive_cooling</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">num_iter</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span>
    <span class="n">tol</span><span class="o">=</span><span class="mf">1e-6</span><span class="p">,</span>
    <span class="n">weight_fn</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">default_weight</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">scale</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">center</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>
    <span class="k">return</span> <span class="n">digraph_spring_layout</span><span class="p">(</span>
        <span class="n">graph</span><span class="p">,</span>
        <span class="n">pos</span><span class="p">,</span>
        <span class="n">fixed</span><span class="p">,</span>
        <span class="n">k</span><span class="p">,</span>
        <span class="n">repulsive_exponent</span><span class="p">,</span>
        <span class="n">adaptive_cooling</span><span class="p">,</span>
        <span class="n">num_iter</span><span class="p">,</span>
        <span class="n">tol</span><span class="p">,</span>
        <span class="n">weight_fn</span><span class="p">,</span>
        <span class="n">default_weight</span><span class="p">,</span>
        <span class="n">scale</span><span class="p">,</span>
        <span class="n">center</span><span class="p">,</span>
        <span class="n">seed</span><span class="p">,</span>
    <span class="p">)</span>


<span class="nd">@spring_layout</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">PyGraph</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_graph_spring_layout</span><span class="p">(</span>
    <span class="n">graph</span><span class="p">,</span>
    <span class="n">pos</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">fixed</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">k</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">repulsive_exponent</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
    <span class="n">adaptive_cooling</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">num_iter</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span>
    <span class="n">tol</span><span class="o">=</span><span class="mf">1e-6</span><span class="p">,</span>
    <span class="n">weight_fn</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">default_weight</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">scale</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">center</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>
    <span class="k">return</span> <span class="n">graph_spring_layout</span><span class="p">(</span>
        <span class="n">graph</span><span class="p">,</span>
        <span class="n">pos</span><span class="p">,</span>
        <span class="n">fixed</span><span class="p">,</span>
        <span class="n">k</span><span class="p">,</span>
        <span class="n">repulsive_exponent</span><span class="p">,</span>
        <span class="n">adaptive_cooling</span><span class="p">,</span>
        <span class="n">num_iter</span><span class="p">,</span>
        <span class="n">tol</span><span class="p">,</span>
        <span class="n">weight_fn</span><span class="p">,</span>
        <span class="n">default_weight</span><span class="p">,</span>
        <span class="n">scale</span><span class="p">,</span>
        <span class="n">center</span><span class="p">,</span>
        <span class="n">seed</span><span class="p">,</span>
    <span class="p">)</span>


<div class="viewcode-block" id="networkx_converter"><a class="viewcode-back" href="../apiref/rustworkx.networkx_converter.html#rustworkx.networkx_converter">[docs]</a><span class="k">def</span> <span class="nf">networkx_converter</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">keep_attributes</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Convert a networkx graph object into a rustworkx graph object.</span>

<span class="sd">    .. note::</span>

<span class="sd">        networkx is **not** a dependency of rustworkx and this function</span>
<span class="sd">        is provided as a convenience method for users of both networkx and</span>
<span class="sd">        rustworkx. This function will not work unless you install networkx</span>
<span class="sd">        independently.</span>

<span class="sd">    :param networkx.Graph graph: The networkx graph to convert.</span>
<span class="sd">    :param bool keep_attributes: If ``True``, add networkx node attributes to</span>
<span class="sd">        the data payload in the nodes of the output rustworkx graph. When set to</span>
<span class="sd">        ``True``, the node data payloads in the output rustworkx graph object</span>
<span class="sd">        will be dictionaries with the node attributes from the input networkx</span>
<span class="sd">        graph where the ``&quot;__networkx_node__&quot;`` key contains the node from the</span>
<span class="sd">        input networkx graph.</span>

<span class="sd">    :returns: A rustworkx graph, either a :class:`~rustworkx.PyDiGraph` or a</span>
<span class="sd">        :class:`~rustworkx.PyGraph` based on whether the input graph is directed</span>
<span class="sd">        or not.</span>
<span class="sd">    :rtype: :class:`~rustworkx.PyDiGraph` or :class:`~rustworkx.PyGraph`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">graph</span><span class="o">.</span><span class="n">is_directed</span><span class="p">():</span>
        <span class="n">new_graph</span> <span class="o">=</span> <span class="n">PyDiGraph</span><span class="p">(</span><span class="n">multigraph</span><span class="o">=</span><span class="n">graph</span><span class="o">.</span><span class="n">is_multigraph</span><span class="p">())</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">new_graph</span> <span class="o">=</span> <span class="n">PyGraph</span><span class="p">(</span><span class="n">multigraph</span><span class="o">=</span><span class="n">graph</span><span class="o">.</span><span class="n">is_multigraph</span><span class="p">())</span>
    <span class="n">nodes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span>
    <span class="n">node_indices</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span> <span class="n">new_graph</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">(</span><span class="n">nodes</span><span class="p">)))</span>
    <span class="n">new_graph</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">(</span>
        <span class="p">[(</span><span class="n">node_indices</span><span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">node_indices</span><span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="kc">True</span><span class="p">)]</span>
    <span class="p">)</span>

    <span class="k">if</span> <span class="n">keep_attributes</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">node</span><span class="p">,</span> <span class="n">node_index</span> <span class="ow">in</span> <span class="n">node_indices</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">attributes</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node</span><span class="p">]</span>
            <span class="n">attributes</span><span class="p">[</span><span class="s2">&quot;__networkx_node__&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">node</span>
            <span class="n">new_graph</span><span class="p">[</span><span class="n">node_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">attributes</span>

    <span class="k">return</span> <span class="n">new_graph</span></div>


<div class="viewcode-block" id="bipartite_layout"><a class="viewcode-back" href="../apiref/rustworkx.bipartite_layout.html#rustworkx.bipartite_layout">[docs]</a><span class="nd">@functools</span><span class="o">.</span><span class="n">singledispatch</span>
<span class="k">def</span> <span class="nf">bipartite_layout</span><span class="p">(</span>
    <span class="n">graph</span><span class="p">,</span>
    <span class="n">first_nodes</span><span class="p">,</span>
    <span class="n">horizontal</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">scale</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">center</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">aspect_ratio</span><span class="o">=</span><span class="mi">4</span> <span class="o">/</span> <span class="mi">3</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Generate a bipartite layout of the graph</span>

<span class="sd">    :param graph: The graph to generate the layout for. Can either be a</span>
<span class="sd">        :class:`~rustworkx.PyGraph` or :class:`~rustworkx.PyDiGraph`</span>
<span class="sd">    :param set first_nodes: The set of node indices on the left (or top if</span>
<span class="sd">        horitontal is true)</span>
<span class="sd">    :param bool horizontal: An optional bool specifying the orientation of the</span>
<span class="sd">        layout</span>
<span class="sd">    :param float scale: An optional scaling factor to scale positions</span>
<span class="sd">    :param tuple center: An optional center position. This is a 2 tuple of two</span>
<span class="sd">        ``float`` values for the center position</span>
<span class="sd">    :param float aspect_ratio: An optional number for the ratio of the width to</span>
<span class="sd">        the height of the layout.</span>

<span class="sd">    :returns: The bipartite layout of the graph.</span>
<span class="sd">    :rtype: Pos2DMapping</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Invalid Input Type </span><span class="si">%s</span><span class="s2"> for graph&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">graph</span><span class="p">))</span></div>


<span class="nd">@bipartite_layout</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">PyDiGraph</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_digraph_bipartite_layout</span><span class="p">(</span>
    <span class="n">graph</span><span class="p">,</span>
    <span class="n">first_nodes</span><span class="p">,</span>
    <span class="n">horizontal</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">scale</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">center</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">aspect_ratio</span><span class="o">=</span><span class="mi">4</span> <span class="o">/</span> <span class="mi">3</span><span class="p">,</span>
<span class="p">):</span>
    <span class="k">return</span> <span class="n">digraph_bipartite_layout</span><span class="p">(</span>
        <span class="n">graph</span><span class="p">,</span>
        <span class="n">first_nodes</span><span class="p">,</span>
        <span class="n">horizontal</span><span class="o">=</span><span class="n">horizontal</span><span class="p">,</span>
        <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">,</span>
        <span class="n">center</span><span class="o">=</span><span class="n">center</span><span class="p">,</span>
        <span class="n">aspect_ratio</span><span class="o">=</span><span class="n">aspect_ratio</span><span class="p">,</span>
    <span class="p">)</span>


<span class="nd">@bipartite_layout</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">PyGraph</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_graph_bipartite_layout</span><span class="p">(</span>
    <span class="n">graph</span><span class="p">,</span>
    <span class="n">first_nodes</span><span class="p">,</span>
    <span class="n">horizontal</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">scale</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">center</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">aspect_ratio</span><span class="o">=</span><span class="mi">4</span> <span class="o">/</span> <span class="mi">3</span><span class="p">,</span>
<span class="p">):</span>
    <span class="k">return</span> <span class="n">graph_bipartite_layout</span><span class="p">(</span>
        <span class="n">graph</span><span class="p">,</span>
        <span class="n">first_nodes</span><span class="p">,</span>
        <span class="n">horizontal</span><span class="o">=</span><span class="n">horizontal</span><span class="p">,</span>
        <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">,</span>
        <span class="n">center</span><span class="o">=</span><span class="n">center</span><span class="p">,</span>
        <span class="n">aspect_ratio</span><span class="o">=</span><span class="n">aspect_ratio</span><span class="p">,</span>
    <span class="p">)</span>


<div class="viewcode-block" id="circular_layout"><a class="viewcode-back" href="../apiref/rustworkx.circular_layout.html#rustworkx.circular_layout">[docs]</a><span class="nd">@functools</span><span class="o">.</span><span class="n">singledispatch</span>
<span class="k">def</span> <span class="nf">circular_layout</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Generate a circular layout of the graph</span>

<span class="sd">    :param graph: The graph to generate the layout for. Can either be a</span>
<span class="sd">        :class:`~rustworkx.PyGraph` or :class:`~rustworkx.PyDiGraph`</span>
<span class="sd">    :param float scale: An optional scaling factor to scale positions</span>
<span class="sd">    :param tuple center: An optional center position. This is a 2 tuple of two</span>
<span class="sd">        ``float`` values for the center position</span>

<span class="sd">    :returns: The circular layout of the graph.</span>
<span class="sd">    :rtype: Pos2DMapping</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Invalid Input Type </span><span class="si">%s</span><span class="s2"> for graph&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">graph</span><span class="p">))</span></div>


<span class="nd">@circular_layout</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">PyDiGraph</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_digraph_circular_layout</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">digraph_circular_layout</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="n">center</span><span class="p">)</span>


<span class="nd">@circular_layout</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">PyGraph</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_graph_circular_layout</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">graph_circular_layout</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="n">center</span><span class="p">)</span>


<div class="viewcode-block" id="shell_layout"><a class="viewcode-back" href="../apiref/rustworkx.shell_layout.html#rustworkx.shell_layout">[docs]</a><span class="nd">@functools</span><span class="o">.</span><span class="n">singledispatch</span>
<span class="k">def</span> <span class="nf">shell_layout</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">nlist</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">rotate</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate a shell layout of the graph</span>

<span class="sd">    :param graph: The graph to generate the layout for. Can either be a</span>
<span class="sd">        :class:`~rustworkx.PyGraph` or :class:`~rustworkx.PyDiGraph`</span>
<span class="sd">    :param list nlist: The list of lists of indices which represents each shell</span>
<span class="sd">    :param float rotate: Angle (in radians) by which to rotate the starting</span>
<span class="sd">        position of each shell relative to the starting position of the</span>
<span class="sd">        previous shell</span>
<span class="sd">    :param float scale: An optional scaling factor to scale positions</span>
<span class="sd">    :param tuple center: An optional center position. This is a 2 tuple of two</span>
<span class="sd">        ``float`` values for the center position</span>

<span class="sd">    :returns: The shell layout of the graph.</span>
<span class="sd">    :rtype: Pos2DMapping</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Invalid Input Type </span><span class="si">%s</span><span class="s2"> for graph&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">graph</span><span class="p">))</span></div>


<span class="nd">@shell_layout</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">PyDiGraph</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_digraph_shell_layout</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">nlist</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">rotate</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">digraph_shell_layout</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">nlist</span><span class="o">=</span><span class="n">nlist</span><span class="p">,</span> <span class="n">rotate</span><span class="o">=</span><span class="n">rotate</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="n">center</span><span class="p">)</span>


<span class="nd">@shell_layout</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">PyGraph</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_graph_shell_layout</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">nlist</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">rotate</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">graph_shell_layout</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">nlist</span><span class="o">=</span><span class="n">nlist</span><span class="p">,</span> <span class="n">rotate</span><span class="o">=</span><span class="n">rotate</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="n">center</span><span class="p">)</span>


<div class="viewcode-block" id="spiral_layout"><a class="viewcode-back" href="../apiref/rustworkx.spiral_layout.html#rustworkx.spiral_layout">[docs]</a><span class="nd">@functools</span><span class="o">.</span><span class="n">singledispatch</span>
<span class="k">def</span> <span class="nf">spiral_layout</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">resolution</span><span class="o">=</span><span class="mf">0.35</span><span class="p">,</span> <span class="n">equidistant</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate a spiral layout of the graph</span>

<span class="sd">    :param graph: The graph to generate the layout for. Can either be a</span>
<span class="sd">        :class:`~rustworkx.PyGraph` or :class:`~rustworkx.PyDiGraph`</span>
<span class="sd">    :param float scale: An optional scaling factor to scale positions</span>
<span class="sd">    :param tuple center: An optional center position. This is a 2 tuple of two</span>
<span class="sd">        ``float`` values for the center position</span>
<span class="sd">    :param float resolution: The compactness of the spiral layout returned.</span>
<span class="sd">        Lower values result in more compressed spiral layouts.</span>
<span class="sd">    :param bool equidistant: If true, nodes will be plotted equidistant from</span>
<span class="sd">        each other.</span>

<span class="sd">    :returns: The spiral layout of the graph.</span>
<span class="sd">    :rtype: Pos2DMapping</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Invalid Input Type </span><span class="si">%s</span><span class="s2"> for graph&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">graph</span><span class="p">))</span></div>


<span class="nd">@spiral_layout</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">PyDiGraph</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_digraph_spiral_layout</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">resolution</span><span class="o">=</span><span class="mf">0.35</span><span class="p">,</span> <span class="n">equidistant</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">digraph_spiral_layout</span><span class="p">(</span>
        <span class="n">graph</span><span class="p">,</span>
        <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">,</span>
        <span class="n">center</span><span class="o">=</span><span class="n">center</span><span class="p">,</span>
        <span class="n">resolution</span><span class="o">=</span><span class="n">resolution</span><span class="p">,</span>
        <span class="n">equidistant</span><span class="o">=</span><span class="n">equidistant</span><span class="p">,</span>
    <span class="p">)</span>


<span class="nd">@spiral_layout</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">PyGraph</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_graph_spiral_layout</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">resolution</span><span class="o">=</span><span class="mf">0.35</span><span class="p">,</span> <span class="n">equidistant</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">graph_spiral_layout</span><span class="p">(</span>
        <span class="n">graph</span><span class="p">,</span>
        <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">,</span>
        <span class="n">center</span><span class="o">=</span><span class="n">center</span><span class="p">,</span>
        <span class="n">resolution</span><span class="o">=</span><span class="n">resolution</span><span class="p">,</span>
        <span class="n">equidistant</span><span class="o">=</span><span class="n">equidistant</span><span class="p">,</span>
    <span class="p">)</span>


<div class="viewcode-block" id="num_shortest_paths_unweighted"><a class="viewcode-back" href="../apiref/rustworkx.num_shortest_paths_unweighted.html#rustworkx.num_shortest_paths_unweighted">[docs]</a><span class="nd">@functools</span><span class="o">.</span><span class="n">singledispatch</span>
<span class="k">def</span> <span class="nf">num_shortest_paths_unweighted</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">source</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Get the number of unweighted shortest paths from a source node</span>

<span class="sd">    :param PyDiGraph graph: The graph to find the number of shortest paths on</span>
<span class="sd">    :param int source: The source node to find the shortest paths from</span>

<span class="sd">    :returns: A mapping of target node indices to the number of shortest paths</span>
<span class="sd">        from ``source`` to that node. If there is no path from ``source`` to</span>
<span class="sd">        a node in the graph that node will not be preset in the output mapping.</span>
<span class="sd">    :rtype: NodesCountMapping</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Invalid input type </span><span class="si">%s</span><span class="s2"> for graph&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">graph</span><span class="p">))</span></div>


<span class="nd">@num_shortest_paths_unweighted</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">PyDiGraph</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_digraph_num_shortest_paths_unweighted</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">source</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">digraph_num_shortest_paths_unweighted</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">source</span><span class="p">)</span>


<span class="nd">@num_shortest_paths_unweighted</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">PyGraph</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_graph_num_shortest_paths_unweighted</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">source</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">graph_num_shortest_paths_unweighted</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">source</span><span class="p">)</span>


<div class="viewcode-block" id="betweenness_centrality"><a class="viewcode-back" href="../apiref/rustworkx.betweenness_centrality.html#rustworkx.betweenness_centrality">[docs]</a><span class="nd">@functools</span><span class="o">.</span><span class="n">singledispatch</span>
<span class="k">def</span> <span class="nf">betweenness_centrality</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">normalized</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">endpoints</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">parallel_threshold</span><span class="o">=</span><span class="mi">50</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Returns the betweenness centrality of each node in the graph.</span>

<span class="sd">    Betweenness centrality of a node :math:`v` is the sum of the</span>
<span class="sd">    fraction of all-pairs shortest paths that pass through :math`v`</span>

<span class="sd">    .. math::</span>

<span class="sd">       c_B(v) =\sum_{s,t \in V} \frac{\sigma(s, t|v)}{\sigma(s, t)}</span>

<span class="sd">    where :math:`V` is the set of nodes, :math:`\sigma(s, t)` is the number of</span>
<span class="sd">    shortest :math`(s, t)` paths, and :math:`\sigma(s, t|v)` is the number of</span>
<span class="sd">    those paths  passing through some  node :math:`v` other than :math:`s, t`.</span>
<span class="sd">    If :math:`s = t`, :math:`\sigma(s, t) = 1`, and if :math:`v \in {s, t}`,</span>
<span class="sd">    :math:`\sigma(s, t|v) = 0`</span>

<span class="sd">    The algorithm used in this function is based on:</span>

<span class="sd">    Ulrik Brandes, A Faster Algorithm for Betweenness Centrality.</span>
<span class="sd">    Journal of Mathematical Sociology 25(2):163-177, 2001.</span>

<span class="sd">    This function is multithreaded and will run in parallel if the number</span>
<span class="sd">    of nodes in the graph is above the value of ``parallel_threshold`` (it</span>
<span class="sd">    defaults to 50). If the function will be running in parallel the env var</span>
<span class="sd">    ``RAYON_NUM_THREADS`` can be used to adjust how many threads will be used.</span>

<span class="sd">    :param PyDiGraph graph: The input graph</span>
<span class="sd">    :param bool normalized: Whether to normalize the betweenness scores by</span>
<span class="sd">        the number of distinct paths between all pairs of nodes.</span>
<span class="sd">    :param bool endpoints: Whether to include the endpoints of paths in</span>
<span class="sd">        path lengths used to compute the betweenness.</span>
<span class="sd">    :param int parallel_threshold: The number of nodes to calculate the</span>
<span class="sd">        the betweenness centrality in parallel at if the number of nodes in</span>
<span class="sd">        the graph is less than this value it will run in a single thread. The</span>
<span class="sd">        default value is 50</span>

<span class="sd">    :returns: A dictionary mapping each node index to its betweenness centrality.</span>
<span class="sd">    :rtype: dict</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Invalid input type </span><span class="si">%s</span><span class="s2"> for graph&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">graph</span><span class="p">))</span></div>


<span class="nd">@betweenness_centrality</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">PyDiGraph</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_digraph_betweenness_centrality</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">normalized</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">endpoints</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">parallel_threshold</span><span class="o">=</span><span class="mi">50</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">digraph_betweenness_centrality</span><span class="p">(</span>
        <span class="n">graph</span><span class="p">,</span>
        <span class="n">normalized</span><span class="o">=</span><span class="n">normalized</span><span class="p">,</span>
        <span class="n">endpoints</span><span class="o">=</span><span class="n">endpoints</span><span class="p">,</span>
        <span class="n">parallel_threshold</span><span class="o">=</span><span class="n">parallel_threshold</span><span class="p">,</span>
    <span class="p">)</span>


<span class="nd">@betweenness_centrality</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">PyGraph</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_graph_betweenness_centrality</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">normalized</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">endpoints</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">parallel_threshold</span><span class="o">=</span><span class="mi">50</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">graph_betweenness_centrality</span><span class="p">(</span>
        <span class="n">graph</span><span class="p">,</span>
        <span class="n">normalized</span><span class="o">=</span><span class="n">normalized</span><span class="p">,</span>
        <span class="n">endpoints</span><span class="o">=</span><span class="n">endpoints</span><span class="p">,</span>
        <span class="n">parallel_threshold</span><span class="o">=</span><span class="n">parallel_threshold</span><span class="p">,</span>
    <span class="p">)</span>


<div class="viewcode-block" id="eigenvector_centrality"><a class="viewcode-back" href="../apiref/rustworkx.eigenvector_centrality.html#rustworkx.eigenvector_centrality">[docs]</a><span class="nd">@functools</span><span class="o">.</span><span class="n">singledispatch</span>
<span class="k">def</span> <span class="nf">eigenvector_centrality</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">weight_fn</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">default_weight</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">max_iter</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">1e-6</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute the eigenvector centrality of a graph.</span>

<span class="sd">    For details on the eigenvector centrality refer to:</span>

<span class="sd">    Phillip Bonacich. Power and Centrality: A Family of Measures.</span>
<span class="sd">    American Journal of Sociology 92(5):11701182, 1986</span>
<span class="sd">    &lt;https://doi.org/10.1086/228631&gt;</span>

<span class="sd">    This function uses a power iteration method to compute the eigenvector</span>
<span class="sd">    and convergence is not guaranteed. The function will stop when `max_iter`</span>
<span class="sd">    iterations is reached or when the computed vector between two iterations</span>
<span class="sd">    is smaller than the error tolerance multiplied by the number of nodes.</span>
<span class="sd">    The implementation of this algorithm is based on the NetworkX</span>
<span class="sd">    `eigenvector_centrality() &lt;https://networkx.org/documentation/stable/reference/algorithms/generated/networkx.algorithms.centrality.eigenvector_centrality.html&gt;`__</span>
<span class="sd">    function.</span>

<span class="sd">    In the case of multigraphs the weights of any parallel edges will be</span>
<span class="sd">    summed when computing the eigenvector centrality.</span>

<span class="sd">    :param graph: Graph to be used. Can either be a</span>
<span class="sd">        :class:`~rustworkx.PyGraph` or :class:`~rustworkx.PyDiGraph`.</span>
<span class="sd">    :param weight_fn: An optional input callable that will be passed the edge&#39;s</span>
<span class="sd">        payload object and is expected to return a `float` weight for that edge.</span>
<span class="sd">        If this is not specified ``default_weight`` will be used as the weight</span>
<span class="sd">        for every edge in ``graph``</span>
<span class="sd">    :param float default_weight: If ``weight_fn`` is not set the default weight</span>
<span class="sd">        value to use for the weight of all edges</span>
<span class="sd">    :param int max_iter: The maximum number of iterations in the power method. If</span>
<span class="sd">        not specified a default value of 100 is used.</span>
<span class="sd">    :param float tol: The error tolerance used when checking for convergence in the</span>
<span class="sd">        power method. If this is not specified default value of 1e-6 is used.</span>

<span class="sd">    :returns: a read-only dict-like object whose keys are the node indices and values are the</span>
<span class="sd">         centrality score for that node.</span>
<span class="sd">    :rtype: CentralityMapping</span>
<span class="sd">    &quot;&quot;&quot;</span></div>


<span class="nd">@eigenvector_centrality</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">PyDiGraph</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_digraph_eigenvector_centrality</span><span class="p">(</span>
    <span class="n">graph</span><span class="p">,</span> <span class="n">weight_fn</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">default_weight</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">max_iter</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">1e-6</span>
<span class="p">):</span>
    <span class="k">return</span> <span class="n">digraph_eigenvector_centrality</span><span class="p">(</span>
        <span class="n">graph</span><span class="p">,</span> <span class="n">weight_fn</span><span class="o">=</span><span class="n">weight_fn</span><span class="p">,</span> <span class="n">default_weight</span><span class="o">=</span><span class="n">default_weight</span><span class="p">,</span> <span class="n">max_iter</span><span class="o">=</span><span class="n">max_iter</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="n">tol</span>
    <span class="p">)</span>


<span class="nd">@eigenvector_centrality</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">PyGraph</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_graph_eigenvector_centrality</span><span class="p">(</span>
    <span class="n">graph</span><span class="p">,</span> <span class="n">weight_fn</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">default_weight</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">max_iter</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">1e-6</span>
<span class="p">):</span>
    <span class="k">return</span> <span class="n">graph_eigenvector_centrality</span><span class="p">(</span>
        <span class="n">graph</span><span class="p">,</span> <span class="n">weight_fn</span><span class="o">=</span><span class="n">weight_fn</span><span class="p">,</span> <span class="n">default_weight</span><span class="o">=</span><span class="n">default_weight</span><span class="p">,</span> <span class="n">max_iter</span><span class="o">=</span><span class="n">max_iter</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="n">tol</span>
    <span class="p">)</span>


<div class="viewcode-block" id="vf2_mapping"><a class="viewcode-back" href="../apiref/rustworkx.vf2_mapping.html#rustworkx.vf2_mapping">[docs]</a><span class="nd">@functools</span><span class="o">.</span><span class="n">singledispatch</span>
<span class="k">def</span> <span class="nf">vf2_mapping</span><span class="p">(</span>
    <span class="n">first</span><span class="p">,</span>
    <span class="n">second</span><span class="p">,</span>
    <span class="n">node_matcher</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">edge_matcher</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">id_order</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">subgraph</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">induced</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">call_limit</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return an iterator over all vf2 mappings between two graphs.</span>

<span class="sd">    This funcion will run the vf2 algorithm used from</span>
<span class="sd">    :func:`~rustworkx.is_isomorphic` and :func:`~rustworkx.is_subgraph_isomorphic`</span>
<span class="sd">    but instead of returning a boolean it will return an iterator over all possible</span>
<span class="sd">    mapping of node ids found from ``first`` to ``second``. If the graphs are not</span>
<span class="sd">    isomorphic then the iterator will be empty. A simple example that retrieves</span>
<span class="sd">    one mapping would be::</span>

<span class="sd">            graph_a = rustworkx.generators.path_graph(3)</span>
<span class="sd">            graph_b = rustworkx.generators.path_graph(2)</span>
<span class="sd">            vf2 = rustworkx.vf2_mapping(graph_a, graph_b, subgraph=True)</span>
<span class="sd">            try:</span>
<span class="sd">                mapping = next(vf2)</span>
<span class="sd">            except StopIteration:</span>
<span class="sd">                pass</span>

<span class="sd">    :param first: The first graph to find the mapping for</span>
<span class="sd">    :param second: The second graph to find the mapping for</span>
<span class="sd">    :param node_matcher: An optional python callable object that takes 2</span>
<span class="sd">        positional arguments, one for each node data object in either graph.</span>
<span class="sd">        If the return of this function evaluates to True then the nodes</span>
<span class="sd">        passed to it are viewed as matching.</span>
<span class="sd">    :param edge_matcher: A python callable object that takes 2 positional</span>
<span class="sd">        one for each edge data object. If the return of this</span>
<span class="sd">        function evaluates to True then the edges passed to it are viewed</span>
<span class="sd">        as matching.</span>
<span class="sd">    :param bool id_order: If set to ``False`` this function will use a</span>
<span class="sd">        heuristic matching order based on [VF2]_ paper. Otherwise it will</span>
<span class="sd">        default to matching the nodes in order specified by their ids.</span>
<span class="sd">    :param bool subgraph: If set to ``True`` the function will return the</span>
<span class="sd">        subgraph isomorphic found between the graphs.</span>
<span class="sd">    :param bool induced: If set to ``True`` this function will check the existence</span>
<span class="sd">        of a node-induced subgraph of first isomorphic to second graph.</span>
<span class="sd">        Default: ``True``.</span>
<span class="sd">    :param int call_limit: An optional bound on the number of states that VF2</span>
<span class="sd">        algorithm visits while searching for a solution. If it exceeds this limit,</span>
<span class="sd">        the algorithm will stop. Default: ``None``.</span>

<span class="sd">    :returns: An iterator over dicitonaries of node indices from ``first`` to node</span>
<span class="sd">        indices in ``second`` representing the mapping found.</span>
<span class="sd">    :rtype: Iterable[NodeMap]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Invalid Input Type </span><span class="si">%s</span><span class="s2"> for graph&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">first</span><span class="p">))</span></div>


<span class="nd">@vf2_mapping</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">PyDiGraph</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_digraph_vf2_mapping</span><span class="p">(</span>
    <span class="n">first</span><span class="p">,</span>
    <span class="n">second</span><span class="p">,</span>
    <span class="n">node_matcher</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">edge_matcher</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">id_order</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">subgraph</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">induced</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">call_limit</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>
    <span class="k">return</span> <span class="n">digraph_vf2_mapping</span><span class="p">(</span>
        <span class="n">first</span><span class="p">,</span>
        <span class="n">second</span><span class="p">,</span>
        <span class="n">node_matcher</span><span class="o">=</span><span class="n">node_matcher</span><span class="p">,</span>
        <span class="n">edge_matcher</span><span class="o">=</span><span class="n">edge_matcher</span><span class="p">,</span>
        <span class="n">id_order</span><span class="o">=</span><span class="n">id_order</span><span class="p">,</span>
        <span class="n">subgraph</span><span class="o">=</span><span class="n">subgraph</span><span class="p">,</span>
        <span class="n">induced</span><span class="o">=</span><span class="n">induced</span><span class="p">,</span>
        <span class="n">call_limit</span><span class="o">=</span><span class="n">call_limit</span><span class="p">,</span>
    <span class="p">)</span>


<span class="nd">@vf2_mapping</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">PyGraph</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_graph_vf2_mapping</span><span class="p">(</span>
    <span class="n">first</span><span class="p">,</span>
    <span class="n">second</span><span class="p">,</span>
    <span class="n">node_matcher</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">edge_matcher</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">id_order</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">subgraph</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">induced</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">call_limit</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>
    <span class="k">return</span> <span class="n">graph_vf2_mapping</span><span class="p">(</span>
        <span class="n">first</span><span class="p">,</span>
        <span class="n">second</span><span class="p">,</span>
        <span class="n">node_matcher</span><span class="o">=</span><span class="n">node_matcher</span><span class="p">,</span>
        <span class="n">edge_matcher</span><span class="o">=</span><span class="n">edge_matcher</span><span class="p">,</span>
        <span class="n">id_order</span><span class="o">=</span><span class="n">id_order</span><span class="p">,</span>
        <span class="n">subgraph</span><span class="o">=</span><span class="n">subgraph</span><span class="p">,</span>
        <span class="n">induced</span><span class="o">=</span><span class="n">induced</span><span class="p">,</span>
        <span class="n">call_limit</span><span class="o">=</span><span class="n">call_limit</span><span class="p">,</span>
    <span class="p">)</span>


<div class="viewcode-block" id="union"><a class="viewcode-back" href="../apiref/rustworkx.union.html#rustworkx.union">[docs]</a><span class="nd">@functools</span><span class="o">.</span><span class="n">singledispatch</span>
<span class="k">def</span> <span class="nf">union</span><span class="p">(</span>
    <span class="n">first</span><span class="p">,</span>
    <span class="n">second</span><span class="p">,</span>
    <span class="n">merge_nodes</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">merge_edges</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return a new graph by forming a union from two input graph objects</span>

<span class="sd">    The algorithm in this function operates in three phases:</span>

<span class="sd">    1. Add all the nodes from  ``second`` into ``first``. operates in</span>
<span class="sd">    :math:`\\mathcal{O}(n_2)`, with :math:`n_2` being number of nodes in</span>
<span class="sd">    ``second``.</span>
<span class="sd">    2. Merge nodes from ``second`` over ``first`` given that:</span>

<span class="sd">       - The ``merge_nodes`` is ``True``. operates in :math:`\\mathcal{O}(n_1 n_2)`,</span>
<span class="sd">         with :math:`n_1` being the number of nodes in ``first`` and :math:`n_2`</span>
<span class="sd">         the number of nodes in ``second``</span>
<span class="sd">       - The respective node in ``second`` and ``first`` share the same</span>
<span class="sd">         weight/data payload.</span>

<span class="sd">    3. Adds all the edges from ``second`` to ``first``. If the ``merge_edges``</span>
<span class="sd">       parameter is ``True`` and the respective edge in ``second`` and</span>
<span class="sd">       ``first`` share the same weight/data payload they will be merged together.</span>

<span class="sd">    :param first: The first graph object</span>
<span class="sd">    :param second: The second graph object</span>
<span class="sd">    :param bool merge_nodes: If set to ``True`` nodes will be merged between</span>
<span class="sd">        ``second`` and ``first`` if the weights are equal. Default: ``False``.</span>
<span class="sd">    :param bool merge_edges: If set to ``True`` edges will be merged between</span>
<span class="sd">        ``second`` and ``first`` if the weights are equal. Default: ``False``.</span>

<span class="sd">    :returns: A new graph object that is the union of ``second`` and</span>
<span class="sd">        ``first``. It&#39;s worth noting the weight/data payload objects are</span>
<span class="sd">        passed by reference from ``first`` and ``second`` to this new object.</span>
<span class="sd">    :rtype: :class:`~rustworkx.PyGraph` or :class:`~rustworkx.PyDiGraph`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Invalid Input Type </span><span class="si">%s</span><span class="s2"> for graph&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">first</span><span class="p">))</span></div>


<span class="nd">@union</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">PyDiGraph</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_digraph_union</span><span class="p">(</span>
    <span class="n">first</span><span class="p">,</span>
    <span class="n">second</span><span class="p">,</span>
    <span class="n">merge_nodes</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">merge_edges</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
<span class="p">):</span>
    <span class="k">return</span> <span class="n">digraph_union</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">second</span><span class="p">,</span> <span class="n">merge_nodes</span><span class="o">=</span><span class="n">merge_nodes</span><span class="p">,</span> <span class="n">merge_edges</span><span class="o">=</span><span class="n">merge_edges</span><span class="p">)</span>


<span class="nd">@union</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">PyGraph</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_graph_union</span><span class="p">(</span>
    <span class="n">first</span><span class="p">,</span>
    <span class="n">second</span><span class="p">,</span>
    <span class="n">merge_nodes</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">merge_edges</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
<span class="p">):</span>
    <span class="k">return</span> <span class="n">graph_union</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">second</span><span class="p">,</span> <span class="n">merge_nodes</span><span class="o">=</span><span class="n">merge_nodes</span><span class="p">,</span> <span class="n">merge_edges</span><span class="o">=</span><span class="n">merge_edges</span><span class="p">)</span>


<span class="nd">@functools</span><span class="o">.</span><span class="n">singledispatch</span>
<span class="k">def</span> <span class="nf">tensor_product</span><span class="p">(</span>
    <span class="n">first</span><span class="p">,</span>
    <span class="n">second</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return a new graph by forming the tensor product</span>
<span class="sd">    from two input graph objects</span>

<span class="sd">    :param first: The first graph object</span>
<span class="sd">    :param second: The second graph object</span>

<span class="sd">    :returns: A new graph object that is the tensor product of ``second`` and</span>
<span class="sd">        ``first``. It&#39;s worth noting the weight/data payload objects are</span>
<span class="sd">        passed by reference from ``first`` and ``second`` to this new object.</span>
<span class="sd">        A read-only dictionary of the product of nodes is also returned. The keys</span>
<span class="sd">        are a tuple where the first element is a node of the first graph and the</span>
<span class="sd">        second element is a node of the second graph, and the values are the map</span>
<span class="sd">        of those elements to node indices in the product graph. For example::</span>

<span class="sd">            {</span>
<span class="sd">                (0, 0): 0,</span>
<span class="sd">                (0, 1): 1,</span>
<span class="sd">            }</span>

<span class="sd">    :rtype: Tuple[:class:`~rustworkx.PyGraph` or :class:`~rustworkx.PyDiGraph`,</span>
<span class="sd">        :class:`~rustworkx.ProductNodeMap`]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Invalid Input Type </span><span class="si">%s</span><span class="s2"> for graph&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">first</span><span class="p">))</span>


<span class="nd">@tensor_product</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">PyDiGraph</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_digraph_tensor_product</span><span class="p">(</span>
    <span class="n">first</span><span class="p">,</span>
    <span class="n">second</span><span class="p">,</span>
<span class="p">):</span>
    <span class="k">return</span> <span class="n">digraph_tensor_product</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">second</span><span class="p">)</span>


<span class="nd">@tensor_product</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">PyGraph</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_graph_tensor_product</span><span class="p">(</span>
    <span class="n">first</span><span class="p">,</span>
    <span class="n">second</span><span class="p">,</span>
<span class="p">):</span>
    <span class="k">return</span> <span class="n">graph_tensor_product</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">second</span><span class="p">)</span>


<div class="viewcode-block" id="cartesian_product"><a class="viewcode-back" href="../apiref/rustworkx.cartesian_product.html#rustworkx.cartesian_product">[docs]</a><span class="nd">@functools</span><span class="o">.</span><span class="n">singledispatch</span>
<span class="k">def</span> <span class="nf">cartesian_product</span><span class="p">(</span>
    <span class="n">first</span><span class="p">,</span>
    <span class="n">second</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return a new graph by forming the cartesian product</span>
<span class="sd">    from two input graph objects</span>

<span class="sd">    :param first: The first graph object</span>
<span class="sd">    :param second: The second graph object</span>

<span class="sd">    :returns: A new graph object that is the union of ``second`` and</span>
<span class="sd">        ``first``. It&#39;s worth noting the weight/data payload objects are</span>
<span class="sd">        passed by reference from ``first`` and ``second`` to this new object.</span>
<span class="sd">        A read-only dictionary of the product of nodes is also returned. The keys</span>
<span class="sd">        are a tuple where the first element is a node of the first graph and the</span>
<span class="sd">        second element is a node of the second graph, and the values are the map</span>
<span class="sd">        of those elements to node indices in the product graph. For example::</span>

<span class="sd">            {</span>
<span class="sd">                (0, 0): 0,</span>
<span class="sd">                (0, 1): 1,</span>
<span class="sd">            }</span>

<span class="sd">    :rtype: Tuple[:class:`~rustworkx.PyGraph` or :class:`~rustworkx.PyDiGraph`,</span>
<span class="sd">        :class:`~rustworkx.ProductNodeMap`]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Invalid Input Type </span><span class="si">%s</span><span class="s2"> for graph&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">first</span><span class="p">))</span></div>


<span class="nd">@cartesian_product</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">PyDiGraph</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_digraph_cartesian_product</span><span class="p">(</span>
    <span class="n">first</span><span class="p">,</span>
    <span class="n">second</span><span class="p">,</span>
<span class="p">):</span>
    <span class="k">return</span> <span class="n">digraph_cartesian_product</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">second</span><span class="p">)</span>


<span class="nd">@cartesian_product</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">PyGraph</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_graph_cartesian_product</span><span class="p">(</span>
    <span class="n">first</span><span class="p">,</span>
    <span class="n">second</span><span class="p">,</span>
<span class="p">):</span>
    <span class="k">return</span> <span class="n">graph_cartesian_product</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">second</span><span class="p">)</span>


<div class="viewcode-block" id="bfs_search"><a class="viewcode-back" href="../apiref/rustworkx.bfs_search.html#rustworkx.bfs_search">[docs]</a><span class="nd">@functools</span><span class="o">.</span><span class="n">singledispatch</span>
<span class="k">def</span> <span class="nf">bfs_search</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">visitor</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Breadth-first traversal of a directed/undirected graph.</span>

<span class="sd">    The pseudo-code for the BFS algorithm is listed below, with the annotated</span>
<span class="sd">    event points, for which the given visitor object will be called with the</span>
<span class="sd">    appropriate method.</span>

<span class="sd">    ::</span>

<span class="sd">        BFS(G, s)</span>
<span class="sd">          for each vertex u in V</span>
<span class="sd">              color[u] := WHITE</span>
<span class="sd">          end for</span>
<span class="sd">          color[s] := GRAY</span>
<span class="sd">          EQUEUE(Q, s)                             discover vertex s</span>
<span class="sd">          while (Q != )</span>
<span class="sd">              u := DEQUEUE(Q)</span>
<span class="sd">              for each vertex v in Adj[u]          (u,v) is a tree edge</span>
<span class="sd">                  if (color[v] = WHITE)</span>
<span class="sd">                      color[v] = GRAY</span>
<span class="sd">                  else                             (u,v) is a non - tree edge</span>
<span class="sd">                      if (color[v] = GRAY)         (u,v) has a gray target</span>
<span class="sd">                          ...</span>
<span class="sd">                      else if (color[v] = BLACK)   (u,v) has a black target</span>
<span class="sd">                          ...</span>
<span class="sd">              end for</span>
<span class="sd">              color[u] := BLACK                    finish vertex u</span>
<span class="sd">          end while</span>

<span class="sd">    If an exception is raised inside the callback function, the graph traversal</span>
<span class="sd">    will be stopped immediately. You can exploit this to exit early by raising a</span>
<span class="sd">    :class:`~rustworkx.visit.StopSearch` exception, in which case the search function</span>
<span class="sd">    will return but without raising back the exception. You can also prune part of</span>
<span class="sd">    the search tree by raising :class:`~rustworkx.visit.PruneSearch`.</span>

<span class="sd">    In the following example we keep track of the tree edges:</span>

<span class="sd">    .. jupyter-execute::</span>

<span class="sd">        import rustworkx as rx</span>
<span class="sd">        from rustworkx.visit import BFSVisitor</span>


<span class="sd">        class TreeEdgesRecorder(BFSVisitor):</span>

<span class="sd">            def __init__(self):</span>
<span class="sd">                self.edges = []</span>

<span class="sd">            def tree_edge(self, edge):</span>
<span class="sd">                self.edges.append(edge)</span>

<span class="sd">        graph = rx.PyDiGraph()</span>
<span class="sd">        graph.extend_from_edge_list([(1, 3), (0, 1), (2, 1), (0, 2)])</span>
<span class="sd">        vis = TreeEdgesRecorder()</span>
<span class="sd">        rx.bfs_search(graph, [0], vis)</span>
<span class="sd">        print(&#39;Tree edges:&#39;, vis.edges)</span>

<span class="sd">    .. note::</span>

<span class="sd">        Graph can **not** be mutated while traversing.</span>

<span class="sd">    :param graph: The graph to be used. This can be a :class:`~rustworkx.PyGraph`</span>
<span class="sd">        or a :class:`~rustworkx.PyDiGraph`</span>
<span class="sd">    :param List[int] source: An optional list of node indices to use as the starting</span>
<span class="sd">        nodes for the breadth-first search. If this is not specified then a source</span>
<span class="sd">        will be chosen arbitrarly and repeated until all components of the</span>
<span class="sd">        graph are searched.</span>
<span class="sd">    :param visitor: A visitor object that is invoked at the event points inside the</span>
<span class="sd">        algorithm. This should be a subclass of :class:`~rustworkx.visit.BFSVisitor`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Invalid Input Type </span><span class="si">%s</span><span class="s2"> for graph&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">graph</span><span class="p">))</span></div>


<span class="nd">@bfs_search</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">PyDiGraph</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_digraph_bfs_search</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">visitor</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">digraph_bfs_search</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">visitor</span><span class="p">)</span>


<span class="nd">@bfs_search</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">PyGraph</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_graph_bfs_search</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">visitor</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">graph_bfs_search</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">visitor</span><span class="p">)</span>


<div class="viewcode-block" id="dfs_search"><a class="viewcode-back" href="../apiref/rustworkx.dfs_search.html#rustworkx.dfs_search">[docs]</a><span class="nd">@functools</span><span class="o">.</span><span class="n">singledispatch</span>
<span class="k">def</span> <span class="nf">dfs_search</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">visitor</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Depth-first traversal of a directed/undirected graph.</span>

<span class="sd">    The pseudo-code for the DFS algorithm is listed below, with the annotated</span>
<span class="sd">    event points, for which the given visitor object will be called with the</span>
<span class="sd">    appropriate method.</span>

<span class="sd">    ::</span>

<span class="sd">        DFS(G)</span>
<span class="sd">          for each vertex u in V</span>
<span class="sd">              color[u] := WHITE                 initialize vertex u</span>
<span class="sd">          end for</span>
<span class="sd">          time := 0</span>
<span class="sd">          call DFS-VISIT(G, source)             start vertex s</span>

<span class="sd">        DFS-VISIT(G, u)</span>
<span class="sd">          color[u] := GRAY                      discover vertex u</span>
<span class="sd">          for each v in Adj[u]                  examine edge (u,v)</span>
<span class="sd">              if (color[v] = WHITE)             (u,v) is a tree edge</span>
<span class="sd">                  all DFS-VISIT(G, v)</span>
<span class="sd">              else if (color[v] = GRAY)         (u,v) is a back edge</span>
<span class="sd">              ...</span>
<span class="sd">             else if (color[v] = BLACK)         (u,v) is a cross or forward edge</span>
<span class="sd">             ...</span>
<span class="sd">          end for</span>
<span class="sd">          color[u] := BLACK                     finish vertex u</span>

<span class="sd">    If an exception is raised inside the callback function, the graph traversal</span>
<span class="sd">    will be stopped immediately. You can exploit this to exit early by raising a</span>
<span class="sd">    :class:`~rustworkx.visit.StopSearch` exception. You can also prune part of the</span>
<span class="sd">    search tree by raising :class:`~rustworkx.visit.PruneSearch`.</span>

<span class="sd">    In the following example we keep track of the tree edges:</span>

<span class="sd">    .. jupyter-execute::</span>

<span class="sd">           import rustworkx as rx</span>
<span class="sd">           from rustworkx.visit import DFSVisitor</span>

<span class="sd">           class TreeEdgesRecorder(DFSVisitor):</span>

<span class="sd">               def __init__(self):</span>
<span class="sd">                   self.edges = []</span>

<span class="sd">               def tree_edge(self, edge):</span>
<span class="sd">                   self.edges.append(edge)</span>

<span class="sd">           graph = rx.PyGraph()</span>
<span class="sd">           graph.extend_from_edge_list([(1, 3), (0, 1), (2, 1), (0, 2)])</span>
<span class="sd">           vis = TreeEdgesRecorder()</span>
<span class="sd">           rx.dfs_search(graph, [0], vis)</span>
<span class="sd">           print(&#39;Tree edges:&#39;, vis.edges)</span>

<span class="sd">    .. note::</span>

<span class="sd">        Graph can *not* be mutated while traversing.</span>

<span class="sd">    :param PyGraph graph: The graph to be used.</span>
<span class="sd">    :param List[int] source: An optional list of node indices to use as the starting</span>
<span class="sd">        nodes for the depth-first search. If this is not specified then a source</span>
<span class="sd">        will be chosen arbitrarly and repeated until all components of the</span>
<span class="sd">        graph are searched.</span>
<span class="sd">    :param visitor: A visitor object that is invoked at the event points inside the</span>
<span class="sd">        algorithm. This should be a subclass of :class:`~rustworkx.visit.DFSVisitor`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Invalid Input Type </span><span class="si">%s</span><span class="s2"> for graph&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">graph</span><span class="p">))</span></div>


<span class="nd">@dfs_search</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">PyDiGraph</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_digraph_dfs_search</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">visitor</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">digraph_dfs_search</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">visitor</span><span class="p">)</span>


<span class="nd">@dfs_search</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">PyGraph</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_graph_dfs_search</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">visitor</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">graph_dfs_search</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">visitor</span><span class="p">)</span>


<div class="viewcode-block" id="dijkstra_search"><a class="viewcode-back" href="../apiref/rustworkx.dijkstra_search.html#rustworkx.dijkstra_search">[docs]</a><span class="nd">@functools</span><span class="o">.</span><span class="n">singledispatch</span>
<span class="k">def</span> <span class="nf">dijkstra_search</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">weight_fn</span><span class="p">,</span> <span class="n">visitor</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Dijkstra traversal of a graph.</span>

<span class="sd">    The pseudo-code for the Dijkstra algorithm is listed below, with the annotated</span>
<span class="sd">    event points, for which the given visitor object will be called with the</span>
<span class="sd">    appropriate method.</span>

<span class="sd">    ::</span>

<span class="sd">        DIJKSTRA(G, source, weight)</span>
<span class="sd">          for each vertex u in V</span>
<span class="sd">              d[u] := infinity</span>
<span class="sd">              p[u] := u</span>
<span class="sd">          end for</span>
<span class="sd">          d[source] := 0</span>
<span class="sd">          INSERT(Q, source)</span>
<span class="sd">          while (Q != )</span>
<span class="sd">              u := EXTRACT-MIN(Q)                         discover vertex u</span>
<span class="sd">              for each vertex v in Adj[u]                 examine edge (u,v)</span>
<span class="sd">                  if (weight[(u,v)] + d[u] &lt; d[v])        edge (u,v) relaxed</span>
<span class="sd">                      d[v] := weight[(u,v)] + d[u]</span>
<span class="sd">                      p[v] := u</span>
<span class="sd">                      DECREASE-KEY(Q, v)</span>
<span class="sd">                  else                                    edge (u,v) not relaxed</span>
<span class="sd">                      ...</span>
<span class="sd">                  if (d[v] was originally infinity)</span>
<span class="sd">                      INSERT(Q, v)</span>
<span class="sd">              end for                                     finish vertex u</span>
<span class="sd">          end while</span>

<span class="sd">    If an exception is raised inside the callback function, the graph traversal</span>
<span class="sd">    will be stopped immediately. You can exploit this to exit early by raising a</span>
<span class="sd">    :class:`~rustworkx.visit.StopSearch` exception, in which case the search function</span>
<span class="sd">    will return but without raising back the exception. You can also prune part of the</span>
<span class="sd">    search tree by raising :class:`~rustworkx.visit.PruneSearch`.</span>

<span class="sd">    .. note::</span>

<span class="sd">        Graph can **not** be mutated while traversing.</span>

<span class="sd">    :param graph: The graph to be used. This can be a :class:`~rustworkx.PyGraph`</span>
<span class="sd">        or a :class:`~rustworkx.PyDiGraph`.</span>
<span class="sd">    :param List[int] source: An optional list of node indices to use as the starting nodes</span>
<span class="sd">        for the dijkstra search. If this is not specified then a source</span>
<span class="sd">        will be chosen arbitrarly and repeated until all components of the</span>
<span class="sd">        graph are searched.</span>
<span class="sd">    :param weight_fn: An optional weight function for an edge. It will accept</span>
<span class="sd">        a single argument, the edge&#39;s weight object and will return a float which</span>
<span class="sd">        will be used to represent the weight/cost of the edge. If not specified,</span>
<span class="sd">        a default value of cost ``1.0`` will be used for each edge.</span>
<span class="sd">    :param visitor: A visitor object that is invoked at the event points inside the</span>
<span class="sd">        algorithm. This should be a subclass of :class:`~rustworkx.visit.DijkstraVisitor`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Invalid Input Type </span><span class="si">%s</span><span class="s2"> for graph&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">graph</span><span class="p">))</span></div>


<span class="nd">@dijkstra_search</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">PyDiGraph</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_digraph_dijkstra_search</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">weight_fn</span><span class="p">,</span> <span class="n">visitor</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">digraph_dijkstra_search</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">weight_fn</span><span class="p">,</span> <span class="n">visitor</span><span class="p">)</span>


<span class="nd">@dijkstra_search</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">PyGraph</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_graph_dijkstra_search</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">weight_fn</span><span class="p">,</span> <span class="n">visitor</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">graph_dijkstra_search</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">weight_fn</span><span class="p">,</span> <span class="n">visitor</span><span class="p">)</span>


<div class="viewcode-block" id="bellman_ford_shortest_paths"><a class="viewcode-back" href="../apiref/rustworkx.bellman_ford_shortest_paths.html#rustworkx.bellman_ford_shortest_paths">[docs]</a><span class="nd">@functools</span><span class="o">.</span><span class="n">singledispatch</span>
<span class="k">def</span> <span class="nf">bellman_ford_shortest_paths</span><span class="p">(</span>
    <span class="n">graph</span><span class="p">,</span>
    <span class="n">source</span><span class="p">,</span>
    <span class="n">target</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">weight_fn</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">default_weight</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
    <span class="n">as_undirected</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Find the shortest path from a node</span>

<span class="sd">    This function will generate the shortest path from a source node using</span>
<span class="sd">    the Bellman-Ford algorithm wit the SPFA heuristic.</span>

<span class="sd">    :param graph: The input graph to use. Can either be a</span>
<span class="sd">        :class:`~rustworkx.PyGraph` or :class:`~rustworkx.PyDiGraph`</span>
<span class="sd">    :param int source: The node index to find paths from</span>
<span class="sd">    :param int target: An optional target to find a path to</span>
<span class="sd">    :param weight_fn: An optional weight function for an edge. It will accept</span>
<span class="sd">        a single argument, the edge&#39;s weight object and will return a float</span>
<span class="sd">        which will be used to represent the weight/cost of the edge</span>
<span class="sd">    :param float default_weight: If ``weight_fn`` isn&#39;t specified this optional</span>
<span class="sd">        float value will be used for the weight/cost of each edge.</span>
<span class="sd">    :param bool as_undirected: If set to true the graph will be treated as</span>
<span class="sd">        undirected for finding the shortest path. This only works with a</span>
<span class="sd">        :class:`~rustworkx.PyDiGraph` input for ``graph``</span>

<span class="sd">    :return: A read-only dictionary of paths. The keys are destination node indices</span>
<span class="sd">        and the dict values are lists of node indices making the path.</span>
<span class="sd">    :rtype: PathMapping</span>

<span class="sd">    :raises: :class:`~rustworkx.NegativeCycle`: when there is a negative cycle and the shortest</span>
<span class="sd">        path is not defined</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Invalid Input Type </span><span class="si">%s</span><span class="s2"> for graph&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">graph</span><span class="p">))</span></div>


<span class="nd">@bellman_ford_shortest_paths</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">PyDiGraph</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_digraph_bellman_ford_shortest_path</span><span class="p">(</span>
    <span class="n">graph</span><span class="p">,</span>
    <span class="n">source</span><span class="p">,</span>
    <span class="n">target</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">weight_fn</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">default_weight</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
    <span class="n">as_undirected</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
<span class="p">):</span>
    <span class="k">return</span> <span class="n">digraph_bellman_ford_shortest_paths</span><span class="p">(</span>
        <span class="n">graph</span><span class="p">,</span>
        <span class="n">source</span><span class="p">,</span>
        <span class="n">target</span><span class="o">=</span><span class="n">target</span><span class="p">,</span>
        <span class="n">weight_fn</span><span class="o">=</span><span class="n">weight_fn</span><span class="p">,</span>
        <span class="n">default_weight</span><span class="o">=</span><span class="n">default_weight</span><span class="p">,</span>
        <span class="n">as_undirected</span><span class="o">=</span><span class="n">as_undirected</span><span class="p">,</span>
    <span class="p">)</span>


<span class="nd">@bellman_ford_shortest_paths</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">PyGraph</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_graph_bellman_ford_shortest_path</span><span class="p">(</span>
    <span class="n">graph</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">weight_fn</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">default_weight</span><span class="o">=</span><span class="mf">1.0</span>
<span class="p">):</span>
    <span class="k">return</span> <span class="n">graph_bellman_ford_shortest_paths</span><span class="p">(</span>
        <span class="n">graph</span><span class="p">,</span>
        <span class="n">source</span><span class="p">,</span>
        <span class="n">target</span><span class="o">=</span><span class="n">target</span><span class="p">,</span>
        <span class="n">weight_fn</span><span class="o">=</span><span class="n">weight_fn</span><span class="p">,</span>
        <span class="n">default_weight</span><span class="o">=</span><span class="n">default_weight</span><span class="p">,</span>
    <span class="p">)</span>


<div class="viewcode-block" id="bellman_ford_shortest_path_lengths"><a class="viewcode-back" href="../apiref/rustworkx.bellman_ford_shortest_path_lengths.html#rustworkx.bellman_ford_shortest_path_lengths">[docs]</a><span class="nd">@functools</span><span class="o">.</span><span class="n">singledispatch</span>
<span class="k">def</span> <span class="nf">bellman_ford_shortest_path_lengths</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">edge_cost_fn</span><span class="p">,</span> <span class="n">goal</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute the lengths of the shortest paths for a graph object using</span>
<span class="sd">    the Bellman-Ford algorithm with the SPFA heuristic.</span>

<span class="sd">    :param graph: The input graph to use. Can either be a</span>
<span class="sd">        :class:`~rustworkx.PyGraph` or :class:`~rustworkx.PyDiGraph`</span>
<span class="sd">    :param int node: The node index to use as the source for finding the</span>
<span class="sd">        shortest paths from</span>
<span class="sd">    :param edge_cost_fn: A python callable that will take in 1 parameter, an</span>
<span class="sd">        edge&#39;s data object and will return a float that represents the</span>
<span class="sd">        cost/weight of that edge. It can be negative.</span>
<span class="sd">    :param int goal: An optional node index to use as the end of the path.</span>
<span class="sd">        When specified the output dictionary will only have a single entry with</span>
<span class="sd">        the length of the shortest path to the goal node.</span>

<span class="sd">    :returns: A read-only dictionary of the shortest paths from the provided node</span>
<span class="sd">        where the key is the node index of the end of the path and the value is the</span>
<span class="sd">        cost/sum of the weights of path</span>
<span class="sd">    :rtype: PathLengthMapping</span>

<span class="sd">    :raises: :class:`~rustworkx.NegativeCycle`: when there is a negative cycle and the shortest</span>
<span class="sd">        path is not defined</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Invalid Input Type </span><span class="si">%s</span><span class="s2"> for graph&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">graph</span><span class="p">))</span></div>


<span class="nd">@bellman_ford_shortest_path_lengths</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">PyDiGraph</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_digraph_bellman_ford_shortest_path_lengths</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">edge_cost_fn</span><span class="p">,</span> <span class="n">goal</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">digraph_bellman_ford_shortest_path_lengths</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">edge_cost_fn</span><span class="p">,</span> <span class="n">goal</span><span class="o">=</span><span class="n">goal</span><span class="p">)</span>


<span class="nd">@bellman_ford_shortest_path_lengths</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">PyGraph</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_graph_bellman_ford_shortest_path_lengths</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">edge_cost_fn</span><span class="p">,</span> <span class="n">goal</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">graph_bellman_ford_shortest_path_lengths</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">edge_cost_fn</span><span class="p">,</span> <span class="n">goal</span><span class="o">=</span><span class="n">goal</span><span class="p">)</span>


<div class="viewcode-block" id="all_pairs_bellman_ford_path_lengths"><a class="viewcode-back" href="../apiref/rustworkx.all_pairs_bellman_ford_path_lengths.html#rustworkx.all_pairs_bellman_ford_path_lengths">[docs]</a><span class="nd">@functools</span><span class="o">.</span><span class="n">singledispatch</span>
<span class="k">def</span> <span class="nf">all_pairs_bellman_ford_path_lengths</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">edge_cost_fn</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;For each node in the graph, calculates the lengths of the shortest paths to all others.</span>

<span class="sd">    This function will generate the shortest path lengths from all nodes in the</span>
<span class="sd">    graph using the Bellman-Ford algorithm. This function is multithreaded and will</span>
<span class="sd">    launch a thread pool with threads equal to the number of CPUs by</span>
<span class="sd">    default. You can tune the number of threads with the ``RAYON_NUM_THREADS``</span>
<span class="sd">    environment variable. For example, setting ``RAYON_NUM_THREADS=4`` would</span>
<span class="sd">    limit the thread pool to 4 threads.</span>

<span class="sd">    :param graph: The input graph to use. Can either be a</span>
<span class="sd">        :class:`~rustworkx.PyGraph` or :class:`~rustworkx.PyDiGraph`</span>
<span class="sd">    :param edge_cost_fn: A callable object that acts as a weight function for</span>
<span class="sd">        an edge. It will accept a single positional argument, the edge&#39;s weight</span>
<span class="sd">        object and will return a float which will be used to represent the</span>
<span class="sd">        weight/cost of the edge</span>

<span class="sd">    :return: A read-only dictionary of path lengths. The keys are the source</span>
<span class="sd">        node indices and the values are a dict of the target node and the</span>
<span class="sd">        length of the shortest path to that node. For example::</span>

<span class="sd">            {</span>
<span class="sd">                0: {1: 2.0, 2: 2.0},</span>
<span class="sd">                1: {2: 1.0},</span>
<span class="sd">                2: {0: 1.0},</span>
<span class="sd">            }</span>

<span class="sd">    :rtype: AllPairsPathLengthMapping</span>

<span class="sd">    :raises: :class:`~rustworkx.NegativeCycle`: when there is a negative cycle and the shortest</span>
<span class="sd">        path is not defined</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Invalid Input Type </span><span class="si">%s</span><span class="s2"> for graph&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">graph</span><span class="p">))</span></div>


<span class="nd">@all_pairs_bellman_ford_path_lengths</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">PyDiGraph</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_digraph_all_pairs_bellman_ford_path_lengths</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">edge_cost_fn</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">digraph_all_pairs_bellman_ford_path_lengths</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">edge_cost_fn</span><span class="p">)</span>


<span class="nd">@all_pairs_bellman_ford_path_lengths</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">PyGraph</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_graph_all_pairs_bellman_ford_path_lengths</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">edge_cost_fn</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">graph_all_pairs_bellman_ford_path_lengths</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">edge_cost_fn</span><span class="p">)</span>


<div class="viewcode-block" id="all_pairs_bellman_ford_shortest_paths"><a class="viewcode-back" href="../apiref/rustworkx.all_pairs_bellman_ford_shortest_paths.html#rustworkx.all_pairs_bellman_ford_shortest_paths">[docs]</a><span class="nd">@functools</span><span class="o">.</span><span class="n">singledispatch</span>
<span class="k">def</span> <span class="nf">all_pairs_bellman_ford_shortest_paths</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">edge_cost_fn</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;For each node in the graph, finds the shortest paths to all others.</span>

<span class="sd">    This function will generate the shortest path from all nodes in the graph</span>
<span class="sd">    using the Bellman-Ford algorithm. This function is multithreaded and will run</span>
<span class="sd">    launch a thread pool with threads equal to the number of CPUs by default.</span>
<span class="sd">    You can tune the number of threads with the ``RAYON_NUM_THREADS``</span>
<span class="sd">    environment variable. For example, setting ``RAYON_NUM_THREADS=4`` would</span>
<span class="sd">    limit the thread pool to 4 threads.</span>

<span class="sd">    :param graph: The input graph to use. Can either be a</span>
<span class="sd">        :class:`~rustworkx.PyGraph` or :class:`~rustworkx.PyDiGraph`</span>
<span class="sd">    :param edge_cost_fn: A callable object that acts as a weight function for</span>
<span class="sd">        an edge. It will accept a single positional argument, the edge&#39;s weight</span>
<span class="sd">        object and will return a float which will be used to represent the</span>
<span class="sd">        weight/cost of the edge</span>

<span class="sd">    :return: A read-only dictionary of paths. The keys are source node</span>
<span class="sd">        indices and the values are a dict of target node indices and a list</span>
<span class="sd">        of node indices making the path. For example::</span>

<span class="sd">            {</span>
<span class="sd">                0: {1: [0, 1],  2: [0, 1, 2]},</span>
<span class="sd">                1: {2: [1, 2]},</span>
<span class="sd">                2: {0: [2, 0]},</span>
<span class="sd">            }</span>

<span class="sd">    :rtype: AllPairsPathMapping</span>

<span class="sd">    :raises: :class:`~rustworkx.NegativeCycle`: when there is a negative cycle and the shortest</span>
<span class="sd">        path is not defined</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Invalid Input Type </span><span class="si">%s</span><span class="s2"> for graph&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">graph</span><span class="p">))</span></div>


<span class="nd">@all_pairs_bellman_ford_shortest_paths</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">PyDiGraph</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_digraph_all_pairs_bellman_ford_shortest_path</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">edge_cost_fn</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">digraph_all_pairs_bellman_ford_shortest_paths</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">edge_cost_fn</span><span class="p">)</span>


<span class="nd">@all_pairs_bellman_ford_shortest_paths</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">PyGraph</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_graph_all_pairs_bellman_ford_shortest_path</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">edge_cost_fn</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">graph_all_pairs_bellman_ford_shortest_paths</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">edge_cost_fn</span><span class="p">)</span>


<div class="viewcode-block" id="node_link_json"><a class="viewcode-back" href="../apiref/rustworkx.node_link_json.html#rustworkx.node_link_json">[docs]</a><span class="nd">@functools</span><span class="o">.</span><span class="n">singledispatch</span>
<span class="k">def</span> <span class="nf">node_link_json</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">graph_attrs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">node_attrs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">edge_attrs</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Generate a JSON object representing a graph in a node-link format</span>

<span class="sd">    :param graph: The graph to generate the JSON for. Can either be a</span>
<span class="sd">        :class:`~retworkx.PyGraph` or :class:`~retworkx.PyDiGraph`.</span>
<span class="sd">    :param str path: An optional path to write the JSON output to. If specified</span>
<span class="sd">        the function will not return anything and instead will write the JSON</span>
<span class="sd">        to the file specified.</span>
<span class="sd">    :param graph_attrs: An optional callable that will be passed the</span>
<span class="sd">        :attr:`~.PyGraph.attrs` attribute of the graph and is expected to</span>
<span class="sd">        return a dictionary of string keys to string values representing the</span>
<span class="sd">        graph attributes. This dictionary will be included as attributes in</span>
<span class="sd">        the output JSON. If anything other than a dictionary with string keys</span>
<span class="sd">        and string values is returned an exception will be raised.</span>
<span class="sd">    :param node_attrs: An optional callable that will be passed the node data</span>
<span class="sd">        payload for each node in the graph and is expected to return a</span>
<span class="sd">        dictionary of string keys to string values representing the data payload.</span>
<span class="sd">        This dictionary will be used as the ``data`` field for each node.</span>
<span class="sd">    :param edge_attrs:  An optional callable that will be passed the edge data</span>
<span class="sd">        payload for each node in the graph and is expected to return a</span>
<span class="sd">        dictionary of string keys to string values representing the data payload.</span>
<span class="sd">        This dictionary will be used as the ``data`` field for each edge.</span>

<span class="sd">    :returns: Either the JSON string for the payload or ``None`` if ``path`` is specified</span>
<span class="sd">    :rtype: str</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Invalid Input Type </span><span class="si">%s</span><span class="s2"> for graph&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">graph</span><span class="p">))</span></div>


<span class="nd">@node_link_json</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">PyDiGraph</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_digraph_node_link_json</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">graph_attrs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">node_attrs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">edge_attrs</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">digraph_node_link_json</span><span class="p">(</span>
        <span class="n">graph</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="n">path</span><span class="p">,</span> <span class="n">graph_attrs</span><span class="o">=</span><span class="n">graph_attrs</span><span class="p">,</span> <span class="n">node_attrs</span><span class="o">=</span><span class="n">node_attrs</span><span class="p">,</span> <span class="n">edge_attrs</span><span class="o">=</span><span class="n">edge_attrs</span>
    <span class="p">)</span>


<span class="nd">@node_link_json</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">PyGraph</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_graph_node_link_json</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">graph_attrs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">node_attrs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">edge_attrs</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">graph_node_link_json</span><span class="p">(</span>
        <span class="n">graph</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="n">path</span><span class="p">,</span> <span class="n">graph_attrs</span><span class="o">=</span><span class="n">graph_attrs</span><span class="p">,</span> <span class="n">node_attrs</span><span class="o">=</span><span class="n">node_attrs</span><span class="p">,</span> <span class="n">edge_attrs</span><span class="o">=</span><span class="n">edge_attrs</span>
    <span class="p">)</span>
</pre></div>

             </article>
             
            </div>
            <footer>
  

  

    <hr>

  

  <div role="contentinfo">
    <p>
        &copy; Copyright 2021, rustworkx Contributors.

    </p>
  </div>
    
      <div>
        Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
      </div>
     

</footer>

          </div>
        </div>

        <div class="pytorch-content-right" id="pytorch-content-right">
          <div class="pytorch-right-menu" id="pytorch-right-menu">
            <div class="pytorch-side-scroll" id="pytorch-side-scroll-right">
              
            </div>
          </div>
        </div>
      </section>
    </div>

  

     
       <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
         <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
         <script src="../_static/jquery.js"></script>
         <script src="../_static/underscore.js"></script>
         <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
         <script src="../_static/doctools.js"></script>
         <script src="../_static/sphinx_highlight.js"></script>
         <script src="../_static/thebelab-helper.js"></script>
         <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
         <script src="https://cdn.jsdelivr.net/npm/@jupyter-widgets/html-manager@^1.0.1/dist/embed-amd.js"></script>
     

  

  <script type="text/javascript" src="../_static/js/vendor/popper.min.js"></script>
  <script type="text/javascript" src="../_static/js/vendor/bootstrap.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/list.js/1.5.0/list.min.js"></script>
  <script type="text/javascript" src="../_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>
 <script type="text/javascript">
    $(document).ready(function() {
        $(".toggle > *").hide();
        $(".toggle .header").show();
        $(".toggle .header").click(function() {
            $(this).parent().children().not(".header").toggle(400);
            $(this).parent().children(".header").toggleClass("open");
        })
    });
</script>


  <div>
    <br>
  </div>

  <!-- Begin Mobile Menu -->

  <div class="mobile-main-menu">
    <div class="container-fluid">
      <div class="container">
        <div class="mobile-main-menu-header-container">
          <a class="header-logo" href="https://qiskit.org/" aria-label="PyTorch"></a>
          <a class="main-menu-close-button" href="#" data-behavior="close-mobile-menu"></a>
        </div>
      </div>
    </div>

    <div class="mobile-main-menu-links-container">
      <div class="main-menu">
        <ul>
          <li>
            <a href="https://retworkx.readthedocs.io/en/stable/">Qiskit Documentation</a>
          </li>

          <li>
            <a href="https://qiskit.org/learn" target="_blank">Learning Resources</a>
          </li>

          <li>
            <a href="https://qiskit.slack.com" target="_blank">Slack Support</a>
          </li>

          <li>
            <a href="https://github.com/Qiskit/retworkx" target="_blank">Github</a>
          </li>
        </ul>
      </div>
    </div>
  </div>

  <!-- End Mobile Menu -->

  <script type="text/javascript" src="../_static/js/vendor/anchor.min.js"></script>

  <script type="text/javascript">
    $(document).ready(function() {
      mobileMenu.bind();
      mobileTOC.bind();
      pytorchAnchors.bind();
      sideMenus.bind();
      scrollToAnchor.bind();
      highlightNavigation.bind();
      mainMenuDropdown.bind();
      filterTags.bind();

      // Add class to links that have code blocks, since we cannot create links in code blocks
      $("article.pytorch-article a span.pre").each(function(e) {
        $(this).closest("a").addClass("has-code");
      });
    })
  </script>
</body>
</html>