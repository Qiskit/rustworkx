@InProceedings{SciPyProceedings_11,
  author =       {Aric A. Hagberg and Daniel A. Schult and Pieter J. Swart},
  title =        {Exploring Network Structure, Dynamics, and Function using NetworkX},
  booktitle =   {Proceedings of the 7th Python in Science Conference},
  pages =     {11 - 15},
  address = {Pasadena, CA USA},
  year =      {2008},
  editor =    {Ga\"el Varoquaux and Travis Vaught and Jarrod Millman},
  url = {http://conference.scipy.org/proceedings/SciPy2008/paper_2/}
}

@software{Qiskit2021,
  author       = {Matthew Treinish and
                  Jay Gambetta and
                  Diego M. Rodríguez and
                  Manoel Marques and
                  Luciano Bello and
                  Christopher J. Wood and
                  Juan Gomez and
                  Paul Nation and
                  Richard Chen and
                  Erick Winston and
                  Julien Gacon and
                  Andrew Cross and
                  Kevin Krsulich and
                  Ismael Faro Sertage and
                  Steve Wood and
                  Thomas Alexander and
                  Lauren Capelluto and
                  Salvador de la Puente González and
                  Jesús Rubio and
                  Naoki Kanazawa and
                  Edwin Navarro and
                  Maddy Tod and
                  Ikko Hamamura and
                  Antonio Mezzacapo and
                  Lev Bishop and
                  Shaohan Hu and
                  Abby Cross and
                  Christa Zoufal and
                  Donny Greenberg and
                  Stefan Woerner},
  title        = {Qiskit/qiskit-terra: Qiskit Terra  0.19.1},
  month        = sep,
  year         = 2021,
  publisher    = {Zenodo},
  version      = {0.19.1},
  doi          = {10.5281/zenodo.2583252},
  url          = {https://doi.org/10.5281/zenodo.2583252}
}

@InProceedings{Childs2019,
  author =	{Andrew M. Childs and Eddie Schoute and Cem M. Unsal},
  title =	{{Circuit Transformations for Quantum Architectures}},
  booktitle =	{14th Conference on the Theory of Quantum Computation, Communication and Cryptography (TQC 2019)},
  pages =	{3:1--3:24},
  series =	{Leibniz International Proceedings in Informatics (LIPIcs)},
  ISBN =	{978-3-95977-112-2},
  ISSN =	{1868-8969},
  year =	{2019},
  volume =	{135},
  editor =	{Wim van Dam and Laura Mancinska},
  publisher =	{Schloss Dagstuhl--Leibniz-Zentrum fuer Informatik},
  address =	{Dagstuhl, Germany},
  URL =		{http://drops.dagstuhl.de/opus/volltexte/2019/10395},
  URN =		{urn:nbn:de:0030-drops-103958},
  doi =		{10.4230/LIPIcs.TQC.2019.3},
  annote =	{Keywords: quantum circuit, quantum architectures, circuit mapping}
}

@inproceedings{Matsakis2014,
  author = {Matsakis, Nicholas D. and Klock, Felix S.},
  title = {The Rust Language},
  year = {2014},
  isbn = {9781450332170},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  url = {https://doi.org/10.1145/2663171.2663188},
  doi = {10.1145/2663171.2663188},
  abstract = {Rust is a new programming language for developing reliable and efficient systems.
  It is designed to support concurrency and parallelism in building applications and
  libraries that take full advantage of modern hardware. Rust's static type system is
  safe1 and expressive and provides strong guarantees about isolation, concurrency,
  and memory safety.Rust also offers a clear performance model, making it easier to
  predict and reason about program efficiency. One important way it accomplishes this
  is by allowing fine-grained control over memory representations, with direct support
  for stack allocation and contiguous record storage. The language balances such controls
  with the absolute requirement for safety: Rust's type system and runtime guarantee
  the absence of data races, buffer overflows, stack overflows, and accesses to uninitialized
  or deallocated memory.},
  booktitle = {Proceedings of the 2014 ACM SIGAda Annual Conference on High Integrity Language Technology},
  pages = {103–104},
  numpages = {2},
  keywords = {affine type systems, rust, memory management, systems programming},
  location = {Portland, Oregon, USA},
  series = {HILT '14}
}

@article{Leskovec2016,
  author = {Leskovec, Jure and Sosi\v{c}, Rok},
  title = {SNAP: A General-Purpose Network Analysis and Graph-Mining Library},
  year = {2016},
  issue_date = {October 2016},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  volume = {8},
  number = {1},
  issn = {2157-6904},
  url = {https://doi.org/10.1145/2898361},
  doi = {10.1145/2898361},
  abstract = {Large networks are becoming a widely used abstraction for studying complex systems
  in a broad set of disciplines, ranging from social-network analysis to molecular biology
  and neuroscience. Despite an increasing need to analyze and manipulate large networks,
  only a limited number of tools are available for this task.Here, we describe the Stanford
  Network Analysis Platform (SNAP), a general-purpose, high-performance system that
  provides easy-to-use, high-level operations for analysis and manipulation of large
  networks. We present SNAP functionality, describe its implementational details, and
  give performance benchmarks. SNAP has been developed for single big-memory machines,
  and it balances the trade-off between maximum performance, compact in-memory graph
  representation, and the ability to handle dynamic graphs in which nodes and edges
  are being added or removed over time. SNAP can process massive networks with hundreds
  of millions of nodes and billions of edges. SNAP offers over 140 different graph algorithms
  that can efficiently manipulate large graphs, calculate structural properties, generate
  regular and random graphs, and handle attributes and metadata on nodes and edges.
  Besides being able to handle large graphs, an additional strength of SNAP is that
  networks and their attributes are fully dynamic; they can be modified during the computation
  at low cost. SNAP is provided as an open-source library in C++ as well as a module
  in Python.We also describe the Stanford Large Network Dataset, a set of social and
  information real-world networks and datasets, which we make publicly available. The
  collection is a complementary resource to our SNAP software and is widely used for
  development and benchmarking of graph analytics algorithms.},
  journal = {ACM Trans. Intell. Syst. Technol.},
  month = jul,
  articleno = {1},
  numpages = {20},
  keywords = {graph analytics, data mining, open-source software, Networks, graphs}
}

@Article{Csardi2006,
  title = {The igraph software package for complex network research},
  author = {Gabor Csardi and Tamas Nepusz},
  journal = {InterJournal},
  volume = {Complex Systems},
  pages = {1695},
  year = {2006},
  url = {https://igraph.org}
}

@article{Peixoto2014,
  title = {The graph-tool python library},
  url = {http://figshare.com/articles/graph_tool/1164194},
  doi = {10.6084/m9.figshare.1164194},
  urldate = {2014-09-10},
  journal = {figshare},
  author = {Peixoto, Tiago P.},
  year = {2014},
  keywords = {all, complex networks, graph, network, other}
}

@misc{Ullberg2021,
  author = {Seaton Ullberg},
  title = {atompack: A flexible Python library for atomic structure generation},
  year = {2021},
  publisher = {GitHub},
  journal = {GitHub repository},
  url = {https://github.com/seatonullberg/atompack}
}

@misc{Jha2021,
  author = {Shantanu Jha and Jessie Chen and Aaron Householder and Allen Mi},
  title = {qtcodes},
  year = {2021},
  publisher = {GitHub},
  journal = {GitHub repository},
  url = {https://github.com/yaleqc/qtcodes}
}

@misc{bluss2021,
  author = {
    bluss 
    and Jean-Marie Comets 
    and Agustín Borgna 
    and Martin Larralde
    and Bruce Mitchener
    and Anton Kochkov
    },
  title = {petgraph},
  year = {2021},
  publisher = {GitHub},
  journal = {GitHub repository},
  url = {https://github.com/petgraph/petgraph}
}

@misc{Hewitt2021,
  author = {
    David Hewitt
    and Yuji Kanagawa
    and Nikolay Kim
    and Daniel Grunwald
    and Alexander Niederbühl
    and messense
    and Bruno Kolenbrander
    and Georg Brandl
    and Paul Ganssle
    },
  title = {PyO3},
  year = {2021},
  publisher = {GitHub},
  journal = {GitHub repository},
  url = {https://github.com/PyO3/pyo3}
}

@Article{Dijkstra1959ANO,
  title={A note on two problems in connexion with graphs},
  author={Edsger W. Dijkstra},
  journal={Numerische Mathematik},
  year={1959},
  volume={1},
  doi={10.1007/BF01386390},
  pages={269-271}
}

@ARTICLE{Cordella2004,
  author={Cordella, L.P. and Foggia, P. and Sansone, C. and Vento, M.},
  journal={IEEE Transactions on Pattern Analysis and Machine Intelligence}, 
  title={A (sub)graph isomorphism algorithm for matching large graphs}, 
  year={2004},
  volume={26},
  number={10},
  pages={1367-1372},
  doi={10.1109/TPAMI.2004.75}}

@article{Juttner2018,
title = {VF2++—An improved subgraph isomorphism algorithm},
journal = {Discrete Applied Mathematics},
volume = {242},
pages = {69-81},
year = {2018},
note = {Computational Advances in Combinatorial Optimization},
issn = {0166-218X},
doi = {10.1016/j.dam.2018.02.018},
url = {https://www.sciencedirect.com/science/article/pii/S0166218X18300829},
author = {Alpár Jüttner and Péter Madarasi},
keywords = {Computational biology, Subgraph isomorphism problem},
abstract = {This paper presents a largely improved version of the VF2 algorithm for the Subgraph Isomorphism Problem. The improvements are twofold. Firstly, it is based on a new approach for determining the matching order of the nodes, and secondly, more efficient — nevertheless easier to compute — cutting rules are proposed. They together reduce the search space significantly. In addition to the usual Subgraph Isomorphism Problem, the paper also presents specialized algorithms for the Induced Subgraph Isomorphism and for the Graph Isomorphism Problems. Finally, an extensive experimental evaluation is provided using a wide range of inputs, including both real-life biological and chemical datasets and standard randomly generated graph series. The results show major and consistent running time improvements over the other known methods. The C++ implementations of the algorithms are available open-source as part of the LEMON graph and network optimization library.}
}

@article{Johnson1977,
author = {Johnson, Donald B.},
title = {Efficient Algorithms for Shortest Paths in Sparse Networks},
year = {1977},
issue_date = {Jan. 1977},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {24},
number = {1},
issn = {0004-5411},
url = {https://doi.org/10.1145/321992.321993},
doi = {10.1145/321992.321993},
abstract = {Algorithms for finding shortest paths are presented which are faster than algorithms
previously known on networks which are relatively sparse in arcs. Known results which
the results of this paper extend are surveyed briefly and analyzed. A new implementation
for priority queues is employed, and a class of “arc set partition” algorithms is
introduced. For the single source problem on networks with nonnegative arcs a running
time of O(min(n1+1/k + e, n + e) log n)) is achieved, where there are n nodes and
e arcs, and k is a fixed integer satisfying k > 0. This bound is O(e) on dense networks.
For the single source and all pairs problem on unrestricted networks the running time
is O(min(n2+1/k + ne, n2 log n + ne log n).},
journal = {J. ACM},
month = jan,
pages = {1–13},
numpages = {13}
}

@article{Staudt2016, 
  title={NetworKit: A tool suite for large-scale complex network analysis}, 
  volume={4}, 
  DOI={10.1017/nws.2016.20}, 
  number={4}, 
  journal={Network Science}, 
  publisher={Cambridge University Press}, 
  author={STAUDT, CHRISTIAN L. and SAZONOVS, ALEKSEJS and MEYERHENKE, HENNING}, 
  year={2016}, 
  pages={508–530}
}

@inbook{Ji2021,
author = {Liu, Ji and Bello, Luciano and Zhou, Huiyang},
title = {Relaxed Peephole Optimization: A Novel Compiler Optimization for Quantum Circuits},
year = {2021},
isbn = {9781728186139},
publisher = {IEEE Press},
url = {https://doi.org/10.1109/CGO51591.2021.9370310},
abstract = {As in classical computing, compilers play an important role in quantum computing. Quantum processors typically support a limited set of primitive operations or quantum gates and have certain hardware-related limitations. A quantum compiler is responsible for adapting a quantum program to these constraint environments and decomposing quantum gates into a sequence of the primitive ones. During the compilation process, it is also critical for the compiler to optimize the quantum circuits in order to reduce the noise in the computation results. Since the noise is introduced by operations and decoherence, reducing the gate count is the key for improving performance.In this paper, we propose a novel quantum compiler optimization, named relaxed peephole optimization (RPO) for quantum computers. RPO leverages the single-qubit state information that can be determined statically by the compiler. We define that a qubit is in a basis state when, at a given point in time, its state is either in the X-, Y-, or Z-basis (|+〉 / |-〉, |L〉 / |R〉 and |0〉 / |1〉). When basis qubits are used as inputs to quantum gates, there exist opportunities for strength reduction, which replaces quantum operations with equivalent but less expensive ones. Compared to the existing peephole optimization for quantum programs, the difference is that our proposed optimization does not require an identical unitary matrix, thereby named 'relaxed' peephole optimization. We also extend our approach to optimize the quantum gates when some input qubits are in known pure states. Both optimizations, namely the Quantum Basis-state Optimization (QBO) and the Quantum Pure-state Optimization (QPO), are implemented in the IBM's Qiskit transpiler. Our experimental results show that our proposed optimization pass is fast and effective. The circuits optimized with our compiler optimizations obtain up to 18.0% (11.7% on average) fewer CNOT gates and up to 8.2% (7.1% on average) lower transpilation time than that of the most aggressive optimization level in the Qiskit compiler. When running on real quantum computers, the success rates of 3-qubit quantum phase estimation algorithm improve by 2.30X due to the reduced gate counts.},
booktitle = {Proceedings of the 2021 IEEE/ACM International Symposium on Code Generation and Optimization},
pages = {301–314},
numpages = {14}
}

@manual{Sagemath2020,
  Key          = {SageMath},
  Author       = {{The Sage Developers}},
  Title        = {{S}ageMath, the {S}age {M}athematics {S}oftware {S}ystem ({V}ersion 9.1)},
  note         = {{\tt https://www.sagemath.org}},
  Year         = {2020},
  doi          = {10.5281/zenodo.4066866},
  url          = {https://doi.org/10.5281/zenodo.4066866}
}

@misc{Bergholm2020,
      title={PennyLane: Automatic differentiation of hybrid quantum-classical computations}, 
      author={Ville Bergholm and Josh Izaac and Maria Schuld and Christian Gogolin and M. Sohaib Alam and Shahnawaz Ahmed and Juan Miguel Arrazola and Carsten Blank and Alain Delgado and Soran Jahangiri and Keri McKiernan and Johannes Jakob Meyer and Zeyue Niu and Antal Száva and Nathan Killoran},
      year={2020},
      eprint={1811.04968},
      archivePrefix={arXiv},
      primaryClass={quant-ph}
}

@misc{Stone2021,
  author = {
    Josh Stone 
    and Nicholas D. Matsakis
    },
  title = {Rayon: A data parallelism library for Rust},
  year = {2021},
  publisher = {GitHub},
  journal = {GitHub repository},
  url = {https://github.com/rayon-rs/rayon}
}