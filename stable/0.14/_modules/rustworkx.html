<!doctype html>
<html class="no-js" lang="en">
  <head><meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <meta name="color-scheme" content="light dark"><link rel="index" title="Index" href="../genindex.html" /><link rel="search" title="Search" href="../search.html" />

    <!-- Generated with Sphinx 7.1.2 and Furo 2023.05.20 -->
        <title>rustworkx - rustworkx 0.14.2</title>
      <link rel="stylesheet" type="text/css" href="../_static/styles/furo.css?digest=e6660623a769aa55fea372102b9bf3151b292993" />
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=82a976d7" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/qiskit-sphinx-theme.css?v=4f054d5c" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/qiskit-ecosystem.css?v=745c5aa7" />
    <link rel="stylesheet" type="text/css" href="../_static/jupyter-sphinx.css" />
    <link rel="stylesheet" type="text/css" href="../_static/thebelab.css" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/furo-extensions.css?digest=30d1aed668e5c3a91c3e3bf6a60b675221979f0e" />
    
    


<style>
  body {
    --color-code-background: #ffffff;
  --color-code-foreground: black;
  
  }
  @media not print {
    body[data-theme="dark"] {
      --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
    }
    @media (prefers-color-scheme: dark) {
      body:not([data-theme="light"]) {
        --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
      }
    }
  }
</style><link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@400;600&family=IBM+Plex+Sans:ital,wght@0,400;0,600;1,400;1,600&display=swap" rel="stylesheet">
<script src="../_static/js/web-components/top-nav-bar.js"></script></head>
  <body>
    
    <script>document.body.dataset.theme = "light";</script>
    
<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg id="icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32">
      <defs><style>.cls-1{fill:none;}</style></defs>
      <path d="M28,4H4A2,2,0,0,0,2,6V26a2,2,0,0,0,2,2H28a2,2,0,0,0,2-2V6A2,2,0,0,0,28,4ZM4,6H20V26H4ZM28,26H22V6h6Z"/>
      <rect id="_Transparent_Rectangle_" data-name="&lt;Transparent Rectangle&gt;" class="cls-1" width="32" height="32"/>
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg id="icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32">
      <defs><style>.cls-1{fill:none;}</style></defs>
      <rect x="4" y="6" width="24" height="2"/>
      <rect x="4" y="24" width="24" height="2"/>
      <rect x="4" y="12" width="24" height="2"/>
      <rect x="4" y="18" width="24" height="2"/>
      <rect id="_Transparent_Rectangle_" data-name="&lt;Transparent Rectangle&gt;" class="cls-1" width="32" height="32"/>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg version="1.1" id="icon" xmlns="http://www.w3.org/2000/svg" x="0px" y="0px"
         viewBox="0 0 32 32" style="enable-background:new 0 0 32 32;" xml:space="preserve"><polygon points="22,16 12,26 10.6,24.6 19.2,16 10.6,7.4 12,6 " stroke="currentColor"/>
      <rect id="_x3C_Transparent_Rectangle_x3E_" fill="none" width="32" height="32"/>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24">
    <title>Light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="feather-sun">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24">
    <title>Dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-moon">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" />
    </svg>
  </symbol>
  <symbol id="svg-sun-half" viewBox="0 0 24 24">
    <title>Auto light/dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-shadow">
      <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
      <circle cx="12" cy="12" r="9" />
      <path d="M13 12h5" />
      <path d="M13 15h4" />
      <path d="M13 18h1" />
      <path d="M13 9h4" />
      <path d="M13 6h1" />
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc">
<label class="overlay sidebar-overlay" for="__navigation">
  <div class="visually-hidden">Hide navigation sidebar</div>
</label>
<label class="overlay toc-overlay" for="__toc">
  <div class="visually-hidden">Hide table of contents sidebar</div>
</label>



<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <div class="visually-hidden">Toggle site navigation sidebar</div>
        <i class="icon"><svg><use href="#svg-menu"></use></svg></i>
      </label>
    </div>
    <div class="header-center">
      <a href="../index.html"><div class="brand">rustworkx 0.14.2</div></a>
    </div>
    <div class="header-right">
      <div class="theme-toggle-container theme-toggle-header">
        <button class="theme-toggle">
          <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
          <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
          <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
          <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
        </button>
      </div>
      <label class="toc-overlay-icon toc-header-icon no-toc" for="__toc">
        <div class="visually-hidden">Toggle table of contents sidebar</div>
        <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky">
<a class="sidebar-brand" href="../index.html">
  
  
  <span class="sidebar-brand-text">rustworkx 0.14.2</span>
  
</a><form class="sidebar-search-container" method="get" action="../search.html" role="search">
  <input class="sidebar-search" placeholder="Search" name="q" aria-label="Search">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form>
<div id="searchbox"></div><div class="sidebar-scroll"><div class="sidebar-tree">
  <ul>
<li class="toctree-l1"><a class="reference internal" href="../index.html">About Rustworkx</a></li>
<li class="toctree-l1"><a class="reference internal" href="../install.html">Installation and Getting Started</a></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../tutorial/index.html">Rustworkx Tutorials and Guides</a><input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" role="switch" type="checkbox"/><label for="toctree-checkbox-1"><div class="visually-hidden">Toggle navigation of Rustworkx Tutorials and Guides</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../tutorial/introduction.html">Introduction to rustworkx</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tutorial/dags.html">Directed Acyclic Graphs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tutorial/betweenness_centrality.html">Working with Betweenness Centrality</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../api/index.html">Rustworkx API</a><input class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" role="switch" type="checkbox"/><label for="toctree-checkbox-2"><div class="visually-hidden">Toggle navigation of Rustworkx API</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2 has-children"><a class="reference internal" href="../api/graph_classes.html">Graph Classes</a><input class="toctree-checkbox" id="toctree-checkbox-3" name="toctree-checkbox-3" role="switch" type="checkbox"/><label for="toctree-checkbox-3"><div class="visually-hidden">Toggle navigation of Graph Classes</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l3 has-children"><a class="reference internal" href="../apiref/rustworkx.PyGraph.html">PyGraph</a><input class="toctree-checkbox" id="toctree-checkbox-4" name="toctree-checkbox-4" role="switch" type="checkbox"/><label for="toctree-checkbox-4"><div class="visually-hidden">Toggle navigation of PyGraph</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyGraph.add_edge.html">rustworkx.PyGraph.add_edge</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyGraph.add_edges_from.html">rustworkx.PyGraph.add_edges_from</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyGraph.add_edges_from_no_data.html">rustworkx.PyGraph.add_edges_from_no_data</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyGraph.add_node.html">rustworkx.PyGraph.add_node</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyGraph.add_nodes_from.html">rustworkx.PyGraph.add_nodes_from</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyGraph.adj.html">rustworkx.PyGraph.adj</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyGraph.clear.html">rustworkx.PyGraph.clear</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyGraph.clear_edges.html">rustworkx.PyGraph.clear_edges</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyGraph.compose.html">rustworkx.PyGraph.compose</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyGraph.contract_nodes.html">rustworkx.PyGraph.contract_nodes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyGraph.copy.html">rustworkx.PyGraph.copy</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyGraph.degree.html">rustworkx.PyGraph.degree</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyGraph.edge_index_map.html">rustworkx.PyGraph.edge_index_map</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyGraph.edge_indices.html">rustworkx.PyGraph.edge_indices</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyGraph.edge_indices_from_endpoints.html">rustworkx.PyGraph.edge_indices_from_endpoints</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyGraph.edge_list.html">rustworkx.PyGraph.edge_list</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyGraph.edge_subgraph.html">rustworkx.PyGraph.edge_subgraph</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyGraph.edges.html">rustworkx.PyGraph.edges</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyGraph.extend_from_edge_list.html">rustworkx.PyGraph.extend_from_edge_list</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyGraph.extend_from_weighted_edge_list.html">rustworkx.PyGraph.extend_from_weighted_edge_list</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyGraph.filter_edges.html">rustworkx.PyGraph.filter_edges</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyGraph.filter_nodes.html">rustworkx.PyGraph.filter_nodes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyGraph.find_node_by_weight.html">rustworkx.PyGraph.find_node_by_weight</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyGraph.from_adjacency_matrix.html">rustworkx.PyGraph.from_adjacency_matrix</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyGraph.from_complex_adjacency_matrix.html">rustworkx.PyGraph.from_complex_adjacency_matrix</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyGraph.get_all_edge_data.html">rustworkx.PyGraph.get_all_edge_data</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyGraph.get_edge_data.html">rustworkx.PyGraph.get_edge_data</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyGraph.get_edge_data_by_index.html">rustworkx.PyGraph.get_edge_data_by_index</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyGraph.get_edge_endpoints_by_index.html">rustworkx.PyGraph.get_edge_endpoints_by_index</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyGraph.get_node_data.html">rustworkx.PyGraph.get_node_data</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyGraph.has_edge.html">rustworkx.PyGraph.has_edge</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyGraph.has_parallel_edges.html">rustworkx.PyGraph.has_parallel_edges</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyGraph.in_edges.html">rustworkx.PyGraph.in_edges</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyGraph.incident_edge_index_map.html">rustworkx.PyGraph.incident_edge_index_map</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyGraph.incident_edges.html">rustworkx.PyGraph.incident_edges</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyGraph.neighbors.html">rustworkx.PyGraph.neighbors</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyGraph.node_indexes.html">rustworkx.PyGraph.node_indexes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyGraph.node_indices.html">rustworkx.PyGraph.node_indices</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyGraph.nodes.html">rustworkx.PyGraph.nodes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyGraph.num_edges.html">rustworkx.PyGraph.num_edges</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyGraph.num_nodes.html">rustworkx.PyGraph.num_nodes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyGraph.out_edges.html">rustworkx.PyGraph.out_edges</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyGraph.read_edge_list.html">rustworkx.PyGraph.read_edge_list</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyGraph.remove_edge.html">rustworkx.PyGraph.remove_edge</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyGraph.remove_edge_from_index.html">rustworkx.PyGraph.remove_edge_from_index</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyGraph.remove_edges_from.html">rustworkx.PyGraph.remove_edges_from</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyGraph.remove_node.html">rustworkx.PyGraph.remove_node</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyGraph.remove_nodes_from.html">rustworkx.PyGraph.remove_nodes_from</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyGraph.subgraph.html">rustworkx.PyGraph.subgraph</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyGraph.substitute_node_with_subgraph.html">rustworkx.PyGraph.substitute_node_with_subgraph</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyGraph.to_directed.html">rustworkx.PyGraph.to_directed</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyGraph.to_dot.html">rustworkx.PyGraph.to_dot</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyGraph.update_edge.html">rustworkx.PyGraph.update_edge</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyGraph.update_edge_by_index.html">rustworkx.PyGraph.update_edge_by_index</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyGraph.weighted_edge_list.html">rustworkx.PyGraph.weighted_edge_list</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyGraph.write_edge_list.html">rustworkx.PyGraph.write_edge_list</a></li>
</ul>
</li>
<li class="toctree-l3 has-children"><a class="reference internal" href="../apiref/rustworkx.PyDiGraph.html">PyDiGraph</a><input class="toctree-checkbox" id="toctree-checkbox-5" name="toctree-checkbox-5" role="switch" type="checkbox"/><label for="toctree-checkbox-5"><div class="visually-hidden">Toggle navigation of PyDiGraph</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyDiGraph.add_child.html">rustworkx.PyDiGraph.add_child</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyDiGraph.add_edge.html">rustworkx.PyDiGraph.add_edge</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyDiGraph.add_edges_from.html">rustworkx.PyDiGraph.add_edges_from</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyDiGraph.add_edges_from_no_data.html">rustworkx.PyDiGraph.add_edges_from_no_data</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyDiGraph.add_node.html">rustworkx.PyDiGraph.add_node</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyDiGraph.add_nodes_from.html">rustworkx.PyDiGraph.add_nodes_from</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyDiGraph.add_parent.html">rustworkx.PyDiGraph.add_parent</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyDiGraph.adj.html">rustworkx.PyDiGraph.adj</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyDiGraph.adj_direction.html">rustworkx.PyDiGraph.adj_direction</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyDiGraph.clear.html">rustworkx.PyDiGraph.clear</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyDiGraph.clear_edges.html">rustworkx.PyDiGraph.clear_edges</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyDiGraph.compose.html">rustworkx.PyDiGraph.compose</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyDiGraph.contract_nodes.html">rustworkx.PyDiGraph.contract_nodes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyDiGraph.copy.html">rustworkx.PyDiGraph.copy</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyDiGraph.edge_index_map.html">rustworkx.PyDiGraph.edge_index_map</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyDiGraph.edge_indices.html">rustworkx.PyDiGraph.edge_indices</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyDiGraph.edge_indices_from_endpoints.html">rustworkx.PyDiGraph.edge_indices_from_endpoints</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyDiGraph.edge_list.html">rustworkx.PyDiGraph.edge_list</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyDiGraph.edge_subgraph.html">rustworkx.PyDiGraph.edge_subgraph</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyDiGraph.edges.html">rustworkx.PyDiGraph.edges</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyDiGraph.extend_from_edge_list.html">rustworkx.PyDiGraph.extend_from_edge_list</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyDiGraph.extend_from_weighted_edge_list.html">rustworkx.PyDiGraph.extend_from_weighted_edge_list</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyDiGraph.filter_edges.html">rustworkx.PyDiGraph.filter_edges</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyDiGraph.filter_nodes.html">rustworkx.PyDiGraph.filter_nodes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyDiGraph.find_adjacent_node_by_edge.html">rustworkx.PyDiGraph.find_adjacent_node_by_edge</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyDiGraph.find_node_by_weight.html">rustworkx.PyDiGraph.find_node_by_weight</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyDiGraph.find_predecessor_node_by_edge.html">rustworkx.PyDiGraph.find_predecessor_node_by_edge</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyDiGraph.find_predecessors_by_edge.html">rustworkx.PyDiGraph.find_predecessors_by_edge</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyDiGraph.find_successors_by_edge.html">rustworkx.PyDiGraph.find_successors_by_edge</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyDiGraph.from_adjacency_matrix.html">rustworkx.PyDiGraph.from_adjacency_matrix</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyDiGraph.from_complex_adjacency_matrix.html">rustworkx.PyDiGraph.from_complex_adjacency_matrix</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyDiGraph.get_all_edge_data.html">rustworkx.PyDiGraph.get_all_edge_data</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyDiGraph.get_edge_data.html">rustworkx.PyDiGraph.get_edge_data</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyDiGraph.get_edge_data_by_index.html">rustworkx.PyDiGraph.get_edge_data_by_index</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyDiGraph.get_edge_endpoints_by_index.html">rustworkx.PyDiGraph.get_edge_endpoints_by_index</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyDiGraph.get_node_data.html">rustworkx.PyDiGraph.get_node_data</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyDiGraph.has_edge.html">rustworkx.PyDiGraph.has_edge</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyDiGraph.has_parallel_edges.html">rustworkx.PyDiGraph.has_parallel_edges</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyDiGraph.in_degree.html">rustworkx.PyDiGraph.in_degree</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyDiGraph.in_edges.html">rustworkx.PyDiGraph.in_edges</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyDiGraph.incident_edge_index_map.html">rustworkx.PyDiGraph.incident_edge_index_map</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyDiGraph.incident_edges.html">rustworkx.PyDiGraph.incident_edges</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyDiGraph.insert_node_on_in_edges.html">rustworkx.PyDiGraph.insert_node_on_in_edges</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyDiGraph.insert_node_on_in_edges_multiple.html">rustworkx.PyDiGraph.insert_node_on_in_edges_multiple</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyDiGraph.insert_node_on_out_edges.html">rustworkx.PyDiGraph.insert_node_on_out_edges</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyDiGraph.insert_node_on_out_edges_multiple.html">rustworkx.PyDiGraph.insert_node_on_out_edges_multiple</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyDiGraph.is_symmetric.html">rustworkx.PyDiGraph.is_symmetric</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyDiGraph.make_symmetric.html">rustworkx.PyDiGraph.make_symmetric</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyDiGraph.merge_nodes.html">rustworkx.PyDiGraph.merge_nodes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyDiGraph.neighbors.html">rustworkx.PyDiGraph.neighbors</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyDiGraph.node_indexes.html">rustworkx.PyDiGraph.node_indexes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyDiGraph.node_indices.html">rustworkx.PyDiGraph.node_indices</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyDiGraph.nodes.html">rustworkx.PyDiGraph.nodes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyDiGraph.num_edges.html">rustworkx.PyDiGraph.num_edges</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyDiGraph.num_nodes.html">rustworkx.PyDiGraph.num_nodes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyDiGraph.out_degree.html">rustworkx.PyDiGraph.out_degree</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyDiGraph.out_edges.html">rustworkx.PyDiGraph.out_edges</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyDiGraph.predecessor_indices.html">rustworkx.PyDiGraph.predecessor_indices</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyDiGraph.predecessors.html">rustworkx.PyDiGraph.predecessors</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyDiGraph.read_edge_list.html">rustworkx.PyDiGraph.read_edge_list</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyDiGraph.remove_edge.html">rustworkx.PyDiGraph.remove_edge</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyDiGraph.remove_edge_from_index.html">rustworkx.PyDiGraph.remove_edge_from_index</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyDiGraph.remove_edges_from.html">rustworkx.PyDiGraph.remove_edges_from</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyDiGraph.remove_node.html">rustworkx.PyDiGraph.remove_node</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyDiGraph.remove_node_retain_edges.html">rustworkx.PyDiGraph.remove_node_retain_edges</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyDiGraph.remove_nodes_from.html">rustworkx.PyDiGraph.remove_nodes_from</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyDiGraph.reverse.html">rustworkx.PyDiGraph.reverse</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyDiGraph.subgraph.html">rustworkx.PyDiGraph.subgraph</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyDiGraph.substitute_node_with_subgraph.html">rustworkx.PyDiGraph.substitute_node_with_subgraph</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyDiGraph.successor_indices.html">rustworkx.PyDiGraph.successor_indices</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyDiGraph.successors.html">rustworkx.PyDiGraph.successors</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyDiGraph.to_dot.html">rustworkx.PyDiGraph.to_dot</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyDiGraph.to_undirected.html">rustworkx.PyDiGraph.to_undirected</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyDiGraph.update_edge.html">rustworkx.PyDiGraph.update_edge</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyDiGraph.update_edge_by_index.html">rustworkx.PyDiGraph.update_edge_by_index</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyDiGraph.weighted_edge_list.html">rustworkx.PyDiGraph.weighted_edge_list</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyDiGraph.write_edge_list.html">rustworkx.PyDiGraph.write_edge_list</a></li>
</ul>
</li>
<li class="toctree-l3 has-children"><a class="reference internal" href="../apiref/rustworkx.PyDAG.html">PyDAG</a><input class="toctree-checkbox" id="toctree-checkbox-6" name="toctree-checkbox-6" role="switch" type="checkbox"/><label for="toctree-checkbox-6"><div class="visually-hidden">Toggle navigation of PyDAG</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyDAG.add_child.html">rustworkx.PyDAG.add_child</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyDAG.add_edge.html">rustworkx.PyDAG.add_edge</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyDAG.add_edges_from.html">rustworkx.PyDAG.add_edges_from</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyDAG.add_edges_from_no_data.html">rustworkx.PyDAG.add_edges_from_no_data</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyDAG.add_node.html">rustworkx.PyDAG.add_node</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyDAG.add_nodes_from.html">rustworkx.PyDAG.add_nodes_from</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyDAG.add_parent.html">rustworkx.PyDAG.add_parent</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyDAG.adj.html">rustworkx.PyDAG.adj</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyDAG.adj_direction.html">rustworkx.PyDAG.adj_direction</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyDAG.clear.html">rustworkx.PyDAG.clear</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyDAG.clear_edges.html">rustworkx.PyDAG.clear_edges</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyDAG.compose.html">rustworkx.PyDAG.compose</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyDAG.contract_nodes.html">rustworkx.PyDAG.contract_nodes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyDAG.copy.html">rustworkx.PyDAG.copy</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyDAG.edge_index_map.html">rustworkx.PyDAG.edge_index_map</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyDAG.edge_indices.html">rustworkx.PyDAG.edge_indices</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyDAG.edge_indices_from_endpoints.html">rustworkx.PyDAG.edge_indices_from_endpoints</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyDAG.edge_list.html">rustworkx.PyDAG.edge_list</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyDAG.edge_subgraph.html">rustworkx.PyDAG.edge_subgraph</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyDAG.edges.html">rustworkx.PyDAG.edges</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyDAG.extend_from_edge_list.html">rustworkx.PyDAG.extend_from_edge_list</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyDAG.extend_from_weighted_edge_list.html">rustworkx.PyDAG.extend_from_weighted_edge_list</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyDAG.filter_edges.html">rustworkx.PyDAG.filter_edges</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyDAG.filter_nodes.html">rustworkx.PyDAG.filter_nodes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyDAG.find_adjacent_node_by_edge.html">rustworkx.PyDAG.find_adjacent_node_by_edge</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyDAG.find_node_by_weight.html">rustworkx.PyDAG.find_node_by_weight</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyDAG.find_predecessor_node_by_edge.html">rustworkx.PyDAG.find_predecessor_node_by_edge</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyDAG.find_predecessors_by_edge.html">rustworkx.PyDAG.find_predecessors_by_edge</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyDAG.find_successors_by_edge.html">rustworkx.PyDAG.find_successors_by_edge</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyDAG.from_adjacency_matrix.html">rustworkx.PyDAG.from_adjacency_matrix</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyDAG.from_complex_adjacency_matrix.html">rustworkx.PyDAG.from_complex_adjacency_matrix</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyDAG.get_all_edge_data.html">rustworkx.PyDAG.get_all_edge_data</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyDAG.get_edge_data.html">rustworkx.PyDAG.get_edge_data</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyDAG.get_edge_data_by_index.html">rustworkx.PyDAG.get_edge_data_by_index</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyDAG.get_edge_endpoints_by_index.html">rustworkx.PyDAG.get_edge_endpoints_by_index</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyDAG.get_node_data.html">rustworkx.PyDAG.get_node_data</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyDAG.has_edge.html">rustworkx.PyDAG.has_edge</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyDAG.has_parallel_edges.html">rustworkx.PyDAG.has_parallel_edges</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyDAG.in_degree.html">rustworkx.PyDAG.in_degree</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyDAG.in_edges.html">rustworkx.PyDAG.in_edges</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyDAG.incident_edge_index_map.html">rustworkx.PyDAG.incident_edge_index_map</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyDAG.incident_edges.html">rustworkx.PyDAG.incident_edges</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyDAG.insert_node_on_in_edges.html">rustworkx.PyDAG.insert_node_on_in_edges</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyDAG.insert_node_on_in_edges_multiple.html">rustworkx.PyDAG.insert_node_on_in_edges_multiple</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyDAG.insert_node_on_out_edges.html">rustworkx.PyDAG.insert_node_on_out_edges</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyDAG.insert_node_on_out_edges_multiple.html">rustworkx.PyDAG.insert_node_on_out_edges_multiple</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyDAG.is_symmetric.html">rustworkx.PyDAG.is_symmetric</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyDAG.make_symmetric.html">rustworkx.PyDAG.make_symmetric</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyDAG.merge_nodes.html">rustworkx.PyDAG.merge_nodes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyDAG.neighbors.html">rustworkx.PyDAG.neighbors</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyDAG.node_indexes.html">rustworkx.PyDAG.node_indexes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyDAG.node_indices.html">rustworkx.PyDAG.node_indices</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyDAG.nodes.html">rustworkx.PyDAG.nodes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyDAG.num_edges.html">rustworkx.PyDAG.num_edges</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyDAG.num_nodes.html">rustworkx.PyDAG.num_nodes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyDAG.out_degree.html">rustworkx.PyDAG.out_degree</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyDAG.out_edges.html">rustworkx.PyDAG.out_edges</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyDAG.predecessor_indices.html">rustworkx.PyDAG.predecessor_indices</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyDAG.predecessors.html">rustworkx.PyDAG.predecessors</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyDAG.read_edge_list.html">rustworkx.PyDAG.read_edge_list</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyDAG.remove_edge.html">rustworkx.PyDAG.remove_edge</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyDAG.remove_edge_from_index.html">rustworkx.PyDAG.remove_edge_from_index</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyDAG.remove_edges_from.html">rustworkx.PyDAG.remove_edges_from</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyDAG.remove_node.html">rustworkx.PyDAG.remove_node</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyDAG.remove_node_retain_edges.html">rustworkx.PyDAG.remove_node_retain_edges</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyDAG.remove_nodes_from.html">rustworkx.PyDAG.remove_nodes_from</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyDAG.reverse.html">rustworkx.PyDAG.reverse</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyDAG.subgraph.html">rustworkx.PyDAG.subgraph</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyDAG.substitute_node_with_subgraph.html">rustworkx.PyDAG.substitute_node_with_subgraph</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyDAG.successor_indices.html">rustworkx.PyDAG.successor_indices</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyDAG.successors.html">rustworkx.PyDAG.successors</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyDAG.to_dot.html">rustworkx.PyDAG.to_dot</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyDAG.to_undirected.html">rustworkx.PyDAG.to_undirected</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyDAG.update_edge.html">rustworkx.PyDAG.update_edge</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyDAG.update_edge_by_index.html">rustworkx.PyDAG.update_edge_by_index</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyDAG.weighted_edge_list.html">rustworkx.PyDAG.weighted_edge_list</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PyDAG.write_edge_list.html">rustworkx.PyDAG.write_edge_list</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../api/algorithm_functions/index.html">Algorithm Functions</a><input class="toctree-checkbox" id="toctree-checkbox-7" name="toctree-checkbox-7" role="switch" type="checkbox"/><label for="toctree-checkbox-7"><div class="visually-hidden">Toggle navigation of Algorithm Functions</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l3 has-children"><a class="reference internal" href="../api/algorithm_functions/centrality.html">Centrality</a><input class="toctree-checkbox" id="toctree-checkbox-8" name="toctree-checkbox-8" role="switch" type="checkbox"/><label for="toctree-checkbox-8"><div class="visually-hidden">Toggle navigation of Centrality</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.betweenness_centrality.html">rustworkx.betweenness_centrality</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.edge_betweenness_centrality.html">rustworkx.edge_betweenness_centrality</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.eigenvector_centrality.html">rustworkx.eigenvector_centrality</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.katz_centrality.html">rustworkx.katz_centrality</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.closeness_centrality.html">rustworkx.closeness_centrality</a></li>
</ul>
</li>
<li class="toctree-l3 has-children"><a class="reference internal" href="../api/algorithm_functions/coloring.html">Coloring</a><input class="toctree-checkbox" id="toctree-checkbox-9" name="toctree-checkbox-9" role="switch" type="checkbox"/><label for="toctree-checkbox-9"><div class="visually-hidden">Toggle navigation of Coloring</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.graph_greedy_color.html">rustworkx.graph_greedy_color</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.graph_bipartite_edge_color.html">rustworkx.graph_bipartite_edge_color</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.graph_greedy_edge_color.html">rustworkx.graph_greedy_edge_color</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.graph_misra_gries_edge_color.html">rustworkx.graph_misra_gries_edge_color</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.two_color.html">rustworkx.two_color</a></li>
</ul>
</li>
<li class="toctree-l3 has-children"><a class="reference internal" href="../api/algorithm_functions/connectivity_and_cycles.html">Connectivity and Cycles</a><input class="toctree-checkbox" id="toctree-checkbox-10" name="toctree-checkbox-10" role="switch" type="checkbox"/><label for="toctree-checkbox-10"><div class="visually-hidden">Toggle navigation of Connectivity and Cycles</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.number_connected_components.html">rustworkx.number_connected_components</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.connected_components.html">rustworkx.connected_components</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.node_connected_component.html">rustworkx.node_connected_component</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.is_connected.html">rustworkx.is_connected</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.strongly_connected_components.html">rustworkx.strongly_connected_components</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.number_weakly_connected_components.html">rustworkx.number_weakly_connected_components</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.weakly_connected_components.html">rustworkx.weakly_connected_components</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.is_weakly_connected.html">rustworkx.is_weakly_connected</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.cycle_basis.html">rustworkx.cycle_basis</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.simple_cycles.html">rustworkx.simple_cycles</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.digraph_find_cycle.html">rustworkx.digraph_find_cycle</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.articulation_points.html">rustworkx.articulation_points</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.bridges.html">rustworkx.bridges</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.biconnected_components.html">rustworkx.biconnected_components</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.chain_decomposition.html">rustworkx.chain_decomposition</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.all_simple_paths.html">rustworkx.all_simple_paths</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.all_pairs_all_simple_paths.html">rustworkx.all_pairs_all_simple_paths</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.stoer_wagner_min_cut.html">rustworkx.stoer_wagner_min_cut</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.longest_simple_path.html">rustworkx.longest_simple_path</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.is_bipartite.html">rustworkx.is_bipartite</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.isolates.html">rustworkx.isolates</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.has_path.html">rustworkx.has_path</a></li>
</ul>
</li>
<li class="toctree-l3 has-children"><a class="reference internal" href="../api/algorithm_functions/dag_algorithms.html">DAG Algorithms</a><input class="toctree-checkbox" id="toctree-checkbox-11" name="toctree-checkbox-11" role="switch" type="checkbox"/><label for="toctree-checkbox-11"><div class="visually-hidden">Toggle navigation of DAG Algorithms</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.dag_longest_path.html">rustworkx.dag_longest_path</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.dag_longest_path_length.html">rustworkx.dag_longest_path_length</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.dag_weighted_longest_path.html">rustworkx.dag_weighted_longest_path</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.dag_weighted_longest_path_length.html">rustworkx.dag_weighted_longest_path_length</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.is_directed_acyclic_graph.html">rustworkx.is_directed_acyclic_graph</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.layers.html">rustworkx.layers</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.transitive_reduction.html">rustworkx.transitive_reduction</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.topological_generations.html">rustworkx.topological_generations</a></li>
</ul>
</li>
<li class="toctree-l3 has-children"><a class="reference internal" href="../api/algorithm_functions/graph_operations.html">Graph Operations</a><input class="toctree-checkbox" id="toctree-checkbox-12" name="toctree-checkbox-12" role="switch" type="checkbox"/><label for="toctree-checkbox-12"><div class="visually-hidden">Toggle navigation of Graph Operations</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.complement.html">rustworkx.complement</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.union.html">rustworkx.union</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.cartesian_product.html">rustworkx.cartesian_product</a></li>
</ul>
</li>
<li class="toctree-l3 has-children"><a class="reference internal" href="../api/algorithm_functions/isomorphism.html">Isomorphism</a><input class="toctree-checkbox" id="toctree-checkbox-13" name="toctree-checkbox-13" role="switch" type="checkbox"/><label for="toctree-checkbox-13"><div class="visually-hidden">Toggle navigation of Isomorphism</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.is_isomorphic.html">rustworkx.is_isomorphic</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.is_subgraph_isomorphic.html">rustworkx.is_subgraph_isomorphic</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.is_isomorphic_node_match.html">rustworkx.is_isomorphic_node_match</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.vf2_mapping.html">rustworkx.vf2_mapping</a></li>
</ul>
</li>
<li class="toctree-l3 has-children"><a class="reference internal" href="../api/algorithm_functions/link_analysis.html">Link Analysis</a><input class="toctree-checkbox" id="toctree-checkbox-14" name="toctree-checkbox-14" role="switch" type="checkbox"/><label for="toctree-checkbox-14"><div class="visually-hidden">Toggle navigation of Link Analysis</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.pagerank.html">rustworkx.pagerank</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.hits.html">rustworkx.hits</a></li>
</ul>
</li>
<li class="toctree-l3 has-children"><a class="reference internal" href="../api/algorithm_functions/matching.html">Matching</a><input class="toctree-checkbox" id="toctree-checkbox-15" name="toctree-checkbox-15" role="switch" type="checkbox"/><label for="toctree-checkbox-15"><div class="visually-hidden">Toggle navigation of Matching</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.max_weight_matching.html">rustworkx.max_weight_matching</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.is_matching.html">rustworkx.is_matching</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.is_maximal_matching.html">rustworkx.is_maximal_matching</a></li>
</ul>
</li>
<li class="toctree-l3 has-children"><a class="reference internal" href="../api/algorithm_functions/other.html">Other Algorithm Functions</a><input class="toctree-checkbox" id="toctree-checkbox-16" name="toctree-checkbox-16" role="switch" type="checkbox"/><label for="toctree-checkbox-16"><div class="visually-hidden">Toggle navigation of Other Algorithm Functions</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.adjacency_matrix.html">rustworkx.adjacency_matrix</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.transitivity.html">rustworkx.transitivity</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.core_number.html">rustworkx.core_number</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.graph_line_graph.html">rustworkx.graph_line_graph</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.metric_closure.html">rustworkx.metric_closure</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.is_planar.html">rustworkx.is_planar</a></li>
</ul>
</li>
<li class="toctree-l3 has-children"><a class="reference internal" href="../api/algorithm_functions/shortest_paths.html">Shortest Paths</a><input class="toctree-checkbox" id="toctree-checkbox-17" name="toctree-checkbox-17" role="switch" type="checkbox"/><label for="toctree-checkbox-17"><div class="visually-hidden">Toggle navigation of Shortest Paths</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.dijkstra_shortest_paths.html">rustworkx.dijkstra_shortest_paths</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.dijkstra_shortest_path_lengths.html">rustworkx.dijkstra_shortest_path_lengths</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.all_pairs_dijkstra_shortest_paths.html">rustworkx.all_pairs_dijkstra_shortest_paths</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.all_pairs_dijkstra_path_lengths.html">rustworkx.all_pairs_dijkstra_path_lengths</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.bellman_ford_shortest_paths.html">rustworkx.bellman_ford_shortest_paths</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.bellman_ford_shortest_path_lengths.html">rustworkx.bellman_ford_shortest_path_lengths</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.all_pairs_bellman_ford_shortest_paths.html">rustworkx.all_pairs_bellman_ford_shortest_paths</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.all_pairs_bellman_ford_path_lengths.html">rustworkx.all_pairs_bellman_ford_path_lengths</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.negative_edge_cycle.html">rustworkx.negative_edge_cycle</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.find_negative_cycle.html">rustworkx.find_negative_cycle</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.distance_matrix.html">rustworkx.distance_matrix</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.floyd_warshall.html">rustworkx.floyd_warshall</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.floyd_warshall_numpy.html">rustworkx.floyd_warshall_numpy</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.floyd_warshall_successor_and_distance.html">rustworkx.floyd_warshall_successor_and_distance</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.astar_shortest_path.html">rustworkx.astar_shortest_path</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.k_shortest_path_lengths.html">rustworkx.k_shortest_path_lengths</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.num_shortest_paths_unweighted.html">rustworkx.num_shortest_paths_unweighted</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.unweighted_average_shortest_path_length.html">rustworkx.unweighted_average_shortest_path_length</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.all_shortest_paths.html">rustworkx.all_shortest_paths</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.digraph_all_shortest_paths.html">rustworkx.digraph_all_shortest_paths</a></li>
</ul>
</li>
<li class="toctree-l3 has-children"><a class="reference internal" href="../api/algorithm_functions/traversal.html">Traversal</a><input class="toctree-checkbox" id="toctree-checkbox-18" name="toctree-checkbox-18" role="switch" type="checkbox"/><label for="toctree-checkbox-18"><div class="visually-hidden">Toggle navigation of Traversal</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.dfs_edges.html">rustworkx.dfs_edges</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.dfs_search.html">rustworkx.dfs_search</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.bfs_successors.html">rustworkx.bfs_successors</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.bfs_predecessors.html">rustworkx.bfs_predecessors</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.bfs_search.html">rustworkx.bfs_search</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.dijkstra_search.html">rustworkx.dijkstra_search</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.topological_sort.html">rustworkx.topological_sort</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.lexicographical_topological_sort.html">rustworkx.lexicographical_topological_sort</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.descendants.html">rustworkx.descendants</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.ancestors.html">rustworkx.ancestors</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.collect_runs.html">rustworkx.collect_runs</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.collect_bicolor_runs.html">rustworkx.collect_bicolor_runs</a></li>
<li class="toctree-l4 has-children"><a class="reference internal" href="../apiref/rustworkx.visit.DFSVisitor.html">DFSVisitor</a><input class="toctree-checkbox" id="toctree-checkbox-19" name="toctree-checkbox-19" role="switch" type="checkbox"/><label for="toctree-checkbox-19"><div class="visually-hidden">Toggle navigation of DFSVisitor</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l5"><a class="reference internal" href="../apiref/rustworkx.visit.DFSVisitor.back_edge.html">rustworkx.visit.DFSVisitor.back_edge</a></li>
<li class="toctree-l5"><a class="reference internal" href="../apiref/rustworkx.visit.DFSVisitor.discover_vertex.html">rustworkx.visit.DFSVisitor.discover_vertex</a></li>
<li class="toctree-l5"><a class="reference internal" href="../apiref/rustworkx.visit.DFSVisitor.finish_vertex.html">rustworkx.visit.DFSVisitor.finish_vertex</a></li>
<li class="toctree-l5"><a class="reference internal" href="../apiref/rustworkx.visit.DFSVisitor.forward_or_cross_edge.html">rustworkx.visit.DFSVisitor.forward_or_cross_edge</a></li>
<li class="toctree-l5"><a class="reference internal" href="../apiref/rustworkx.visit.DFSVisitor.tree_edge.html">rustworkx.visit.DFSVisitor.tree_edge</a></li>
</ul>
</li>
<li class="toctree-l4 has-children"><a class="reference internal" href="../apiref/rustworkx.visit.BFSVisitor.html">BFSVisitor</a><input class="toctree-checkbox" id="toctree-checkbox-20" name="toctree-checkbox-20" role="switch" type="checkbox"/><label for="toctree-checkbox-20"><div class="visually-hidden">Toggle navigation of BFSVisitor</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l5"><a class="reference internal" href="../apiref/rustworkx.visit.BFSVisitor.black_target_edge.html">rustworkx.visit.BFSVisitor.black_target_edge</a></li>
<li class="toctree-l5"><a class="reference internal" href="../apiref/rustworkx.visit.BFSVisitor.discover_vertex.html">rustworkx.visit.BFSVisitor.discover_vertex</a></li>
<li class="toctree-l5"><a class="reference internal" href="../apiref/rustworkx.visit.BFSVisitor.finish_vertex.html">rustworkx.visit.BFSVisitor.finish_vertex</a></li>
<li class="toctree-l5"><a class="reference internal" href="../apiref/rustworkx.visit.BFSVisitor.gray_target_edge.html">rustworkx.visit.BFSVisitor.gray_target_edge</a></li>
<li class="toctree-l5"><a class="reference internal" href="../apiref/rustworkx.visit.BFSVisitor.non_tree_edge.html">rustworkx.visit.BFSVisitor.non_tree_edge</a></li>
<li class="toctree-l5"><a class="reference internal" href="../apiref/rustworkx.visit.BFSVisitor.tree_edge.html">rustworkx.visit.BFSVisitor.tree_edge</a></li>
</ul>
</li>
<li class="toctree-l4 has-children"><a class="reference internal" href="../apiref/rustworkx.visit.DijkstraVisitor.html">DijkstraVisitor</a><input class="toctree-checkbox" id="toctree-checkbox-21" name="toctree-checkbox-21" role="switch" type="checkbox"/><label for="toctree-checkbox-21"><div class="visually-hidden">Toggle navigation of DijkstraVisitor</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l5"><a class="reference internal" href="../apiref/rustworkx.visit.DijkstraVisitor.discover_vertex.html">rustworkx.visit.DijkstraVisitor.discover_vertex</a></li>
<li class="toctree-l5"><a class="reference internal" href="../apiref/rustworkx.visit.DijkstraVisitor.edge_not_relaxed.html">rustworkx.visit.DijkstraVisitor.edge_not_relaxed</a></li>
<li class="toctree-l5"><a class="reference internal" href="../apiref/rustworkx.visit.DijkstraVisitor.edge_relaxed.html">rustworkx.visit.DijkstraVisitor.edge_relaxed</a></li>
<li class="toctree-l5"><a class="reference internal" href="../apiref/rustworkx.visit.DijkstraVisitor.examine_edge.html">rustworkx.visit.DijkstraVisitor.examine_edge</a></li>
<li class="toctree-l5"><a class="reference internal" href="../apiref/rustworkx.visit.DijkstraVisitor.finish_vertex.html">rustworkx.visit.DijkstraVisitor.finish_vertex</a></li>
</ul>
</li>
<li class="toctree-l4 has-children"><a class="reference internal" href="../apiref/rustworkx.TopologicalSorter.html">TopologicalSorter</a><input class="toctree-checkbox" id="toctree-checkbox-22" name="toctree-checkbox-22" role="switch" type="checkbox"/><label for="toctree-checkbox-22"><div class="visually-hidden">Toggle navigation of TopologicalSorter</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l5"><a class="reference internal" href="../apiref/rustworkx.TopologicalSorter.done.html">rustworkx.TopologicalSorter.done</a></li>
<li class="toctree-l5"><a class="reference internal" href="../apiref/rustworkx.TopologicalSorter.get_ready.html">rustworkx.TopologicalSorter.get_ready</a></li>
<li class="toctree-l5"><a class="reference internal" href="../apiref/rustworkx.TopologicalSorter.is_active.html">rustworkx.TopologicalSorter.is_active</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l3 has-children"><a class="reference internal" href="../api/algorithm_functions/tree.html">Tree</a><input class="toctree-checkbox" id="toctree-checkbox-23" name="toctree-checkbox-23" role="switch" type="checkbox"/><label for="toctree-checkbox-23"><div class="visually-hidden">Toggle navigation of Tree</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.minimum_spanning_edges.html">rustworkx.minimum_spanning_edges</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.minimum_spanning_tree.html">rustworkx.minimum_spanning_tree</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.steiner_tree.html">rustworkx.steiner_tree</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../api/generators.html">Generators</a><input class="toctree-checkbox" id="toctree-checkbox-24" name="toctree-checkbox-24" role="switch" type="checkbox"/><label for="toctree-checkbox-24"><div class="visually-hidden">Toggle navigation of Generators</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../apiref/rustworkx.generators.cycle_graph.html">rustworkx.generators.cycle_graph</a></li>
<li class="toctree-l3"><a class="reference internal" href="../apiref/rustworkx.generators.directed_cycle_graph.html">rustworkx.generators.directed_cycle_graph</a></li>
<li class="toctree-l3"><a class="reference internal" href="../apiref/rustworkx.generators.path_graph.html">rustworkx.generators.path_graph</a></li>
<li class="toctree-l3"><a class="reference internal" href="../apiref/rustworkx.generators.directed_path_graph.html">rustworkx.generators.directed_path_graph</a></li>
<li class="toctree-l3"><a class="reference internal" href="../apiref/rustworkx.generators.star_graph.html">rustworkx.generators.star_graph</a></li>
<li class="toctree-l3"><a class="reference internal" href="../apiref/rustworkx.generators.directed_star_graph.html">rustworkx.generators.directed_star_graph</a></li>
<li class="toctree-l3"><a class="reference internal" href="../apiref/rustworkx.generators.mesh_graph.html">rustworkx.generators.mesh_graph</a></li>
<li class="toctree-l3"><a class="reference internal" href="../apiref/rustworkx.generators.directed_mesh_graph.html">rustworkx.generators.directed_mesh_graph</a></li>
<li class="toctree-l3"><a class="reference internal" href="../apiref/rustworkx.generators.grid_graph.html">rustworkx.generators.grid_graph</a></li>
<li class="toctree-l3"><a class="reference internal" href="../apiref/rustworkx.generators.directed_grid_graph.html">rustworkx.generators.directed_grid_graph</a></li>
<li class="toctree-l3"><a class="reference internal" href="../apiref/rustworkx.generators.binomial_tree_graph.html">rustworkx.generators.binomial_tree_graph</a></li>
<li class="toctree-l3"><a class="reference internal" href="../apiref/rustworkx.generators.directed_binomial_tree_graph.html">rustworkx.generators.directed_binomial_tree_graph</a></li>
<li class="toctree-l3"><a class="reference internal" href="../apiref/rustworkx.generators.hexagonal_lattice_graph.html">rustworkx.generators.hexagonal_lattice_graph</a></li>
<li class="toctree-l3"><a class="reference internal" href="../apiref/rustworkx.generators.directed_hexagonal_lattice_graph.html">rustworkx.generators.directed_hexagonal_lattice_graph</a></li>
<li class="toctree-l3"><a class="reference internal" href="../apiref/rustworkx.generators.heavy_square_graph.html">rustworkx.generators.heavy_square_graph</a></li>
<li class="toctree-l3"><a class="reference internal" href="../apiref/rustworkx.generators.directed_heavy_square_graph.html">rustworkx.generators.directed_heavy_square_graph</a></li>
<li class="toctree-l3"><a class="reference internal" href="../apiref/rustworkx.generators.heavy_hex_graph.html">rustworkx.generators.heavy_hex_graph</a></li>
<li class="toctree-l3"><a class="reference internal" href="../apiref/rustworkx.generators.directed_heavy_hex_graph.html">rustworkx.generators.directed_heavy_hex_graph</a></li>
<li class="toctree-l3"><a class="reference internal" href="../apiref/rustworkx.generators.lollipop_graph.html">rustworkx.generators.lollipop_graph</a></li>
<li class="toctree-l3"><a class="reference internal" href="../apiref/rustworkx.generators.generalized_petersen_graph.html">rustworkx.generators.generalized_petersen_graph</a></li>
<li class="toctree-l3"><a class="reference internal" href="../apiref/rustworkx.generators.barbell_graph.html">rustworkx.generators.barbell_graph</a></li>
<li class="toctree-l3"><a class="reference internal" href="../apiref/rustworkx.generators.full_rary_tree.html">rustworkx.generators.full_rary_tree</a></li>
<li class="toctree-l3"><a class="reference internal" href="../apiref/rustworkx.generators.empty_graph.html">rustworkx.generators.empty_graph</a></li>
<li class="toctree-l3"><a class="reference internal" href="../apiref/rustworkx.generators.directed_empty_graph.html">rustworkx.generators.directed_empty_graph</a></li>
<li class="toctree-l3"><a class="reference internal" href="../apiref/rustworkx.generators.complete_graph.html">rustworkx.generators.complete_graph</a></li>
<li class="toctree-l3"><a class="reference internal" href="../apiref/rustworkx.generators.directed_complete_graph.html">rustworkx.generators.directed_complete_graph</a></li>
</ul>
</li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../api/random_graph_generator_functions.html">Random Graph Generator Functions</a><input class="toctree-checkbox" id="toctree-checkbox-25" name="toctree-checkbox-25" role="switch" type="checkbox"/><label for="toctree-checkbox-25"><div class="visually-hidden">Toggle navigation of Random Graph Generator Functions</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../apiref/rustworkx.directed_gnp_random_graph.html">rustworkx.directed_gnp_random_graph</a></li>
<li class="toctree-l3"><a class="reference internal" href="../apiref/rustworkx.undirected_gnp_random_graph.html">rustworkx.undirected_gnp_random_graph</a></li>
<li class="toctree-l3"><a class="reference internal" href="../apiref/rustworkx.directed_gnm_random_graph.html">rustworkx.directed_gnm_random_graph</a></li>
<li class="toctree-l3"><a class="reference internal" href="../apiref/rustworkx.undirected_gnm_random_graph.html">rustworkx.undirected_gnm_random_graph</a></li>
<li class="toctree-l3"><a class="reference internal" href="../apiref/rustworkx.random_geometric_graph.html">rustworkx.random_geometric_graph</a></li>
<li class="toctree-l3"><a class="reference internal" href="../apiref/rustworkx.barabasi_albert_graph.html">rustworkx.barabasi_albert_graph</a></li>
<li class="toctree-l3"><a class="reference internal" href="../apiref/rustworkx.directed_barabasi_albert_graph.html">rustworkx.directed_barabasi_albert_graph</a></li>
<li class="toctree-l3"><a class="reference internal" href="../apiref/rustworkx.directed_random_bipartite_graph.html">rustworkx.directed_random_bipartite_graph</a></li>
<li class="toctree-l3"><a class="reference internal" href="../apiref/rustworkx.undirected_random_bipartite_graph.html">rustworkx.undirected_random_bipartite_graph</a></li>
</ul>
</li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../api/layout_functions.html">Layout Functions</a><input class="toctree-checkbox" id="toctree-checkbox-26" name="toctree-checkbox-26" role="switch" type="checkbox"/><label for="toctree-checkbox-26"><div class="visually-hidden">Toggle navigation of Layout Functions</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../apiref/rustworkx.random_layout.html">rustworkx.random_layout</a></li>
<li class="toctree-l3"><a class="reference internal" href="../apiref/rustworkx.spring_layout.html">rustworkx.spring_layout</a></li>
<li class="toctree-l3"><a class="reference internal" href="../apiref/rustworkx.bipartite_layout.html">rustworkx.bipartite_layout</a></li>
<li class="toctree-l3"><a class="reference internal" href="../apiref/rustworkx.circular_layout.html">rustworkx.circular_layout</a></li>
<li class="toctree-l3"><a class="reference internal" href="../apiref/rustworkx.shell_layout.html">rustworkx.shell_layout</a></li>
<li class="toctree-l3"><a class="reference internal" href="../apiref/rustworkx.spiral_layout.html">rustworkx.spiral_layout</a></li>
</ul>
</li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../api/serialization.html">Serialization</a><input class="toctree-checkbox" id="toctree-checkbox-27" name="toctree-checkbox-27" role="switch" type="checkbox"/><label for="toctree-checkbox-27"><div class="visually-hidden">Toggle navigation of Serialization</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../apiref/rustworkx.node_link_json.html">rustworkx.node_link_json</a></li>
<li class="toctree-l3"><a class="reference internal" href="../apiref/rustworkx.read_graphml.html">rustworkx.read_graphml</a></li>
</ul>
</li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../api/converters.html">Converters</a><input class="toctree-checkbox" id="toctree-checkbox-28" name="toctree-checkbox-28" role="switch" type="checkbox"/><label for="toctree-checkbox-28"><div class="visually-hidden">Toggle navigation of Converters</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../apiref/rustworkx.networkx_converter.html">rustworkx.networkx_converter</a></li>
</ul>
</li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../api/pydigraph_api_functions.html">API functions for PyDigraph</a><input class="toctree-checkbox" id="toctree-checkbox-29" name="toctree-checkbox-29" role="switch" type="checkbox"/><label for="toctree-checkbox-29"><div class="visually-hidden">Toggle navigation of API functions for PyDigraph</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../apiref/rustworkx.digraph_is_isomorphic.html">rustworkx.digraph_is_isomorphic</a></li>
<li class="toctree-l3"><a class="reference internal" href="../apiref/rustworkx.digraph_is_subgraph_isomorphic.html">rustworkx.digraph_is_subgraph_isomorphic</a></li>
<li class="toctree-l3"><a class="reference internal" href="../apiref/rustworkx.digraph_vf2_mapping.html">rustworkx.digraph_vf2_mapping</a></li>
<li class="toctree-l3"><a class="reference internal" href="../apiref/rustworkx.digraph_distance_matrix.html">rustworkx.digraph_distance_matrix</a></li>
<li class="toctree-l3"><a class="reference internal" href="../apiref/rustworkx.digraph_floyd_warshall.html">rustworkx.digraph_floyd_warshall</a></li>
<li class="toctree-l3"><a class="reference internal" href="../apiref/rustworkx.digraph_floyd_warshall_numpy.html">rustworkx.digraph_floyd_warshall_numpy</a></li>
<li class="toctree-l3"><a class="reference internal" href="../apiref/rustworkx.digraph_floyd_warshall_successor_and_distance.html">rustworkx.digraph_floyd_warshall_successor_and_distance</a></li>
<li class="toctree-l3"><a class="reference internal" href="../apiref/rustworkx.digraph_adjacency_matrix.html">rustworkx.digraph_adjacency_matrix</a></li>
<li class="toctree-l3"><a class="reference internal" href="../apiref/rustworkx.digraph_all_simple_paths.html">rustworkx.digraph_all_simple_paths</a></li>
<li class="toctree-l3"><a class="reference internal" href="../apiref/rustworkx.digraph_all_pairs_all_simple_paths.html">rustworkx.digraph_all_pairs_all_simple_paths</a></li>
<li class="toctree-l3"><a class="reference internal" href="../apiref/rustworkx.digraph_astar_shortest_path.html">rustworkx.digraph_astar_shortest_path</a></li>
<li class="toctree-l3"><a class="reference internal" href="../apiref/rustworkx.digraph_dijkstra_shortest_paths.html">rustworkx.digraph_dijkstra_shortest_paths</a></li>
<li class="toctree-l3"><a class="reference internal" href="../apiref/rustworkx.digraph_all_pairs_dijkstra_shortest_paths.html">rustworkx.digraph_all_pairs_dijkstra_shortest_paths</a></li>
<li class="toctree-l3"><a class="reference internal" href="../apiref/rustworkx.digraph_dijkstra_shortest_path_lengths.html">rustworkx.digraph_dijkstra_shortest_path_lengths</a></li>
<li class="toctree-l3"><a class="reference internal" href="../apiref/rustworkx.digraph_all_pairs_dijkstra_path_lengths.html">rustworkx.digraph_all_pairs_dijkstra_path_lengths</a></li>
<li class="toctree-l3"><a class="reference internal" href="../apiref/rustworkx.digraph_bellman_ford_shortest_path_lengths.html">rustworkx.digraph_bellman_ford_shortest_path_lengths</a></li>
<li class="toctree-l3"><a class="reference internal" href="../apiref/rustworkx.digraph_bellman_ford_shortest_path_lengths.html">rustworkx.digraph_bellman_ford_shortest_path_lengths</a></li>
<li class="toctree-l3"><a class="reference internal" href="../apiref/rustworkx.digraph_all_pairs_bellman_ford_shortest_paths.html">rustworkx.digraph_all_pairs_bellman_ford_shortest_paths</a></li>
<li class="toctree-l3"><a class="reference internal" href="../apiref/rustworkx.digraph_all_pairs_bellman_ford_path_lengths.html">rustworkx.digraph_all_pairs_bellman_ford_path_lengths</a></li>
<li class="toctree-l3"><a class="reference internal" href="../apiref/rustworkx.digraph_k_shortest_path_lengths.html">rustworkx.digraph_k_shortest_path_lengths</a></li>
<li class="toctree-l3"><a class="reference internal" href="../apiref/rustworkx.digraph_all_shortest_paths.html">rustworkx.digraph_all_shortest_paths</a></li>
<li class="toctree-l3"><a class="reference internal" href="../apiref/rustworkx.digraph_dfs_edges.html">rustworkx.digraph_dfs_edges</a></li>
<li class="toctree-l3"><a class="reference internal" href="../apiref/rustworkx.digraph_dfs_search.html">rustworkx.digraph_dfs_search</a></li>
<li class="toctree-l3"><a class="reference internal" href="../apiref/rustworkx.digraph_find_cycle.html">rustworkx.digraph_find_cycle</a></li>
<li class="toctree-l3"><a class="reference internal" href="../apiref/rustworkx.digraph_transitivity.html">rustworkx.digraph_transitivity</a></li>
<li class="toctree-l3"><a class="reference internal" href="../apiref/rustworkx.digraph_core_number.html">rustworkx.digraph_core_number</a></li>
<li class="toctree-l3"><a class="reference internal" href="../apiref/rustworkx.digraph_complement.html">rustworkx.digraph_complement</a></li>
<li class="toctree-l3"><a class="reference internal" href="../apiref/rustworkx.digraph_union.html">rustworkx.digraph_union</a></li>
<li class="toctree-l3"><a class="reference internal" href="../apiref/rustworkx.digraph_tensor_product.html">rustworkx.digraph_tensor_product</a></li>
<li class="toctree-l3"><a class="reference internal" href="../apiref/rustworkx.digraph_cartesian_product.html">rustworkx.digraph_cartesian_product</a></li>
<li class="toctree-l3"><a class="reference internal" href="../apiref/rustworkx.digraph_random_layout.html">rustworkx.digraph_random_layout</a></li>
<li class="toctree-l3"><a class="reference internal" href="../apiref/rustworkx.digraph_bipartite_layout.html">rustworkx.digraph_bipartite_layout</a></li>
<li class="toctree-l3"><a class="reference internal" href="../apiref/rustworkx.digraph_circular_layout.html">rustworkx.digraph_circular_layout</a></li>
<li class="toctree-l3"><a class="reference internal" href="../apiref/rustworkx.digraph_shell_layout.html">rustworkx.digraph_shell_layout</a></li>
<li class="toctree-l3"><a class="reference internal" href="../apiref/rustworkx.digraph_spiral_layout.html">rustworkx.digraph_spiral_layout</a></li>
<li class="toctree-l3"><a class="reference internal" href="../apiref/rustworkx.digraph_spring_layout.html">rustworkx.digraph_spring_layout</a></li>
<li class="toctree-l3"><a class="reference internal" href="../apiref/rustworkx.digraph_num_shortest_paths_unweighted.html">rustworkx.digraph_num_shortest_paths_unweighted</a></li>
<li class="toctree-l3"><a class="reference internal" href="../apiref/rustworkx.digraph_betweenness_centrality.html">rustworkx.digraph_betweenness_centrality</a></li>
<li class="toctree-l3"><a class="reference internal" href="../apiref/rustworkx.digraph_edge_betweenness_centrality.html">rustworkx.digraph_edge_betweenness_centrality</a></li>
<li class="toctree-l3"><a class="reference internal" href="../apiref/rustworkx.digraph_closeness_centrality.html">rustworkx.digraph_closeness_centrality</a></li>
<li class="toctree-l3"><a class="reference internal" href="../apiref/rustworkx.digraph_eigenvector_centrality.html">rustworkx.digraph_eigenvector_centrality</a></li>
<li class="toctree-l3"><a class="reference internal" href="../apiref/rustworkx.digraph_katz_centrality.html">rustworkx.digraph_katz_centrality</a></li>
<li class="toctree-l3"><a class="reference internal" href="../apiref/rustworkx.digraph_unweighted_average_shortest_path_length.html">rustworkx.digraph_unweighted_average_shortest_path_length</a></li>
<li class="toctree-l3"><a class="reference internal" href="../apiref/rustworkx.digraph_bfs_search.html">rustworkx.digraph_bfs_search</a></li>
<li class="toctree-l3"><a class="reference internal" href="../apiref/rustworkx.digraph_dijkstra_search.html">rustworkx.digraph_dijkstra_search</a></li>
<li class="toctree-l3"><a class="reference internal" href="../apiref/rustworkx.digraph_node_link_json.html">rustworkx.digraph_node_link_json</a></li>
<li class="toctree-l3"><a class="reference internal" href="../apiref/rustworkx.digraph_longest_simple_path.html">rustworkx.digraph_longest_simple_path</a></li>
</ul>
</li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../api/pygraph_api_functions.html">API functions for PyGraph</a><input class="toctree-checkbox" id="toctree-checkbox-30" name="toctree-checkbox-30" role="switch" type="checkbox"/><label for="toctree-checkbox-30"><div class="visually-hidden">Toggle navigation of API functions for PyGraph</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../apiref/rustworkx.graph_is_isomorphic.html">rustworkx.graph_is_isomorphic</a></li>
<li class="toctree-l3"><a class="reference internal" href="../apiref/rustworkx.graph_is_subgraph_isomorphic.html">rustworkx.graph_is_subgraph_isomorphic</a></li>
<li class="toctree-l3"><a class="reference internal" href="../apiref/rustworkx.graph_vf2_mapping.html">rustworkx.graph_vf2_mapping</a></li>
<li class="toctree-l3"><a class="reference internal" href="../apiref/rustworkx.graph_distance_matrix.html">rustworkx.graph_distance_matrix</a></li>
<li class="toctree-l3"><a class="reference internal" href="../apiref/rustworkx.graph_floyd_warshall.html">rustworkx.graph_floyd_warshall</a></li>
<li class="toctree-l3"><a class="reference internal" href="../apiref/rustworkx.graph_floyd_warshall_numpy.html">rustworkx.graph_floyd_warshall_numpy</a></li>
<li class="toctree-l3"><a class="reference internal" href="../apiref/rustworkx.graph_floyd_warshall_successor_and_distance.html">rustworkx.graph_floyd_warshall_successor_and_distance</a></li>
<li class="toctree-l3"><a class="reference internal" href="../apiref/rustworkx.graph_adjacency_matrix.html">rustworkx.graph_adjacency_matrix</a></li>
<li class="toctree-l3"><a class="reference internal" href="../apiref/rustworkx.graph_all_simple_paths.html">rustworkx.graph_all_simple_paths</a></li>
<li class="toctree-l3"><a class="reference internal" href="../apiref/rustworkx.graph_all_pairs_all_simple_paths.html">rustworkx.graph_all_pairs_all_simple_paths</a></li>
<li class="toctree-l3"><a class="reference internal" href="../apiref/rustworkx.graph_astar_shortest_path.html">rustworkx.graph_astar_shortest_path</a></li>
<li class="toctree-l3"><a class="reference internal" href="../apiref/rustworkx.graph_dijkstra_shortest_paths.html">rustworkx.graph_dijkstra_shortest_paths</a></li>
<li class="toctree-l3"><a class="reference internal" href="../apiref/rustworkx.graph_dijkstra_shortest_path_lengths.html">rustworkx.graph_dijkstra_shortest_path_lengths</a></li>
<li class="toctree-l3"><a class="reference internal" href="../apiref/rustworkx.graph_all_pairs_dijkstra_shortest_paths.html">rustworkx.graph_all_pairs_dijkstra_shortest_paths</a></li>
<li class="toctree-l3"><a class="reference internal" href="../apiref/rustworkx.graph_k_shortest_path_lengths.html">rustworkx.graph_k_shortest_path_lengths</a></li>
<li class="toctree-l3"><a class="reference internal" href="../apiref/rustworkx.graph_all_pairs_dijkstra_path_lengths.html">rustworkx.graph_all_pairs_dijkstra_path_lengths</a></li>
<li class="toctree-l3"><a class="reference internal" href="../apiref/rustworkx.graph_bellman_ford_shortest_path_lengths.html">rustworkx.graph_bellman_ford_shortest_path_lengths</a></li>
<li class="toctree-l3"><a class="reference internal" href="../apiref/rustworkx.graph_bellman_ford_shortest_path_lengths.html">rustworkx.graph_bellman_ford_shortest_path_lengths</a></li>
<li class="toctree-l3"><a class="reference internal" href="../apiref/rustworkx.graph_all_pairs_bellman_ford_shortest_paths.html">rustworkx.graph_all_pairs_bellman_ford_shortest_paths</a></li>
<li class="toctree-l3"><a class="reference internal" href="../apiref/rustworkx.graph_all_pairs_bellman_ford_path_lengths.html">rustworkx.graph_all_pairs_bellman_ford_path_lengths</a></li>
<li class="toctree-l3"><a class="reference internal" href="../apiref/rustworkx.graph_all_shortest_paths.html">rustworkx.graph_all_shortest_paths</a></li>
<li class="toctree-l3"><a class="reference internal" href="../apiref/rustworkx.graph_dfs_edges.html">rustworkx.graph_dfs_edges</a></li>
<li class="toctree-l3"><a class="reference internal" href="../apiref/rustworkx.graph_dfs_search.html">rustworkx.graph_dfs_search</a></li>
<li class="toctree-l3"><a class="reference internal" href="../apiref/rustworkx.graph_transitivity.html">rustworkx.graph_transitivity</a></li>
<li class="toctree-l3"><a class="reference internal" href="../apiref/rustworkx.graph_core_number.html">rustworkx.graph_core_number</a></li>
<li class="toctree-l3"><a class="reference internal" href="../apiref/rustworkx.graph_complement.html">rustworkx.graph_complement</a></li>
<li class="toctree-l3"><a class="reference internal" href="../apiref/rustworkx.graph_union.html">rustworkx.graph_union</a></li>
<li class="toctree-l3"><a class="reference internal" href="../apiref/rustworkx.graph_tensor_product.html">rustworkx.graph_tensor_product</a></li>
<li class="toctree-l3"><a class="reference internal" href="../apiref/rustworkx.graph_token_swapper.html">rustworkx.graph_token_swapper</a></li>
<li class="toctree-l3"><a class="reference internal" href="../apiref/rustworkx.graph_cartesian_product.html">rustworkx.graph_cartesian_product</a></li>
<li class="toctree-l3"><a class="reference internal" href="../apiref/rustworkx.graph_random_layout.html">rustworkx.graph_random_layout</a></li>
<li class="toctree-l3"><a class="reference internal" href="../apiref/rustworkx.graph_bipartite_layout.html">rustworkx.graph_bipartite_layout</a></li>
<li class="toctree-l3"><a class="reference internal" href="../apiref/rustworkx.graph_circular_layout.html">rustworkx.graph_circular_layout</a></li>
<li class="toctree-l3"><a class="reference internal" href="../apiref/rustworkx.graph_shell_layout.html">rustworkx.graph_shell_layout</a></li>
<li class="toctree-l3"><a class="reference internal" href="../apiref/rustworkx.graph_spiral_layout.html">rustworkx.graph_spiral_layout</a></li>
<li class="toctree-l3"><a class="reference internal" href="../apiref/rustworkx.graph_spring_layout.html">rustworkx.graph_spring_layout</a></li>
<li class="toctree-l3"><a class="reference internal" href="../apiref/rustworkx.graph_num_shortest_paths_unweighted.html">rustworkx.graph_num_shortest_paths_unweighted</a></li>
<li class="toctree-l3"><a class="reference internal" href="../apiref/rustworkx.graph_betweenness_centrality.html">rustworkx.graph_betweenness_centrality</a></li>
<li class="toctree-l3"><a class="reference internal" href="../apiref/rustworkx.graph_edge_betweenness_centrality.html">rustworkx.graph_edge_betweenness_centrality</a></li>
<li class="toctree-l3"><a class="reference internal" href="../apiref/rustworkx.graph_closeness_centrality.html">rustworkx.graph_closeness_centrality</a></li>
<li class="toctree-l3"><a class="reference internal" href="../apiref/rustworkx.graph_eigenvector_centrality.html">rustworkx.graph_eigenvector_centrality</a></li>
<li class="toctree-l3"><a class="reference internal" href="../apiref/rustworkx.graph_katz_centrality.html">rustworkx.graph_katz_centrality</a></li>
<li class="toctree-l3"><a class="reference internal" href="../apiref/rustworkx.graph_unweighted_average_shortest_path_length.html">rustworkx.graph_unweighted_average_shortest_path_length</a></li>
<li class="toctree-l3"><a class="reference internal" href="../apiref/rustworkx.graph_bfs_search.html">rustworkx.graph_bfs_search</a></li>
<li class="toctree-l3"><a class="reference internal" href="../apiref/rustworkx.graph_dijkstra_search.html">rustworkx.graph_dijkstra_search</a></li>
<li class="toctree-l3"><a class="reference internal" href="../apiref/rustworkx.graph_node_link_json.html">rustworkx.graph_node_link_json</a></li>
<li class="toctree-l3"><a class="reference internal" href="../apiref/rustworkx.graph_longest_simple_path.html">rustworkx.graph_longest_simple_path</a></li>
</ul>
</li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../api/exceptions.html">Exceptions</a><input class="toctree-checkbox" id="toctree-checkbox-31" name="toctree-checkbox-31" role="switch" type="checkbox"/><label for="toctree-checkbox-31"><div class="visually-hidden">Toggle navigation of Exceptions</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../apiref/rustworkx.InvalidNode.html">rustworkx.InvalidNode</a></li>
<li class="toctree-l3"><a class="reference internal" href="../apiref/rustworkx.DAGWouldCycle.html">rustworkx.DAGWouldCycle</a></li>
<li class="toctree-l3"><a class="reference internal" href="../apiref/rustworkx.NoEdgeBetweenNodes.html">rustworkx.NoEdgeBetweenNodes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../apiref/rustworkx.DAGHasCycle.html">rustworkx.DAGHasCycle</a></li>
<li class="toctree-l3"><a class="reference internal" href="../apiref/rustworkx.NegativeCycle.html">rustworkx.NegativeCycle</a></li>
<li class="toctree-l3"><a class="reference internal" href="../apiref/rustworkx.NoSuitableNeighbors.html">rustworkx.NoSuitableNeighbors</a></li>
<li class="toctree-l3"><a class="reference internal" href="../apiref/rustworkx.NoPathFound.html">rustworkx.NoPathFound</a></li>
<li class="toctree-l3"><a class="reference internal" href="../apiref/rustworkx.NullGraph.html">rustworkx.NullGraph</a></li>
<li class="toctree-l3"><a class="reference internal" href="../apiref/rustworkx.visit.StopSearch.html">rustworkx.visit.StopSearch</a></li>
<li class="toctree-l3"><a class="reference internal" href="../apiref/rustworkx.visit.PruneSearch.html">rustworkx.visit.PruneSearch</a></li>
<li class="toctree-l3"><a class="reference internal" href="../apiref/rustworkx.JSONSerializationError.html">rustworkx.JSONSerializationError</a></li>
<li class="toctree-l3"><a class="reference internal" href="../apiref/rustworkx.InvalidMapping.html">rustworkx.InvalidMapping</a></li>
<li class="toctree-l3"><a class="reference internal" href="../apiref/rustworkx.GraphNotBipartite.html">rustworkx.GraphNotBipartite</a></li>
</ul>
</li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../api/custom_return_types.html">Custom Return Types</a><input class="toctree-checkbox" id="toctree-checkbox-32" name="toctree-checkbox-32" role="switch" type="checkbox"/><label for="toctree-checkbox-32"><div class="visually-hidden">Toggle navigation of Custom Return Types</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../apiref/rustworkx.BFSSuccessors.html">BFSSuccessors</a></li>
<li class="toctree-l3"><a class="reference internal" href="../apiref/rustworkx.BFSPredecessors.html">BFSPredecessors</a></li>
<li class="toctree-l3"><a class="reference internal" href="../apiref/rustworkx.NodeIndices.html">NodeIndices</a></li>
<li class="toctree-l3"><a class="reference internal" href="../apiref/rustworkx.EdgeIndices.html">EdgeIndices</a></li>
<li class="toctree-l3"><a class="reference internal" href="../apiref/rustworkx.EdgeList.html">EdgeList</a></li>
<li class="toctree-l3"><a class="reference internal" href="../apiref/rustworkx.WeightedEdgeList.html">WeightedEdgeList</a></li>
<li class="toctree-l3 has-children"><a class="reference internal" href="../apiref/rustworkx.EdgeIndexMap.html">EdgeIndexMap</a><input class="toctree-checkbox" id="toctree-checkbox-33" name="toctree-checkbox-33" role="switch" type="checkbox"/><label for="toctree-checkbox-33"><div class="visually-hidden">Toggle navigation of EdgeIndexMap</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.EdgeIndexMap.items.html">rustworkx.EdgeIndexMap.items</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.EdgeIndexMap.keys.html">rustworkx.EdgeIndexMap.keys</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.EdgeIndexMap.values.html">rustworkx.EdgeIndexMap.values</a></li>
</ul>
</li>
<li class="toctree-l3 has-children"><a class="reference internal" href="../apiref/rustworkx.PathMapping.html">PathMapping</a><input class="toctree-checkbox" id="toctree-checkbox-34" name="toctree-checkbox-34" role="switch" type="checkbox"/><label for="toctree-checkbox-34"><div class="visually-hidden">Toggle navigation of PathMapping</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PathMapping.items.html">rustworkx.PathMapping.items</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PathMapping.keys.html">rustworkx.PathMapping.keys</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PathMapping.values.html">rustworkx.PathMapping.values</a></li>
</ul>
</li>
<li class="toctree-l3 has-children"><a class="reference internal" href="../apiref/rustworkx.PathLengthMapping.html">PathLengthMapping</a><input class="toctree-checkbox" id="toctree-checkbox-35" name="toctree-checkbox-35" role="switch" type="checkbox"/><label for="toctree-checkbox-35"><div class="visually-hidden">Toggle navigation of PathLengthMapping</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PathLengthMapping.items.html">rustworkx.PathLengthMapping.items</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PathLengthMapping.keys.html">rustworkx.PathLengthMapping.keys</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.PathLengthMapping.values.html">rustworkx.PathLengthMapping.values</a></li>
</ul>
</li>
<li class="toctree-l3 has-children"><a class="reference internal" href="../apiref/rustworkx.Pos2DMapping.html">Pos2DMapping</a><input class="toctree-checkbox" id="toctree-checkbox-36" name="toctree-checkbox-36" role="switch" type="checkbox"/><label for="toctree-checkbox-36"><div class="visually-hidden">Toggle navigation of Pos2DMapping</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.Pos2DMapping.items.html">rustworkx.Pos2DMapping.items</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.Pos2DMapping.keys.html">rustworkx.Pos2DMapping.keys</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.Pos2DMapping.values.html">rustworkx.Pos2DMapping.values</a></li>
</ul>
</li>
<li class="toctree-l3 has-children"><a class="reference internal" href="../apiref/rustworkx.AllPairsPathMapping.html">AllPairsPathMapping</a><input class="toctree-checkbox" id="toctree-checkbox-37" name="toctree-checkbox-37" role="switch" type="checkbox"/><label for="toctree-checkbox-37"><div class="visually-hidden">Toggle navigation of AllPairsPathMapping</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.AllPairsPathMapping.items.html">rustworkx.AllPairsPathMapping.items</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.AllPairsPathMapping.keys.html">rustworkx.AllPairsPathMapping.keys</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.AllPairsPathMapping.values.html">rustworkx.AllPairsPathMapping.values</a></li>
</ul>
</li>
<li class="toctree-l3 has-children"><a class="reference internal" href="../apiref/rustworkx.AllPairsPathLengthMapping.html">AllPairsPathLengthMapping</a><input class="toctree-checkbox" id="toctree-checkbox-38" name="toctree-checkbox-38" role="switch" type="checkbox"/><label for="toctree-checkbox-38"><div class="visually-hidden">Toggle navigation of AllPairsPathLengthMapping</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.AllPairsPathLengthMapping.items.html">rustworkx.AllPairsPathLengthMapping.items</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.AllPairsPathLengthMapping.keys.html">rustworkx.AllPairsPathLengthMapping.keys</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.AllPairsPathLengthMapping.values.html">rustworkx.AllPairsPathLengthMapping.values</a></li>
</ul>
</li>
<li class="toctree-l3 has-children"><a class="reference internal" href="../apiref/rustworkx.CentralityMapping.html">CentralityMapping</a><input class="toctree-checkbox" id="toctree-checkbox-39" name="toctree-checkbox-39" role="switch" type="checkbox"/><label for="toctree-checkbox-39"><div class="visually-hidden">Toggle navigation of CentralityMapping</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.CentralityMapping.items.html">rustworkx.CentralityMapping.items</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.CentralityMapping.keys.html">rustworkx.CentralityMapping.keys</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.CentralityMapping.values.html">rustworkx.CentralityMapping.values</a></li>
</ul>
</li>
<li class="toctree-l3 has-children"><a class="reference internal" href="../apiref/rustworkx.EdgeCentralityMapping.html">EdgeCentralityMapping</a><input class="toctree-checkbox" id="toctree-checkbox-40" name="toctree-checkbox-40" role="switch" type="checkbox"/><label for="toctree-checkbox-40"><div class="visually-hidden">Toggle navigation of EdgeCentralityMapping</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.EdgeCentralityMapping.items.html">rustworkx.EdgeCentralityMapping.items</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.EdgeCentralityMapping.keys.html">rustworkx.EdgeCentralityMapping.keys</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.EdgeCentralityMapping.values.html">rustworkx.EdgeCentralityMapping.values</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../apiref/rustworkx.Chains.html">Chains</a></li>
<li class="toctree-l3 has-children"><a class="reference internal" href="../apiref/rustworkx.NodeMap.html">NodeMap</a><input class="toctree-checkbox" id="toctree-checkbox-41" name="toctree-checkbox-41" role="switch" type="checkbox"/><label for="toctree-checkbox-41"><div class="visually-hidden">Toggle navigation of NodeMap</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.NodeMap.items.html">rustworkx.NodeMap.items</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.NodeMap.keys.html">rustworkx.NodeMap.keys</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.NodeMap.values.html">rustworkx.NodeMap.values</a></li>
</ul>
</li>
<li class="toctree-l3 has-children"><a class="reference internal" href="../apiref/rustworkx.ProductNodeMap.html">ProductNodeMap</a><input class="toctree-checkbox" id="toctree-checkbox-42" name="toctree-checkbox-42" role="switch" type="checkbox"/><label for="toctree-checkbox-42"><div class="visually-hidden">Toggle navigation of ProductNodeMap</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.ProductNodeMap.items.html">rustworkx.ProductNodeMap.items</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.ProductNodeMap.keys.html">rustworkx.ProductNodeMap.keys</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.ProductNodeMap.values.html">rustworkx.ProductNodeMap.values</a></li>
</ul>
</li>
<li class="toctree-l3 has-children"><a class="reference internal" href="../apiref/rustworkx.BiconnectedComponents.html">BiconnectedComponents</a><input class="toctree-checkbox" id="toctree-checkbox-43" name="toctree-checkbox-43" role="switch" type="checkbox"/><label for="toctree-checkbox-43"><div class="visually-hidden">Toggle navigation of BiconnectedComponents</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.BiconnectedComponents.items.html">rustworkx.BiconnectedComponents.items</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.BiconnectedComponents.keys.html">rustworkx.BiconnectedComponents.keys</a></li>
<li class="toctree-l4"><a class="reference internal" href="../apiref/rustworkx.BiconnectedComponents.values.html">rustworkx.BiconnectedComponents.values</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../visualization.html">Visualization</a><input class="toctree-checkbox" id="toctree-checkbox-44" name="toctree-checkbox-44" role="switch" type="checkbox"/><label for="toctree-checkbox-44"><div class="visually-hidden">Toggle navigation of Visualization</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../apiref/rustworkx.visualization.mpl_draw.html">rustworkx.visualization.mpl_draw</a></li>
<li class="toctree-l2"><a class="reference internal" href="../apiref/rustworkx.visualization.graphviz_draw.html">rustworkx.visualization.graphviz_draw</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../release_notes.html">Release Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../CONTRIBUTING.html">Contributing Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../networkx.html">rustworkx for NetworkX users</a></li>
<li class="toctree-l1"><a class="reference internal" href="../benchmarks.html">Benchmarks</a></li>
</ul>

</div><div class="qiskit-previous-releases-container">
    <input id="previous-releases-checkbox" name="previous-releases-checkbox" role="switch" type="checkbox">
    <div class="qiskit-previous-releases-header-container"><label for="previous-releases-checkbox">
            <p role="note">Previous Releases</p>
            <div class="qiskit-previous-releases-toggle-container">
                <div class="visually-hidden">Toggle navigation of Previous Releases</div>
                <i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i>
            </div>
        </label>
    </div>
    <div class="qiskit-previous-releases-list-container">
        <ul>
        
            <li><a href="//stable/0.14/index.html" rel="nofollow">0.14</a></li>
        
            <li><a href="//stable/0.13/index.html" rel="nofollow">0.13</a></li>
        
            <li><a href="//stable/0.12/index.html" rel="nofollow">0.12</a></li>
        
        </ul>
    </div>
</div>
</div>
      </div>
      
    </div>
  </aside>
  <div class="main">
    <div class="content">
      <div class="article-container">
        <a href="#" class="back-to-top muted-link">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"></path>
          </svg>
          <span>Back to top</span>
        </a>
        <div class="content-icon-container">
          <div class="theme-toggle-container theme-toggle-content">
            <button class="theme-toggle">
              <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
              <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
              <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
              <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
            </button>
          </div>
          <label class="toc-overlay-icon toc-content-icon no-toc" for="__toc">
            <div class="visually-hidden">Toggle table of contents sidebar</div>
            <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
          </label>
        </div>
        <article role="main">
          <h1>Source code for rustworkx</h1><div class="highlight"><pre>
<span></span><span class="c1"># This code is licensed under the Apache License, Version 2.0. You may</span>
<span class="c1"># obtain a copy of this license in the LICENSE.txt file in the root directory</span>
<span class="c1"># of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.</span>
<span class="c1">#</span>
<span class="c1"># Any modifications or derivative works of this code must retain this</span>
<span class="c1"># copyright notice, and modified files need to carry a notice indicating</span>
<span class="c1"># that they have been altered from the originals.</span>


<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">functools</span>

<span class="kn">from</span> <span class="nn">.rustworkx</span> <span class="kn">import</span> <span class="o">*</span>

<span class="c1"># flake8: noqa</span>
<span class="kn">import</span> <span class="nn">rustworkx.visit</span>

<span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">[</span><span class="s2">&quot;rustworkx.generators&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">generators</span>


<div class="viewcode-block" id="PyDAG"><a class="viewcode-back" href="../apiref/rustworkx.PyDAG.html#rustworkx.PyDAG">[docs]</a><span class="k">class</span> <span class="nc">PyDAG</span><span class="p">(</span><span class="n">PyDiGraph</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A class for creating direct acyclic graphs.</span>

<span class="sd">    PyDAG is just an alias of the PyDiGraph class and behaves identically to</span>
<span class="sd">    the :class:`~rustworkx.PyDiGraph` class and can be used interchangably</span>
<span class="sd">    with ``PyDiGraph``. It currently exists solely as a backwards</span>
<span class="sd">    compatibility alias for users of rustworkx from prior to the</span>
<span class="sd">    0.4.0 release when there was no PyDiGraph class.</span>

<span class="sd">    The PyDAG class is used to create a directed graph. It can be a</span>
<span class="sd">    multigraph (have multiple edges between nodes). Each node and edge</span>
<span class="sd">    (although rarely used for edges) is indexed by an integer id. These ids</span>
<span class="sd">    are stable for the lifetime of the graph object and on node or edge</span>
<span class="sd">    deletions you can have holes in the list of indices for the graph.</span>
<span class="sd">    Node indices will be reused on additions after removal. For example:</span>

<span class="sd">    .. jupyter-execute::</span>

<span class="sd">        import rustworkx as rx</span>

<span class="sd">        graph = rx.PyDAG()</span>
<span class="sd">        graph.add_nodes_from(list(range(5)))</span>
<span class="sd">        graph.add_nodes_from(list(range(2)))</span>
<span class="sd">        graph.remove_node(2)</span>
<span class="sd">        print(&quot;After deletion:&quot;, graph.node_indices())</span>
<span class="sd">        res_manual = graph.add_parent(6, None, None)</span>
<span class="sd">        print(&quot;After adding a new node:&quot;, graph.node_indices())</span>

<span class="sd">    Additionally, each node and edge contains an arbitrary Python object as a</span>
<span class="sd">    weight/data payload.</span>

<span class="sd">    You can use the index for access to the data payload as in the</span>
<span class="sd">    following example:</span>

<span class="sd">    .. jupyter-execute::</span>

<span class="sd">        import rustworkx as rx</span>

<span class="sd">        graph = rx.PyDAG()</span>
<span class="sd">        data_payload = &quot;An arbitrary Python object&quot;</span>
<span class="sd">        node_index = graph.add_node(data_payload)</span>
<span class="sd">        print(&quot;Node Index: %s&quot; % node_index)</span>
<span class="sd">        print(graph[node_index])</span>

<span class="sd">    The PyDAG class implements the Python mapping protocol for nodes so in</span>
<span class="sd">    addition to access you can also update the data payload with:</span>

<span class="sd">    .. jupyter-execute::</span>

<span class="sd">        import rustworkx as rx</span>

<span class="sd">        graph = rx.PyDAG()</span>
<span class="sd">        data_payload = &quot;An arbitrary Python object&quot;</span>
<span class="sd">        node_index = graph.add_node(data_payload)</span>
<span class="sd">        graph[node_index] = &quot;New Payload&quot;</span>
<span class="sd">        print(&quot;Node Index: %s&quot; % node_index)</span>
<span class="sd">        print(graph[node_index])</span>

<span class="sd">    The PyDAG class has an option for real time cycle checking which can</span>
<span class="sd">    be used to ensure any edges added to the graph does not introduce a cycle.</span>
<span class="sd">    By default the real time cycle checking feature is disabled for</span>
<span class="sd">    performance, however you can enable it by setting the ``check_cycle``</span>
<span class="sd">    attribute to True. For example::</span>

<span class="sd">        import rustworkx as rx</span>
<span class="sd">        dag = rx.PyDAG()</span>
<span class="sd">        dag.check_cycle = True</span>

<span class="sd">    or at object creation::</span>

<span class="sd">        import rustworkx as rx</span>
<span class="sd">        dag = rx.PyDAG(check_cycle=True)</span>

<span class="sd">    With check_cycle set to true any calls to :meth:`PyDAG.add_edge` will</span>
<span class="sd">    ensure that no cycles are added, ensuring that the PyDAG class truly</span>
<span class="sd">    represents a directed acyclic graph. Do note that this cycle checking on</span>
<span class="sd">    :meth:`~PyDAG.add_edge`, :meth:`~PyDigraph.add_edges_from`,</span>
<span class="sd">    :meth:`~PyDAG.add_edges_from_no_data`,</span>
<span class="sd">    :meth:`~PyDAG.extend_from_edge_list`,  and</span>
<span class="sd">    :meth:`~PyDAG.extend_from_weighted_edge_list` comes with a performance</span>
<span class="sd">    penalty that grows as the graph does.  If you&#39;re adding a node and edge at</span>
<span class="sd">    the same time, leveraging :meth:`PyDAG.add_child` or</span>
<span class="sd">    :meth:`PyDAG.add_parent` will avoid this overhead.</span>

<span class="sd">    By default a ``PyDAG`` is a multigraph (meaning there can be parallel</span>
<span class="sd">    edges between nodes) however this can be disabled by setting the</span>
<span class="sd">    ``multigraph`` kwarg to ``False`` when calling the ``PyDAG`` constructor.</span>
<span class="sd">    For example::</span>

<span class="sd">        import rustworkx as rx</span>
<span class="sd">        dag = rx.PyDAG(multigraph=False)</span>

<span class="sd">    This can only be set at ``PyDiGraph`` initialization and not adjusted after</span>
<span class="sd">    creation. When :attr:`~rustworkx.PyDiGraph.multigraph` is set to ``False``</span>
<span class="sd">    if a method call is made that would add a parallel edge it will instead</span>
<span class="sd">    update the existing edge&#39;s weight/data payload.</span>

<span class="sd">    The maximum number of nodes and edges allowed on a ``PyGraph`` object is</span>
<span class="sd">    :math:`2^{32} - 1` (4,294,967,294) each. Attempting to add more nodes or</span>
<span class="sd">    edges than this will result in an exception being raised.</span>

<span class="sd">    :param bool check_cycle: When this is set to ``True`` the created</span>
<span class="sd">        ``PyDAG`` has runtime cycle detection enabled.</span>
<span class="sd">    :param bool multgraph: When this is set to ``False`` the created</span>
<span class="sd">        ``PyDAG`` object will not be a multigraph. When ``False`` if a method</span>
<span class="sd">        call is made that would add parallel edges the the weight/weight from</span>
<span class="sd">        that method call will be used to update the existing edge in place.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">pass</span></div>


<div class="viewcode-block" id="distance_matrix"><a class="viewcode-back" href="../apiref/rustworkx.distance_matrix.html#rustworkx.distance_matrix">[docs]</a><span class="nd">@functools</span><span class="o">.</span><span class="n">singledispatch</span>
<span class="k">def</span> <span class="nf">distance_matrix</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">parallel_threshold</span><span class="o">=</span><span class="mi">300</span><span class="p">,</span> <span class="n">as_undirected</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">null_value</span><span class="o">=</span><span class="mf">0.0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Get the distance matrix for a graph</span>

<span class="sd">    This differs from functions like :func:`~rustworkx.floyd_warshall_numpy` in</span>
<span class="sd">    that the edge weight/data payload is not used and each edge is treated as a</span>
<span class="sd">    distance of 1.</span>

<span class="sd">    This function is also multithreaded and will run in parallel if the number</span>
<span class="sd">    of nodes in the graph is above the value of ``parallel_threshold`` (it</span>
<span class="sd">    defaults to 300). If the function will be running in parallel the env var</span>
<span class="sd">    ``RAYON_NUM_THREADS`` can be used to adjust how many threads will be used.</span>

<span class="sd">    :param graph: The graph to get the distance matrix for, can be either a</span>
<span class="sd">        :class:`~rustworkx.PyGraph` or :class:`~rustworkx.PyDiGraph`.</span>
<span class="sd">    :param int parallel_threshold: The number of nodes to calculate the</span>
<span class="sd">        the distance matrix in parallel at. It defaults to 300, but this can</span>
<span class="sd">        be tuned</span>
<span class="sd">    :param bool as_undirected: If set to ``True`` the input directed graph</span>
<span class="sd">        will be treat as if each edge was bidirectional/undirected in the</span>
<span class="sd">        output distance matrix.</span>
<span class="sd">    :param float null_value: An optional float that will treated as a null</span>
<span class="sd">        value. This is the default value in the output matrix and it is used</span>
<span class="sd">        to indicate the absence of an edge between 2 nodes. By default this</span>
<span class="sd">        is ``0.0``.</span>

<span class="sd">    :returns: The distance matrix</span>
<span class="sd">    :rtype: numpy.ndarray</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Invalid Input Type </span><span class="si">%s</span><span class="s2"> for graph&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">graph</span><span class="p">))</span></div>


<span class="n">distance_matrix</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">PyDiGraph</span><span class="p">,</span> <span class="n">digraph_distance_matrix</span><span class="p">)</span>
<span class="n">distance_matrix</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">PyGraph</span><span class="p">,</span> <span class="n">graph_distance_matrix</span><span class="p">)</span>


<div class="viewcode-block" id="unweighted_average_shortest_path_length"><a class="viewcode-back" href="../apiref/rustworkx.unweighted_average_shortest_path_length.html#rustworkx.unweighted_average_shortest_path_length">[docs]</a><span class="nd">@functools</span><span class="o">.</span><span class="n">singledispatch</span>
<span class="k">def</span> <span class="nf">unweighted_average_shortest_path_length</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">parallel_threshold</span><span class="o">=</span><span class="mi">300</span><span class="p">,</span> <span class="n">disconnected</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Return the average shortest path length with unweighted edges.</span>

<span class="sd">    The average shortest path length is calculated as</span>

<span class="sd">    .. math::</span>

<span class="sd">        a =\sum_{s,t \in V, s \ne t} \frac{d(s, t)}{n(n-1)}</span>

<span class="sd">    where :math:`V` is the set of nodes in ``graph``, :math:`d(s, t)` is the</span>
<span class="sd">    shortest path length from :math:`s` to :math:`t`, and :math:`n` is the</span>
<span class="sd">    number of nodes in ``graph``. If ``disconnected`` is set to ``True``,</span>
<span class="sd">    the average will be taken only between connected nodes.</span>

<span class="sd">    This function is also multithreaded and will run in parallel if the number</span>
<span class="sd">    of nodes in the graph is above the value of ``parallel_threshold`` (it</span>
<span class="sd">    defaults to 300). If the function will be running in parallel the env var</span>
<span class="sd">    ``RAYON_NUM_THREADS`` can be used to adjust how many threads will be used.</span>
<span class="sd">    By default it will use all available CPUs if the environment variable is</span>
<span class="sd">    not specified.</span>

<span class="sd">    :param graph: The graph to compute the average shortest path length for,</span>
<span class="sd">        can be either a :class:`~rustworkx.PyGraph` or :class:`~rustworkx.PyDiGraph`.</span>
<span class="sd">    :param int parallel_threshold: The number of nodes to calculate the</span>
<span class="sd">        the distance matrix in parallel at. It defaults to 300, but this can</span>
<span class="sd">        be tuned to any number of nodes.</span>
<span class="sd">    :param bool as_undirected: If set to ``True`` the input directed graph</span>
<span class="sd">        will be treated as if each edge was bidirectional/undirected while</span>
<span class="sd">        finding the shortest paths. Default: ``False``.</span>
<span class="sd">    :param bool disconnected: If set to ``True`` only connected vertex pairs</span>
<span class="sd">        will be included in the calculation. If ``False``, infinity is returned</span>
<span class="sd">        for disconnected graphs. Default: ``False``.</span>

<span class="sd">    :returns: The average shortest path length. If no vertex pairs can be included</span>
<span class="sd">        in the calculation this will return NaN.</span>

<span class="sd">    :rtype: float</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Invalid Input Type </span><span class="si">%s</span><span class="s2"> for graph&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">graph</span><span class="p">))</span></div>


<span class="n">unweighted_average_shortest_path_length</span><span class="o">.</span><span class="n">register</span><span class="p">(</span>
    <span class="n">PyDiGraph</span><span class="p">,</span> <span class="n">digraph_unweighted_average_shortest_path_length</span>
<span class="p">)</span>
<span class="n">unweighted_average_shortest_path_length</span><span class="o">.</span><span class="n">register</span><span class="p">(</span>
    <span class="n">PyGraph</span><span class="p">,</span> <span class="n">graph_unweighted_average_shortest_path_length</span>
<span class="p">)</span>


<div class="viewcode-block" id="adjacency_matrix"><a class="viewcode-back" href="../apiref/rustworkx.adjacency_matrix.html#rustworkx.adjacency_matrix">[docs]</a><span class="nd">@functools</span><span class="o">.</span><span class="n">singledispatch</span>
<span class="k">def</span> <span class="nf">adjacency_matrix</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">weight_fn</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">default_weight</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">null_value</span><span class="o">=</span><span class="mf">0.0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return the adjacency matrix for a graph object</span>

<span class="sd">    In the case where there are multiple edges between nodes the value in the</span>
<span class="sd">    output matrix will be the sum of the edges&#39; weights.</span>

<span class="sd">    :param graph: The graph used to generate the adjacency matrix from. Can</span>
<span class="sd">        either be a :class:`~rustworkx.PyGraph` or :class:`~rustworkx.PyDiGraph`</span>
<span class="sd">    :param callable weight_fn: A callable object (function, lambda, etc) which</span>
<span class="sd">        will be passed the edge object and expected to return a ``float``. This</span>
<span class="sd">        tells rustworkx/rust how to extract a numerical weight as a ``float``</span>
<span class="sd">        for edge object. Some simple examples are::</span>

<span class="sd">            adjacency_matrix(graph, weight_fn: lambda x: 1)</span>

<span class="sd">        to return a weight of 1 for all edges. Also::</span>

<span class="sd">            adjacency_matrix(graph, weight_fn: lambda x: float(x))</span>

<span class="sd">        to cast the edge object as a float as the weight. If this is not</span>
<span class="sd">        specified a default value (either ``default_weight`` or 1) will be used</span>
<span class="sd">        for all edges.</span>
<span class="sd">    :param float default_weight: If ``weight_fn`` is not used this can be</span>
<span class="sd">        optionally used to specify a default weight to use for all edges.</span>
<span class="sd">    :param float null_value: An optional float that will treated as a null</span>
<span class="sd">        value. This is the default value in the output matrix and it is used</span>
<span class="sd">        to indicate the absence of an edge between 2 nodes. By default this is</span>
<span class="sd">        ``0.0``.</span>

<span class="sd">     :return: The adjacency matrix for the input dag as a numpy array</span>
<span class="sd">     :rtype: numpy.ndarray</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Invalid Input Type </span><span class="si">%s</span><span class="s2"> for graph&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">graph</span><span class="p">))</span></div>


<span class="n">adjacency_matrix</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">PyDiGraph</span><span class="p">,</span> <span class="n">digraph_adjacency_matrix</span><span class="p">)</span>
<span class="n">adjacency_matrix</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">PyGraph</span><span class="p">,</span> <span class="n">graph_adjacency_matrix</span><span class="p">)</span>


<div class="viewcode-block" id="all_simple_paths"><a class="viewcode-back" href="../apiref/rustworkx.all_simple_paths.html#rustworkx.all_simple_paths">[docs]</a><span class="nd">@functools</span><span class="o">.</span><span class="n">singledispatch</span>
<span class="k">def</span> <span class="nf">all_simple_paths</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">from_</span><span class="p">,</span> <span class="n">to</span><span class="p">,</span> <span class="n">min_depth</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cutoff</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return all simple paths between 2 nodes in a PyGraph object</span>

<span class="sd">    A simple path is a path with no repeated nodes.</span>

<span class="sd">    :param graph: The graph to find the path in. Can either be a</span>
<span class="sd">        class:`~rustworkx.PyGraph` or :class:`~rustworkx.PyDiGraph`</span>
<span class="sd">    :param int from_: The node index to find the paths from</span>
<span class="sd">    :param int to: The node index to find the paths to</span>
<span class="sd">    :param int min_depth: The minimum depth of the path to include in the</span>
<span class="sd">        output list of paths. By default all paths are included regardless of</span>
<span class="sd">        depth, setting to 0 will behave like the default.</span>
<span class="sd">    :param int cutoff: The maximum depth of path to include in the output list</span>
<span class="sd">        of paths. By default includes all paths regardless of depth, setting to</span>
<span class="sd">        0 will behave like default.</span>

<span class="sd">    :returns: A list of lists where each inner list is a path of node indices</span>
<span class="sd">    :rtype: list</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Invalid Input Type </span><span class="si">%s</span><span class="s2"> for graph&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">graph</span><span class="p">))</span></div>


<span class="n">all_simple_paths</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">PyDiGraph</span><span class="p">,</span> <span class="n">digraph_all_simple_paths</span><span class="p">)</span>
<span class="n">all_simple_paths</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">PyGraph</span><span class="p">,</span> <span class="n">graph_all_simple_paths</span><span class="p">)</span>


<div class="viewcode-block" id="floyd_warshall"><a class="viewcode-back" href="../apiref/rustworkx.floyd_warshall.html#rustworkx.floyd_warshall">[docs]</a><span class="nd">@functools</span><span class="o">.</span><span class="n">singledispatch</span>
<span class="k">def</span> <span class="nf">floyd_warshall</span><span class="p">(</span>
    <span class="n">graph</span><span class="p">,</span>
    <span class="n">weight_fn</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">default_weight</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
    <span class="n">parallel_threshold</span><span class="o">=</span><span class="mi">300</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Find all-pairs shortest path lengths using Floyd&#39;s algorithm</span>

<span class="sd">    Floyd&#39;s algorithm is used for finding shortest paths in dense graphs</span>
<span class="sd">    or graphs with negative weights (where Dijkstra&#39;s algorithm fails).</span>

<span class="sd">    This function is multithreaded and will launch a pool with threads equal</span>
<span class="sd">    to the number of CPUs by default if the number of nodes in the graph is</span>
<span class="sd">    above the value of ``parallel_threshold`` (it defaults to 300).</span>
<span class="sd">    You can tune the number of threads with the ``RAYON_NUM_THREADS``</span>
<span class="sd">    environment variable. For example, setting ``RAYON_NUM_THREADS=4`` would</span>
<span class="sd">    limit the thread pool to 4 threads if parallelization was enabled.</span>

<span class="sd">    :param graph: The graph to run Floyd&#39;s algorithm on. Can</span>
<span class="sd">        either be a :class:`~rustworkx.PyGraph` or :class:`~rustworkx.PyDiGraph`</span>
<span class="sd">    :param callable weight_fn: A callable object (function, lambda, etc) which</span>
<span class="sd">        will be passed the edge object and expected to return a ``float``. This</span>
<span class="sd">        tells rustworkx/rust how to extract a numerical weight as a ``float``</span>
<span class="sd">        for edge object. Some simple examples are::</span>

<span class="sd">            floyd_warshall(graph, weight_fn= lambda x: 1)</span>

<span class="sd">        to return a weight of 1 for all edges. Also::</span>

<span class="sd">            floyd_warshall(graph, weight_fn=float)</span>

<span class="sd">        to cast the edge object as a float as the weight. If this is not</span>
<span class="sd">        specified a default value (either ``default_weight`` or 1) will be used</span>
<span class="sd">        for all edges.</span>
<span class="sd">    :param float default_weight: If ``weight_fn`` is not used this can be</span>
<span class="sd">        optionally used to specify a default weight to use for all edges.</span>
<span class="sd">    :param int parallel_threshold: The number of nodes to execute</span>
<span class="sd">        the algorithm in parallel at. It defaults to 300, but this can</span>
<span class="sd">        be tuned</span>

<span class="sd">    :return: A read-only dictionary of path lengths. The keys are the source</span>
<span class="sd">        node indices and the values are a dict of the target node and the</span>
<span class="sd">        length of the shortest path to that node. For example::</span>

<span class="sd">            {</span>
<span class="sd">                0: {0: 0.0, 1: 2.0, 2: 2.0},</span>
<span class="sd">                1: {1: 0.0, 2: 1.0},</span>
<span class="sd">                2: {0: 1.0, 2: 0.0},</span>
<span class="sd">            }</span>

<span class="sd">    :rtype: AllPairsPathLengthMapping</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Invalid Input Type </span><span class="si">%s</span><span class="s2"> for graph&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">graph</span><span class="p">))</span></div>


<span class="n">floyd_warshall</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">PyDiGraph</span><span class="p">,</span> <span class="n">digraph_floyd_warshall</span><span class="p">)</span>
<span class="n">floyd_warshall</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">PyGraph</span><span class="p">,</span> <span class="n">graph_floyd_warshall</span><span class="p">)</span>


<div class="viewcode-block" id="floyd_warshall_numpy"><a class="viewcode-back" href="../apiref/rustworkx.floyd_warshall_numpy.html#rustworkx.floyd_warshall_numpy">[docs]</a><span class="nd">@functools</span><span class="o">.</span><span class="n">singledispatch</span>
<span class="k">def</span> <span class="nf">floyd_warshall_numpy</span><span class="p">(</span>
    <span class="n">graph</span><span class="p">,</span>
    <span class="n">weight_fn</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">default_weight</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
    <span class="n">parallel_threshold</span><span class="o">=</span><span class="mi">300</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Find all-pairs shortest path lengths using Floyd&#39;s algorithm</span>

<span class="sd">    Floyd&#39;s algorithm is used for finding shortest paths in dense graphs</span>
<span class="sd">    or graphs with negative weights (where Dijkstra&#39;s algorithm fails).</span>

<span class="sd">    This function is multithreaded and will launch a pool with threads equal</span>
<span class="sd">    to the number of CPUs by default if the number of nodes in the graph is</span>
<span class="sd">    above the value of ``parallel_threshold`` (it defaults to 300).</span>
<span class="sd">    You can tune the number of threads with the ``RAYON_NUM_THREADS``</span>
<span class="sd">    environment variable. For example, setting ``RAYON_NUM_THREADS=4`` would</span>
<span class="sd">    limit the thread pool to 4 threads if parallelization was enabled.</span>

<span class="sd">    :param graph: The graph to run Floyd&#39;s algorithm on. Can</span>
<span class="sd">        either be a :class:`~rustworkx.PyGraph` or :class:`~rustworkx.PyDiGraph`</span>
<span class="sd">    :param callable weight_fn: A callable object (function, lambda, etc) which</span>
<span class="sd">        will be passed the edge object and expected to return a ``float``. This</span>
<span class="sd">        tells rustworkx/rust how to extract a numerical weight as a ``float``</span>
<span class="sd">        for edge object. Some simple examples are::</span>

<span class="sd">            floyd_warshall_numpy(graph, weight_fn: lambda x: 1)</span>

<span class="sd">        to return a weight of 1 for all edges. Also::</span>

<span class="sd">            floyd_warshall_numpy(graph, weight_fn: lambda x: float(x))</span>

<span class="sd">        to cast the edge object as a float as the weight. If this is not</span>
<span class="sd">        specified a default value (either ``default_weight`` or 1) will be used</span>
<span class="sd">        for all edges.</span>
<span class="sd">    :param float default_weight: If ``weight_fn`` is not used this can be</span>
<span class="sd">        optionally used to specify a default weight to use for all edges.</span>
<span class="sd">    :param int parallel_threshold: The number of nodes to execute</span>
<span class="sd">        the algorithm in parallel at. It defaults to 300, but this can</span>
<span class="sd">        be tuned</span>

<span class="sd">    :returns: A matrix of shortest path distances between nodes. If there is no</span>
<span class="sd">        path between two nodes then the corresponding matrix entry will be</span>
<span class="sd">        ``np.inf``.</span>
<span class="sd">    :rtype: numpy.ndarray</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Invalid Input Type </span><span class="si">%s</span><span class="s2"> for graph&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">graph</span><span class="p">))</span></div>


<span class="n">floyd_warshall_numpy</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">PyDiGraph</span><span class="p">,</span> <span class="n">digraph_floyd_warshall_numpy</span><span class="p">)</span>
<span class="n">floyd_warshall_numpy</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">PyGraph</span><span class="p">,</span> <span class="n">graph_floyd_warshall_numpy</span><span class="p">)</span>


<div class="viewcode-block" id="astar_shortest_path"><a class="viewcode-back" href="../apiref/rustworkx.astar_shortest_path.html#rustworkx.astar_shortest_path">[docs]</a><span class="nd">@functools</span><span class="o">.</span><span class="n">singledispatch</span>
<span class="k">def</span> <span class="nf">astar_shortest_path</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">goal_fn</span><span class="p">,</span> <span class="n">edge_cost_fn</span><span class="p">,</span> <span class="n">estimate_cost_fn</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute the A* shortest path for a graph</span>

<span class="sd">    :param graph: The input graph to use. Can</span>
<span class="sd">        either be a :class:`~rustworkx.PyGraph` or :class:`~rustworkx.PyDiGraph`</span>
<span class="sd">    :param int node: The node index to compute the path from</span>
<span class="sd">    :param goal_fn: A python callable that will take in 1 parameter, a node&#39;s</span>
<span class="sd">        data object and will return a boolean which will be True if it is the</span>
<span class="sd">        finish node.</span>
<span class="sd">    :param edge_cost_fn: A python callable that will take in 1 parameter, an</span>
<span class="sd">        edge&#39;s data object and will return a float that represents the cost</span>
<span class="sd">        of that edge. It must be non-negative.</span>
<span class="sd">    :param estimate_cost_fn: A python callable that will take in 1 parameter, a</span>
<span class="sd">        node&#39;s data object and will return a float which represents the</span>
<span class="sd">        estimated cost for the next node. The return must be non-negative. For</span>
<span class="sd">        the algorithm to find the actual shortest path, it should be</span>
<span class="sd">        admissible, meaning that it should never overestimate the actual cost</span>
<span class="sd">        to get to the nearest goal node.</span>

<span class="sd">    :returns: The computed shortest path between node and finish as a list</span>
<span class="sd">        of node indices.</span>
<span class="sd">    :rtype: NodeIndices</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Invalid Input Type </span><span class="si">%s</span><span class="s2"> for graph&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">graph</span><span class="p">))</span></div>


<span class="n">astar_shortest_path</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">PyDiGraph</span><span class="p">,</span> <span class="n">digraph_astar_shortest_path</span><span class="p">)</span>
<span class="n">astar_shortest_path</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">PyGraph</span><span class="p">,</span> <span class="n">graph_astar_shortest_path</span><span class="p">)</span>


<div class="viewcode-block" id="dijkstra_shortest_paths"><a class="viewcode-back" href="../apiref/rustworkx.dijkstra_shortest_paths.html#rustworkx.dijkstra_shortest_paths">[docs]</a><span class="nd">@functools</span><span class="o">.</span><span class="n">singledispatch</span>
<span class="k">def</span> <span class="nf">dijkstra_shortest_paths</span><span class="p">(</span>
    <span class="n">graph</span><span class="p">,</span>
    <span class="n">source</span><span class="p">,</span>
    <span class="n">target</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">weight_fn</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">default_weight</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
    <span class="n">as_undirected</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Find the shortest path from a node</span>

<span class="sd">    This function will generate the shortest path from a source node using</span>
<span class="sd">    Dijkstra&#39;s algorithm.</span>

<span class="sd">    :param graph: The input graph to use. Can either be a</span>
<span class="sd">        :class:`~rustworkx.PyGraph` or :class:`~rustworkx.PyDiGraph`</span>
<span class="sd">    :param int source: The node index to find paths from</span>
<span class="sd">    :param int target: An optional target to find a path to</span>
<span class="sd">    :param weight_fn: An optional weight function for an edge. It will accept</span>
<span class="sd">        a single argument, the edge&#39;s weight object and will return a float</span>
<span class="sd">        which will be used to represent the weight/cost of the edge</span>
<span class="sd">    :param float default_weight: If ``weight_fn`` isn&#39;t specified this optional</span>
<span class="sd">        float value will be used for the weight/cost of each edge.</span>
<span class="sd">    :param bool as_undirected: If set to true the graph will be treated as</span>
<span class="sd">        undirected for finding the shortest path. This only works with a</span>
<span class="sd">        :class:`~rustworkx.PyDiGraph` input for ``graph``</span>

<span class="sd">    :return: Dictionary of paths. The keys are destination node indices and</span>
<span class="sd">        the dict values are lists of node indices making the path.</span>
<span class="sd">    :rtype: dict</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Invalid Input Type </span><span class="si">%s</span><span class="s2"> for graph&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">graph</span><span class="p">))</span></div>


<span class="n">dijkstra_shortest_paths</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">PyDiGraph</span><span class="p">,</span> <span class="n">digraph_dijkstra_shortest_paths</span><span class="p">)</span>
<span class="n">dijkstra_shortest_paths</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">PyGraph</span><span class="p">,</span> <span class="n">graph_dijkstra_shortest_paths</span><span class="p">)</span>


<div class="viewcode-block" id="has_path"><a class="viewcode-back" href="../apiref/rustworkx.has_path.html#rustworkx.has_path">[docs]</a><span class="nd">@functools</span><span class="o">.</span><span class="n">singledispatch</span>
<span class="k">def</span> <span class="nf">has_path</span><span class="p">(</span>
    <span class="n">graph</span><span class="p">,</span>
    <span class="n">source</span><span class="p">,</span>
    <span class="n">target</span><span class="p">,</span>
    <span class="n">as_undirected</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Checks if a path exists between a source and target node</span>

<span class="sd">    :param graph: The input graph to use. Can either be a</span>
<span class="sd">        :class:`~rustworkx.PyGraph` or :class:`~rustworkx.PyDiGraph`</span>
<span class="sd">    :param int source: The node index to find paths from</span>
<span class="sd">    :param int target: The index of the target node</span>
<span class="sd">    :param bool as_undirected: If set to true the graph will be treated as</span>
<span class="sd">        undirected for finding existence of a path. This only works with a</span>
<span class="sd">        :class:`~rustworkx.PyDiGraph` input for ``graph``</span>

<span class="sd">    :return: True if a path exists, False if not</span>
<span class="sd">    :rtype: bool</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Invalid Input Type </span><span class="si">%s</span><span class="s2"> for graph&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">graph</span><span class="p">))</span></div>


<span class="n">has_path</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">PyDiGraph</span><span class="p">,</span> <span class="n">digraph_has_path</span><span class="p">)</span>
<span class="n">has_path</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">PyGraph</span><span class="p">,</span> <span class="n">graph_has_path</span><span class="p">)</span>


<div class="viewcode-block" id="all_pairs_dijkstra_shortest_paths"><a class="viewcode-back" href="../apiref/rustworkx.all_pairs_dijkstra_shortest_paths.html#rustworkx.all_pairs_dijkstra_shortest_paths">[docs]</a><span class="nd">@functools</span><span class="o">.</span><span class="n">singledispatch</span>
<span class="k">def</span> <span class="nf">all_pairs_dijkstra_shortest_paths</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">edge_cost_fn</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;For each node in the graph, finds the shortest paths to all others.</span>

<span class="sd">    This function will generate the shortest path from all nodes in the graph</span>
<span class="sd">    using Dijkstra&#39;s algorithm. This function is multithreaded and will run</span>
<span class="sd">    launch a thread pool with threads equal to the number of CPUs by default.</span>
<span class="sd">    You can tune the number of threads with the ``RAYON_NUM_THREADS``</span>
<span class="sd">    environment variable. For example, setting ``RAYON_NUM_THREADS=4`` would</span>
<span class="sd">    limit the thread pool to 4 threads.</span>

<span class="sd">    :param graph: The input graph to use. Can either be a</span>
<span class="sd">        :class:`~rustworkx.PyGraph` or :class:`~rustworkx.PyDiGraph`</span>
<span class="sd">    :param edge_cost_fn: A callable object that acts as a weight function for</span>
<span class="sd">        an edge. It will accept a single positional argument, the edge&#39;s weight</span>
<span class="sd">        object and will return a float which will be used to represent the</span>
<span class="sd">        weight/cost of the edge</span>

<span class="sd">    :return: A read-only dictionary of paths. The keys are source node</span>
<span class="sd">        indices and the values are a dict of target node indices and a list</span>
<span class="sd">        of node indices making the path. For example::</span>

<span class="sd">            {</span>
<span class="sd">                0: {1: [0, 1],  2: [0, 1, 2]},</span>
<span class="sd">                1: {2: [1, 2]},</span>
<span class="sd">                2: {0: [2, 0]},</span>
<span class="sd">            }</span>

<span class="sd">    :rtype: AllPairsPathMapping</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Invalid Input Type </span><span class="si">%s</span><span class="s2"> for graph&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">graph</span><span class="p">))</span></div>


<span class="n">all_pairs_dijkstra_shortest_paths</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">PyDiGraph</span><span class="p">,</span> <span class="n">digraph_all_pairs_dijkstra_shortest_paths</span><span class="p">)</span>
<span class="n">all_pairs_dijkstra_shortest_paths</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">PyGraph</span><span class="p">,</span> <span class="n">graph_all_pairs_dijkstra_shortest_paths</span><span class="p">)</span>


<div class="viewcode-block" id="all_pairs_all_simple_paths"><a class="viewcode-back" href="../apiref/rustworkx.all_pairs_all_simple_paths.html#rustworkx.all_pairs_all_simple_paths">[docs]</a><span class="nd">@functools</span><span class="o">.</span><span class="n">singledispatch</span>
<span class="k">def</span> <span class="nf">all_pairs_all_simple_paths</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">min_depth</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cutoff</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return all the simple paths between all pairs of nodes in the graph</span>

<span class="sd">    This function is multithreaded and will launch a thread pool with threads</span>
<span class="sd">    equal to the number of CPUs by default. You can tune the number of threads</span>
<span class="sd">    with the ``RAYON_NUM_THREADS`` environment variable. For example, setting</span>
<span class="sd">    ``RAYON_NUM_THREADS=4`` would limit the thread pool to 4 threads.</span>

<span class="sd">    :param graph: The graph to find all simple paths in. This can be a :class:`~rustworkx.PyGraph`</span>
<span class="sd">        or a :class:`~rustworkx.PyDiGraph`</span>
<span class="sd">    :param int min_depth: The minimum depth of the path to include in the output</span>
<span class="sd">        list of paths. By default all paths are included regardless of depth,</span>
<span class="sd">        setting to 0 will behave like the default.</span>
<span class="sd">    :param int cutoff: The maximum depth of path to include in the output list</span>
<span class="sd">        of paths. By default includes all paths regardless of depth, setting to</span>
<span class="sd">        0 will behave like default.</span>

<span class="sd">    :returns: A mapping of source node indices to a mapping of target node</span>
<span class="sd">        indices to a list of paths between the source and target nodes.</span>
<span class="sd">    :rtype: AllPairsMultiplePathMapping</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Invalid Input Type </span><span class="si">%s</span><span class="s2"> for graph&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">graph</span><span class="p">))</span></div>


<span class="n">all_pairs_all_simple_paths</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">PyDiGraph</span><span class="p">,</span> <span class="n">digraph_all_pairs_all_simple_paths</span><span class="p">)</span>
<span class="n">all_pairs_all_simple_paths</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">PyGraph</span><span class="p">,</span> <span class="n">graph_all_pairs_all_simple_paths</span><span class="p">)</span>


<div class="viewcode-block" id="all_pairs_dijkstra_path_lengths"><a class="viewcode-back" href="../apiref/rustworkx.all_pairs_dijkstra_path_lengths.html#rustworkx.all_pairs_dijkstra_path_lengths">[docs]</a><span class="nd">@functools</span><span class="o">.</span><span class="n">singledispatch</span>
<span class="k">def</span> <span class="nf">all_pairs_dijkstra_path_lengths</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">edge_cost_fn</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;For each node in the graph, calculates the lengths of the shortest paths to all others.</span>

<span class="sd">    This function will generate the shortest path lengths from all nodes in the</span>
<span class="sd">    graph using Dijkstra&#39;s algorithm. This function is multithreaded and will</span>
<span class="sd">    launch a thread pool with threads equal to the number of CPUs by</span>
<span class="sd">    default. You can tune the number of threads with the ``RAYON_NUM_THREADS``</span>
<span class="sd">    environment variable. For example, setting ``RAYON_NUM_THREADS=4`` would</span>
<span class="sd">    limit the thread pool to 4 threads.</span>

<span class="sd">    :param graph: The input graph to use. Can either be a</span>
<span class="sd">        :class:`~rustworkx.PyGraph` or :class:`~rustworkx.PyDiGraph`</span>
<span class="sd">    :param edge_cost_fn: A callable object that acts as a weight function for</span>
<span class="sd">        an edge. It will accept a single positional argument, the edge&#39;s weight</span>
<span class="sd">        object and will return a float which will be used to represent the</span>
<span class="sd">        weight/cost of the edge</span>

<span class="sd">    :return: A read-only dictionary of path lengths. The keys are the source</span>
<span class="sd">        node indices and the values are a dict of the target node and the</span>
<span class="sd">        length of the shortest path to that node. For example::</span>

<span class="sd">            {</span>
<span class="sd">                0: {1: 2.0, 2: 2.0},</span>
<span class="sd">                1: {2: 1.0},</span>
<span class="sd">                2: {0: 1.0},</span>
<span class="sd">            }</span>

<span class="sd">    :rtype: AllPairsPathLengthMapping</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Invalid Input Type </span><span class="si">%s</span><span class="s2"> for graph&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">graph</span><span class="p">))</span></div>


<span class="n">all_pairs_dijkstra_path_lengths</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">PyDiGraph</span><span class="p">,</span> <span class="n">digraph_all_pairs_dijkstra_path_lengths</span><span class="p">)</span>
<span class="n">all_pairs_dijkstra_path_lengths</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">PyGraph</span><span class="p">,</span> <span class="n">graph_all_pairs_dijkstra_path_lengths</span><span class="p">)</span>


<div class="viewcode-block" id="dijkstra_shortest_path_lengths"><a class="viewcode-back" href="../apiref/rustworkx.dijkstra_shortest_path_lengths.html#rustworkx.dijkstra_shortest_path_lengths">[docs]</a><span class="nd">@functools</span><span class="o">.</span><span class="n">singledispatch</span>
<span class="k">def</span> <span class="nf">dijkstra_shortest_path_lengths</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">edge_cost_fn</span><span class="p">,</span> <span class="n">goal</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute the lengths of the shortest paths for a graph object using</span>
<span class="sd">    Dijkstra&#39;s algorithm.</span>

<span class="sd">    :param graph: The input graph to use. Can either be a</span>
<span class="sd">        :class:`~rustworkx.PyGraph` or :class:`~rustworkx.PyDiGraph`</span>
<span class="sd">    :param int node: The node index to use as the source for finding the</span>
<span class="sd">        shortest paths from</span>
<span class="sd">    :param edge_cost_fn: A python callable that will take in 1 parameter, an</span>
<span class="sd">        edge&#39;s data object and will return a float that represents the</span>
<span class="sd">        cost/weight of that edge. It must be non-negative</span>
<span class="sd">    :param int goal: An optional node index to use as the end of the path.</span>
<span class="sd">        When specified the traversal will stop when the goal is reached and</span>
<span class="sd">        the output dictionary will only have a single entry with the length</span>
<span class="sd">        of the shortest path to the goal node.</span>

<span class="sd">    :returns: A dictionary of the shortest paths from the provided node where</span>
<span class="sd">        the key is the node index of the end of the path and the value is the</span>
<span class="sd">        cost/sum of the weights of path</span>
<span class="sd">    :rtype: dict</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Invalid Input Type </span><span class="si">%s</span><span class="s2"> for graph&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">graph</span><span class="p">))</span></div>


<span class="n">dijkstra_shortest_path_lengths</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">PyDiGraph</span><span class="p">,</span> <span class="n">digraph_dijkstra_shortest_path_lengths</span><span class="p">)</span>
<span class="n">dijkstra_shortest_path_lengths</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">PyGraph</span><span class="p">,</span> <span class="n">graph_dijkstra_shortest_path_lengths</span><span class="p">)</span>


<div class="viewcode-block" id="k_shortest_path_lengths"><a class="viewcode-back" href="../apiref/rustworkx.k_shortest_path_lengths.html#rustworkx.k_shortest_path_lengths">[docs]</a><span class="nd">@functools</span><span class="o">.</span><span class="n">singledispatch</span>
<span class="k">def</span> <span class="nf">k_shortest_path_lengths</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">edge_cost</span><span class="p">,</span> <span class="n">goal</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute the length of the kth shortest path</span>

<span class="sd">    Computes the lengths of the kth shortest path from ``start`` to every</span>
<span class="sd">    reachable node.</span>

<span class="sd">    Computes in :math:`O(k * (|E| + |V|*log(|V|)))` time (average).</span>

<span class="sd">    :param graph: The graph to find the shortest paths in. Can either be a</span>
<span class="sd">        :class:`~rustworkx.PyGraph` or :class:`~rustworkx.PyDiGraph`</span>
<span class="sd">    :param int start: The node index to find the shortest paths from</span>
<span class="sd">    :param int k: The kth shortest path to find the lengths of</span>
<span class="sd">    :param edge_cost: A python callable that will receive an edge payload and</span>
<span class="sd">        return a float for the cost of that eedge</span>
<span class="sd">    :param int goal: An optional goal node index, if specified the output</span>
<span class="sd">        dictionary</span>

<span class="sd">    :returns: A dict of lengths where the key is the destination node index and</span>
<span class="sd">        the value is the length of the path.</span>
<span class="sd">    :rtype: dict</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Invalid Input Type </span><span class="si">%s</span><span class="s2"> for graph&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">graph</span><span class="p">))</span></div>


<span class="n">k_shortest_path_lengths</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">PyDiGraph</span><span class="p">,</span> <span class="n">digraph_k_shortest_path_lengths</span><span class="p">)</span>
<span class="n">k_shortest_path_lengths</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">PyGraph</span><span class="p">,</span> <span class="n">graph_k_shortest_path_lengths</span><span class="p">)</span>


<div class="viewcode-block" id="dfs_edges"><a class="viewcode-back" href="../apiref/rustworkx.dfs_edges.html#rustworkx.dfs_edges">[docs]</a><span class="nd">@functools</span><span class="o">.</span><span class="n">singledispatch</span>
<span class="k">def</span> <span class="nf">dfs_edges</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Get an edge list of the tree edges from a depth-first traversal</span>

<span class="sd">    The pseudo-code for the DFS algorithm is listed below. The output</span>
<span class="sd">    contains the tree edges found by the procedure.</span>

<span class="sd">    ::</span>

<span class="sd">        DFS(G, v)</span>
<span class="sd">          let S be a stack</span>
<span class="sd">          label v as discovered</span>
<span class="sd">          PUSH(S, (v, iterator of G.neighbors(v)))</span>
<span class="sd">          while (S != Ø)</span>
<span class="sd">              let (v, iterator) := LAST(S)</span>
<span class="sd">              if hasNext(iterator) then</span>
<span class="sd">                  w := next(iterator)</span>
<span class="sd">                  if w is not labeled as discovered then</span>
<span class="sd">                      label w as discovered                   # (v, w) is a tree edge</span>
<span class="sd">                      PUSH(S, (w, iterator of G.neighbors(w)))</span>
<span class="sd">              else</span>
<span class="sd">                  POP(S)</span>
<span class="sd">          end while</span>

<span class="sd">    .. note::</span>

<span class="sd">        If the input is an undirected graph with a single connected component,</span>
<span class="sd">        the output of this function is a spanning tree.</span>

<span class="sd">    :param graph: The graph to get the DFS edge list from. Can either be a</span>
<span class="sd">        :class:`~rustworkx.PyGraph` or :class:`~rustworkx.PyDiGraph`</span>
<span class="sd">    :param int source: An optional node index to use as the starting node</span>
<span class="sd">        for the depth-first search. The edge list will only return edges in</span>
<span class="sd">        the components reachable from this index. If this is not specified</span>
<span class="sd">        then a source will be chosen arbitrarly and repeated until all</span>
<span class="sd">        components of the graph are searched.</span>

<span class="sd">    :returns: A list of edges as a tuple of the form ``(source, target)`` in</span>
<span class="sd">        depth-first order</span>
<span class="sd">    :rtype: EdgeList</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Invalid Input Type </span><span class="si">%s</span><span class="s2"> for graph&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">graph</span><span class="p">))</span></div>


<span class="n">dfs_edges</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">PyDiGraph</span><span class="p">,</span> <span class="n">digraph_dfs_edges</span><span class="p">)</span>
<span class="n">dfs_edges</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">PyGraph</span><span class="p">,</span> <span class="n">graph_dfs_edges</span><span class="p">)</span>


<div class="viewcode-block" id="is_isomorphic"><a class="viewcode-back" href="../apiref/rustworkx.is_isomorphic.html#rustworkx.is_isomorphic">[docs]</a><span class="nd">@functools</span><span class="o">.</span><span class="n">singledispatch</span>
<span class="k">def</span> <span class="nf">is_isomorphic</span><span class="p">(</span>
    <span class="n">first</span><span class="p">,</span>
    <span class="n">second</span><span class="p">,</span>
    <span class="n">node_matcher</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">edge_matcher</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">id_order</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">call_limit</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Determine if 2 graphs are isomorphic</span>

<span class="sd">    This checks if 2 graphs are isomorphic both structurally and also</span>
<span class="sd">    comparing the node and edge data using the provided matcher functions.</span>
<span class="sd">    The matcher functions take in 2 data objects and will compare them. A</span>
<span class="sd">    simple example that checks if they&#39;re just equal would be::</span>

<span class="sd">            graph_a = rustworkx.PyGraph()</span>
<span class="sd">            graph_b = rustworkx.PyGraph()</span>
<span class="sd">            rustworkx.is_isomorphic(graph_a, graph_b,</span>
<span class="sd">                                lambda x, y: x == y)</span>

<span class="sd">    .. note::</span>

<span class="sd">        For better performance on large graphs, consider setting</span>
<span class="sd">        `id_order=False`.</span>

<span class="sd">    :param first: The first graph to compare. Can either be a</span>
<span class="sd">        :class:`~rustworkx.PyGraph` or :class:`~rustworkx.PyDiGraph`.</span>
<span class="sd">    :param second: The second graph to compare. Can either be a</span>
<span class="sd">        :class:`~rustworkx.PyGraph` or :class:`~rustworkx.PyDiGraph`.</span>
<span class="sd">        It should be the same type as the first graph.</span>
<span class="sd">    :param callable node_matcher: A python callable object that takes 2</span>
<span class="sd">        positional one for each node data object. If the return of this</span>
<span class="sd">        function evaluates to True then the nodes passed to it are viewed</span>
<span class="sd">        as matching.</span>
<span class="sd">    :param callable edge_matcher: A python callable object that takes 2</span>
<span class="sd">        positional one for each edge data object. If the return of this</span>
<span class="sd">        function evaluates to True then the edges passed to it are viewed</span>
<span class="sd">        as matching.</span>
<span class="sd">    :param bool id_order: If set to ``False`` this function will use a</span>
<span class="sd">        heuristic matching order based on [VF2]_ paper. Otherwise it will</span>
<span class="sd">        default to matching the nodes in order specified by their ids.</span>
<span class="sd">    :param int call_limit: An optional bound on the number of states that VF2</span>
<span class="sd">        algorithm visits while searching for a solution. If it exceeds this limit,</span>
<span class="sd">        the algorithm will stop and return ``False``.</span>

<span class="sd">    :returns: ``True`` if the 2 graphs are isomorphic, ``False`` if they are</span>
<span class="sd">        not.</span>
<span class="sd">    :rtype: bool</span>

<span class="sd">    .. [VF2] VF2++  An Improved Subgraph Isomorphism Algorithm</span>
<span class="sd">        by Alpár Jüttner and Péter Madarasi</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Invalid Input Type </span><span class="si">%s</span><span class="s2"> for graph&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">first</span><span class="p">))</span></div>


<span class="n">is_isomorphic</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">PyDiGraph</span><span class="p">,</span> <span class="n">digraph_is_isomorphic</span><span class="p">)</span>
<span class="n">is_isomorphic</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">PyGraph</span><span class="p">,</span> <span class="n">graph_is_isomorphic</span><span class="p">)</span>


<div class="viewcode-block" id="is_isomorphic_node_match"><a class="viewcode-back" href="../apiref/rustworkx.is_isomorphic_node_match.html#rustworkx.is_isomorphic_node_match">[docs]</a><span class="nd">@functools</span><span class="o">.</span><span class="n">singledispatch</span>
<span class="k">def</span> <span class="nf">is_isomorphic_node_match</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">second</span><span class="p">,</span> <span class="n">matcher</span><span class="p">,</span> <span class="n">id_order</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Determine if 2 graphs are isomorphic</span>

<span class="sd">    This checks if 2 graphs are isomorphic both structurally and also</span>
<span class="sd">    comparing the node data using the provided matcher function. The matcher</span>
<span class="sd">    function takes in 2 node data objects and will compare them. A simple</span>
<span class="sd">    example that checks if they&#39;re just equal would be::</span>

<span class="sd">        graph_a = rustworkx.PyDAG()</span>
<span class="sd">        graph_b = rustworkx.PyDAG()</span>
<span class="sd">        rustworkx.is_isomorphic_node_match(graph_a, graph_b,</span>
<span class="sd">                                        lambda x, y: x == y)</span>

<span class="sd">    .. note::</span>

<span class="sd">        For better performance on large graphs, consider setting</span>
<span class="sd">        `id_order=False`.</span>

<span class="sd">    :param first: The first graph to compare. Can either be a</span>
<span class="sd">        :class:`~rustworkx.PyGraph` or :class:`~rustworkx.PyDiGraph`.</span>
<span class="sd">    :param second: The second graph to compare. Can either be a</span>
<span class="sd">        :class:`~rustworkx.PyGraph` or :class:`~rustworkx.PyDiGraph`.</span>
<span class="sd">        It should be the same type as the first graph.</span>
<span class="sd">    :param callable matcher: A python callable object that takes 2 positional</span>
<span class="sd">        one for each node data object. If the return of this</span>
<span class="sd">        function evaluates to True then the nodes passed to it are vieded</span>
<span class="sd">        as matching.</span>
<span class="sd">    :param bool id_order: If set to ``False`` this function will use a</span>
<span class="sd">        heuristic matching order based on [VF2]_ paper. Otherwise it will</span>
<span class="sd">        default to matching the nodes in order specified by their ids.</span>

<span class="sd">    :returns: ``True`` if the 2 graphs are isomorphic ``False`` if they are</span>
<span class="sd">        not.</span>
<span class="sd">    :rtype: bool</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Invalid Input Type </span><span class="si">%s</span><span class="s2"> for graph&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">first</span><span class="p">))</span></div>


<span class="n">is_isomorphic_node_match</span><span class="o">.</span><span class="n">register</span><span class="p">(</span>
    <span class="n">PyDiGraph</span><span class="p">,</span> <span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span><span class="n">digraph_is_isomorphic</span><span class="p">,</span> <span class="n">edge_matcher</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="p">)</span>
<span class="n">is_isomorphic_node_match</span><span class="o">.</span><span class="n">register</span><span class="p">(</span>
    <span class="n">PyGraph</span><span class="p">,</span> <span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span><span class="n">graph_is_isomorphic</span><span class="p">,</span> <span class="n">edge_matcher</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="p">)</span>


<div class="viewcode-block" id="is_subgraph_isomorphic"><a class="viewcode-back" href="../apiref/rustworkx.is_subgraph_isomorphic.html#rustworkx.is_subgraph_isomorphic">[docs]</a><span class="nd">@functools</span><span class="o">.</span><span class="n">singledispatch</span>
<span class="k">def</span> <span class="nf">is_subgraph_isomorphic</span><span class="p">(</span>
    <span class="n">first</span><span class="p">,</span>
    <span class="n">second</span><span class="p">,</span>
    <span class="n">node_matcher</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">edge_matcher</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">id_order</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">induced</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">call_limit</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Determine if 2 graphs are subgraph isomorphic</span>

<span class="sd">    This checks if 2 graphs are subgraph isomorphic both structurally and also</span>
<span class="sd">    comparing the node and edge data using the provided matcher functions.</span>
<span class="sd">    The matcher functions take in 2 data objects and will compare them.</span>
<span class="sd">    Since there is an ambiguity in the term &#39;subgraph&#39;, do note that we check</span>
<span class="sd">    for an node-induced subgraph if argument `induced` is set to `True`. If it is</span>
<span class="sd">    set to `False`, we check for a non induced subgraph, meaning the second graph</span>
<span class="sd">    can have fewer edges than the subgraph of the first. By default it&#39;s `True`. A</span>
<span class="sd">    simple example that checks if they&#39;re just equal would be::</span>

<span class="sd">            graph_a = rustworkx.PyGraph()</span>
<span class="sd">            graph_b = rustworkx.PyGraph()</span>
<span class="sd">            rustworkx.is_subgraph_isomorphic(graph_a, graph_b,</span>
<span class="sd">                                            lambda x, y: x == y)</span>


<span class="sd">    :param first: The first graph to compare. Can either be a</span>
<span class="sd">        :class:`~rustworkx.PyGraph` or :class:`~rustworkx.PyDiGraph`.</span>
<span class="sd">    :param second: The second graph to compare. Can either be a</span>
<span class="sd">        :class:`~rustworkx.PyGraph` or :class:`~rustworkx.PyDiGraph`.</span>
<span class="sd">        It should be the same type as the first graph.</span>
<span class="sd">    :param callable node_matcher: A python callable object that takes 2</span>
<span class="sd">        positional one for each node data object. If the return of this</span>
<span class="sd">        function evaluates to True then the nodes passed to it are viewed</span>
<span class="sd">        as matching.</span>
<span class="sd">    :param callable edge_matcher: A python callable object that takes 2</span>
<span class="sd">        positional one for each edge data object. If the return of this</span>
<span class="sd">        function evaluates to True then the edges passed to it are viewed</span>
<span class="sd">        as matching.</span>
<span class="sd">    :param bool id_order: If set to ``True`` this function will match the nodes</span>
<span class="sd">        in order specified by their ids. Otherwise it will default to a heuristic</span>
<span class="sd">        matching order based on [VF2]_ paper.</span>
<span class="sd">    :param bool induced: If set to ``True`` this function will check the existence</span>
<span class="sd">        of a node-induced subgraph of first isomorphic to second graph.</span>
<span class="sd">        Default: ``True``.</span>
<span class="sd">    :param int call_limit: An optional bound on the number of states that VF2</span>
<span class="sd">        algorithm visits while searching for a solution. If it exceeds this limit,</span>
<span class="sd">        the algorithm will stop and return ``False``.</span>

<span class="sd">    :returns: ``True`` if there is a subgraph of `first` isomorphic to `second`</span>
<span class="sd">        , ``False`` if there is not.</span>
<span class="sd">    :rtype: bool</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Invalid Input Type </span><span class="si">%s</span><span class="s2"> for graph&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">first</span><span class="p">))</span></div>


<span class="n">is_subgraph_isomorphic</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">PyDiGraph</span><span class="p">,</span> <span class="n">digraph_is_subgraph_isomorphic</span><span class="p">)</span>
<span class="n">is_subgraph_isomorphic</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">PyGraph</span><span class="p">,</span> <span class="n">graph_is_subgraph_isomorphic</span><span class="p">)</span>


<div class="viewcode-block" id="transitivity"><a class="viewcode-back" href="../apiref/rustworkx.transitivity.html#rustworkx.transitivity">[docs]</a><span class="nd">@functools</span><span class="o">.</span><span class="n">singledispatch</span>
<span class="k">def</span> <span class="nf">transitivity</span><span class="p">(</span><span class="n">graph</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute the transitivity of a graph.</span>

<span class="sd">    This function is multithreaded and will run</span>
<span class="sd">    launch a thread pool with threads equal to the number of CPUs by default.</span>
<span class="sd">    You can tune the number of threads with the ``RAYON_NUM_THREADS``</span>
<span class="sd">    environment variable. For example, setting ``RAYON_NUM_THREADS=4`` would</span>
<span class="sd">    limit the thread pool to 4 threads.</span>

<span class="sd">    .. note::</span>

<span class="sd">        The function implicitly assumes that there are no parallel edges</span>
<span class="sd">        or self loops. It may produce incorrect/unexpected results if the</span>
<span class="sd">        input graph has self loops or parallel edges.</span>

<span class="sd">    :param graph: The graph to be used. Can either be a</span>
<span class="sd">        :class:`~rustworkx.PyGraph` or :class:`~rustworkx.PyDiGraph`.</span>

<span class="sd">    :returns: Transitivity of the graph.</span>
<span class="sd">    :rtype: float</span>
<span class="sd">        raise TypeError(&quot;Invalid Input Type %s for graph&quot; % type(graph))</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Invalid Input Type </span><span class="si">%s</span><span class="s2"> for graph&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">graph</span><span class="p">))</span></div>


<span class="n">transitivity</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">PyDiGraph</span><span class="p">,</span> <span class="n">digraph_transitivity</span><span class="p">)</span>
<span class="n">transitivity</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">PyGraph</span><span class="p">,</span> <span class="n">graph_transitivity</span><span class="p">)</span>


<div class="viewcode-block" id="core_number"><a class="viewcode-back" href="../apiref/rustworkx.core_number.html#rustworkx.core_number">[docs]</a><span class="nd">@functools</span><span class="o">.</span><span class="n">singledispatch</span>
<span class="k">def</span> <span class="nf">core_number</span><span class="p">(</span><span class="n">graph</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return the core number for each node in the graph.</span>

<span class="sd">    A k-core is a maximal subgraph that contains nodes of degree k or more.</span>

<span class="sd">    .. note::</span>

<span class="sd">        The function implicitly assumes that there are no parallel edges</span>
<span class="sd">        or self loops. It may produce incorrect/unexpected results if the</span>
<span class="sd">        input graph has self loops or parallel edges.</span>

<span class="sd">    :param graph: The graph to get core numbers. Can either be a</span>
<span class="sd">        :class:`~rustworkx.PyGraph` or :class:`~rustworkx.PyDiGraph`</span>

<span class="sd">    :returns: A dictionary keyed by node index to the core number</span>
<span class="sd">    :rtype: dict</span>
<span class="sd">        raise TypeError(&quot;Invalid Input Type %s for graph&quot; % type(graph))</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Invalid Input Type </span><span class="si">%s</span><span class="s2"> for graph&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">graph</span><span class="p">))</span></div>


<span class="n">core_number</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">PyDiGraph</span><span class="p">,</span> <span class="n">digraph_core_number</span><span class="p">)</span>
<span class="n">core_number</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">PyGraph</span><span class="p">,</span> <span class="n">graph_core_number</span><span class="p">)</span>


<div class="viewcode-block" id="complement"><a class="viewcode-back" href="../apiref/rustworkx.complement.html#rustworkx.complement">[docs]</a><span class="nd">@functools</span><span class="o">.</span><span class="n">singledispatch</span>
<span class="k">def</span> <span class="nf">complement</span><span class="p">(</span><span class="n">graph</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute the complement of a graph.</span>

<span class="sd">    :param graph: The graph to be used, can be either a</span>
<span class="sd">        :class:`~rustworkx.PyGraph` or :class:`~rustworkx.PyDiGraph`.</span>

<span class="sd">    :returns: The complement of the graph.</span>
<span class="sd">    :rtype: :class:`~rustworkx.PyGraph` or :class:`~rustworkx.PyDiGraph`</span>

<span class="sd">    .. note::</span>
<span class="sd">        Parallel edges and self-loops are never created,</span>
<span class="sd">        even if the ``multigraph`` is set to ``True``</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Invalid Input Type </span><span class="si">%s</span><span class="s2"> for graph&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">graph</span><span class="p">))</span></div>


<span class="n">complement</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">PyDiGraph</span><span class="p">,</span> <span class="n">digraph_complement</span><span class="p">)</span>
<span class="n">complement</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">PyGraph</span><span class="p">,</span> <span class="n">graph_complement</span><span class="p">)</span>


<div class="viewcode-block" id="random_layout"><a class="viewcode-back" href="../apiref/rustworkx.random_layout.html#rustworkx.random_layout">[docs]</a><span class="nd">@functools</span><span class="o">.</span><span class="n">singledispatch</span>
<span class="k">def</span> <span class="nf">random_layout</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Generate a random layout</span>

<span class="sd">    :param PyGraph graph: The graph to generate the layout for</span>
<span class="sd">    :param tuple center: An optional center position. This is a 2 tuple of two</span>
<span class="sd">        ``float`` values for the center position</span>
<span class="sd">    :param int seed: An optional seed to set for the random number generator.</span>

<span class="sd">    :returns: The random layout of the graph.</span>
<span class="sd">    :rtype: Pos2DMapping</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Invalid Input Type </span><span class="si">%s</span><span class="s2"> for graph&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">graph</span><span class="p">))</span></div>


<span class="n">random_layout</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">PyDiGraph</span><span class="p">,</span> <span class="n">digraph_random_layout</span><span class="p">)</span>
<span class="n">random_layout</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">PyGraph</span><span class="p">,</span> <span class="n">graph_random_layout</span><span class="p">)</span>


<div class="viewcode-block" id="spring_layout"><a class="viewcode-back" href="../apiref/rustworkx.spring_layout.html#rustworkx.spring_layout">[docs]</a><span class="nd">@functools</span><span class="o">.</span><span class="n">singledispatch</span>
<span class="k">def</span> <span class="nf">spring_layout</span><span class="p">(</span>
    <span class="n">graph</span><span class="p">,</span>
    <span class="n">pos</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">fixed</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">k</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">repulsive_exponent</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
    <span class="n">adaptive_cooling</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">num_iter</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span>
    <span class="n">tol</span><span class="o">=</span><span class="mf">1e-6</span><span class="p">,</span>
    <span class="n">weight_fn</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">default_weight</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">scale</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">center</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Position nodes using Fruchterman-Reingold force-directed algorithm.</span>

<span class="sd">    The algorithm simulates a force-directed representation of the network</span>
<span class="sd">    treating edges as springs holding nodes close, while treating nodes</span>
<span class="sd">    as repelling objects, sometimes called an anti-gravity force.</span>
<span class="sd">    Simulation continues until the positions are close to an equilibrium.</span>

<span class="sd">    :param graph: Graph to be used. Can either be a</span>
<span class="sd">        :class:`~rustworkx.PyGraph` or :class:`~rustworkx.PyDiGraph`.</span>
<span class="sd">    :param dict pos:</span>
<span class="sd">        Initial node positions as a dictionary with node ids as keys and values</span>
<span class="sd">        as a coordinate list. If ``None``, then use random initial positions.</span>
<span class="sd">        (``default=None``)</span>
<span class="sd">    :param set fixed: Nodes to keep fixed at initial position.</span>
<span class="sd">        Error raised if fixed specified and ``pos`` is not. (``default=None``)</span>
<span class="sd">    :param float  k:</span>
<span class="sd">        Optimal distance between nodes. If ``None`` the distance is set to</span>
<span class="sd">        :math:`\\frac{1}{\\sqrt{n}}` where :math:`n` is the number of nodes.</span>
<span class="sd">        Increase this value to move nodes farther apart. (``default=None``)</span>
<span class="sd">    :param int repulsive_exponent:</span>
<span class="sd">        Repulsive force exponent. (``default=2``)</span>
<span class="sd">    :param bool adaptive_cooling:</span>
<span class="sd">        Use an adaptive cooling scheme. If set to ``False``,</span>
<span class="sd">        a linear cooling scheme is used. (``default=True``)</span>
<span class="sd">    :param int num_iter:</span>
<span class="sd">        Maximum number of iterations. (``default=50``)</span>
<span class="sd">    :param float tol:</span>
<span class="sd">        Threshold for relative error in node position changes.</span>
<span class="sd">        The iteration stops if the error is below this threshold.</span>
<span class="sd">        (``default = 1e-6``)</span>
<span class="sd">    :param weight_fn: An optional weight function for an edge. It will accept</span>
<span class="sd">        a single argument, the edge&#39;s weight object and will return a float</span>
<span class="sd">        which will be used to represent the weight of the edge.</span>
<span class="sd">    :param float (default=1) default_weight: If ``weight_fn`` isn&#39;t specified</span>
<span class="sd">        this optional float value will be used for the weight/cost of each edge</span>
<span class="sd">    :param float|None scale: Scale factor for positions.</span>
<span class="sd">        Not used unless fixed is None. If scale is ``None``, no re-scaling is</span>
<span class="sd">        performed. (``default=1.0``)</span>
<span class="sd">    :param list center: Coordinate pair around which to center</span>
<span class="sd">        the layout. Not used unless fixed is ``None``. (``default=None``)</span>
<span class="sd">    :param int seed: An optional seed to use for the random number generator</span>

<span class="sd">    :returns: A dictionary of positions keyed by node id.</span>
<span class="sd">    :rtype: dict</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Invalid Input Type </span><span class="si">%s</span><span class="s2"> for graph&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">graph</span><span class="p">))</span></div>


<span class="n">spring_layout</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">PyDiGraph</span><span class="p">,</span> <span class="n">digraph_spring_layout</span><span class="p">)</span>
<span class="n">spring_layout</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">PyGraph</span><span class="p">,</span> <span class="n">graph_spring_layout</span><span class="p">)</span>


<div class="viewcode-block" id="networkx_converter"><a class="viewcode-back" href="../apiref/rustworkx.networkx_converter.html#rustworkx.networkx_converter">[docs]</a><span class="k">def</span> <span class="nf">networkx_converter</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">keep_attributes</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Convert a networkx graph object into a rustworkx graph object.</span>

<span class="sd">    .. note::</span>

<span class="sd">        networkx is **not** a dependency of rustworkx and this function</span>
<span class="sd">        is provided as a convenience method for users of both networkx and</span>
<span class="sd">        rustworkx. This function will not work unless you install networkx</span>
<span class="sd">        independently.</span>

<span class="sd">    :param networkx.Graph graph: The networkx graph to convert.</span>
<span class="sd">    :param bool keep_attributes: If ``True``, add networkx node attributes to</span>
<span class="sd">        the data payload in the nodes of the output rustworkx graph. When set to</span>
<span class="sd">        ``True``, the node data payloads in the output rustworkx graph object</span>
<span class="sd">        will be dictionaries with the node attributes from the input networkx</span>
<span class="sd">        graph where the ``&quot;__networkx_node__&quot;`` key contains the node from the</span>
<span class="sd">        input networkx graph.</span>

<span class="sd">    :returns: A rustworkx graph, either a :class:`~rustworkx.PyDiGraph` or a</span>
<span class="sd">        :class:`~rustworkx.PyGraph` based on whether the input graph is directed</span>
<span class="sd">        or not.</span>
<span class="sd">    :rtype: :class:`~rustworkx.PyDiGraph` or :class:`~rustworkx.PyGraph`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">graph</span><span class="o">.</span><span class="n">is_directed</span><span class="p">():</span>
        <span class="n">new_graph</span> <span class="o">=</span> <span class="n">PyDiGraph</span><span class="p">(</span><span class="n">multigraph</span><span class="o">=</span><span class="n">graph</span><span class="o">.</span><span class="n">is_multigraph</span><span class="p">())</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">new_graph</span> <span class="o">=</span> <span class="n">PyGraph</span><span class="p">(</span><span class="n">multigraph</span><span class="o">=</span><span class="n">graph</span><span class="o">.</span><span class="n">is_multigraph</span><span class="p">())</span>
    <span class="n">nodes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span>
    <span class="n">node_indices</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span> <span class="n">new_graph</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">(</span><span class="n">nodes</span><span class="p">)))</span>
    <span class="n">new_graph</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">(</span>
        <span class="p">[(</span><span class="n">node_indices</span><span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">node_indices</span><span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="kc">True</span><span class="p">)]</span>
    <span class="p">)</span>

    <span class="k">if</span> <span class="n">keep_attributes</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">node</span><span class="p">,</span> <span class="n">node_index</span> <span class="ow">in</span> <span class="n">node_indices</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">attributes</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node</span><span class="p">]</span>
            <span class="n">attributes</span><span class="p">[</span><span class="s2">&quot;__networkx_node__&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">node</span>
            <span class="n">new_graph</span><span class="p">[</span><span class="n">node_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">attributes</span>

    <span class="k">return</span> <span class="n">new_graph</span></div>


<div class="viewcode-block" id="bipartite_layout"><a class="viewcode-back" href="../apiref/rustworkx.bipartite_layout.html#rustworkx.bipartite_layout">[docs]</a><span class="nd">@functools</span><span class="o">.</span><span class="n">singledispatch</span>
<span class="k">def</span> <span class="nf">bipartite_layout</span><span class="p">(</span>
    <span class="n">graph</span><span class="p">,</span>
    <span class="n">first_nodes</span><span class="p">,</span>
    <span class="n">horizontal</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">scale</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">center</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">aspect_ratio</span><span class="o">=</span><span class="mi">4</span> <span class="o">/</span> <span class="mi">3</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Generate a bipartite layout of the graph</span>

<span class="sd">    :param graph: The graph to generate the layout for. Can either be a</span>
<span class="sd">        :class:`~rustworkx.PyGraph` or :class:`~rustworkx.PyDiGraph`</span>
<span class="sd">    :param set first_nodes: The set of node indices on the left (or top if</span>
<span class="sd">        horitontal is true)</span>
<span class="sd">    :param bool horizontal: An optional bool specifying the orientation of the</span>
<span class="sd">        layout</span>
<span class="sd">    :param float scale: An optional scaling factor to scale positions</span>
<span class="sd">    :param tuple center: An optional center position. This is a 2 tuple of two</span>
<span class="sd">        ``float`` values for the center position</span>
<span class="sd">    :param float aspect_ratio: An optional number for the ratio of the width to</span>
<span class="sd">        the height of the layout.</span>

<span class="sd">    :returns: The bipartite layout of the graph.</span>
<span class="sd">    :rtype: Pos2DMapping</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Invalid Input Type </span><span class="si">%s</span><span class="s2"> for graph&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">graph</span><span class="p">))</span></div>


<span class="n">bipartite_layout</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">PyDiGraph</span><span class="p">,</span> <span class="n">digraph_bipartite_layout</span><span class="p">)</span>
<span class="n">bipartite_layout</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">PyGraph</span><span class="p">,</span> <span class="n">graph_bipartite_layout</span><span class="p">)</span>


<div class="viewcode-block" id="circular_layout"><a class="viewcode-back" href="../apiref/rustworkx.circular_layout.html#rustworkx.circular_layout">[docs]</a><span class="nd">@functools</span><span class="o">.</span><span class="n">singledispatch</span>
<span class="k">def</span> <span class="nf">circular_layout</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Generate a circular layout of the graph</span>

<span class="sd">    :param graph: The graph to generate the layout for. Can either be a</span>
<span class="sd">        :class:`~rustworkx.PyGraph` or :class:`~rustworkx.PyDiGraph`</span>
<span class="sd">    :param float scale: An optional scaling factor to scale positions</span>
<span class="sd">    :param tuple center: An optional center position. This is a 2 tuple of two</span>
<span class="sd">        ``float`` values for the center position</span>

<span class="sd">    :returns: The circular layout of the graph.</span>
<span class="sd">    :rtype: Pos2DMapping</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Invalid Input Type </span><span class="si">%s</span><span class="s2"> for graph&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">graph</span><span class="p">))</span></div>


<span class="n">circular_layout</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">PyDiGraph</span><span class="p">,</span> <span class="n">digraph_circular_layout</span><span class="p">)</span>
<span class="n">circular_layout</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">PyGraph</span><span class="p">,</span> <span class="n">graph_circular_layout</span><span class="p">)</span>


<div class="viewcode-block" id="shell_layout"><a class="viewcode-back" href="../apiref/rustworkx.shell_layout.html#rustworkx.shell_layout">[docs]</a><span class="nd">@functools</span><span class="o">.</span><span class="n">singledispatch</span>
<span class="k">def</span> <span class="nf">shell_layout</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">nlist</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">rotate</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate a shell layout of the graph</span>

<span class="sd">    :param graph: The graph to generate the layout for. Can either be a</span>
<span class="sd">        :class:`~rustworkx.PyGraph` or :class:`~rustworkx.PyDiGraph`</span>
<span class="sd">    :param list nlist: The list of lists of indices which represents each shell</span>
<span class="sd">    :param float rotate: Angle (in radians) by which to rotate the starting</span>
<span class="sd">        position of each shell relative to the starting position of the</span>
<span class="sd">        previous shell</span>
<span class="sd">    :param float scale: An optional scaling factor to scale positions</span>
<span class="sd">    :param tuple center: An optional center position. This is a 2 tuple of two</span>
<span class="sd">        ``float`` values for the center position</span>

<span class="sd">    :returns: The shell layout of the graph.</span>
<span class="sd">    :rtype: Pos2DMapping</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Invalid Input Type </span><span class="si">%s</span><span class="s2"> for graph&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">graph</span><span class="p">))</span></div>


<span class="n">shell_layout</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">PyDiGraph</span><span class="p">,</span> <span class="n">digraph_shell_layout</span><span class="p">)</span>
<span class="n">shell_layout</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">PyGraph</span><span class="p">,</span> <span class="n">graph_shell_layout</span><span class="p">)</span>


<div class="viewcode-block" id="spiral_layout"><a class="viewcode-back" href="../apiref/rustworkx.spiral_layout.html#rustworkx.spiral_layout">[docs]</a><span class="nd">@functools</span><span class="o">.</span><span class="n">singledispatch</span>
<span class="k">def</span> <span class="nf">spiral_layout</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">resolution</span><span class="o">=</span><span class="mf">0.35</span><span class="p">,</span> <span class="n">equidistant</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate a spiral layout of the graph</span>

<span class="sd">    :param graph: The graph to generate the layout for. Can either be a</span>
<span class="sd">        :class:`~rustworkx.PyGraph` or :class:`~rustworkx.PyDiGraph`</span>
<span class="sd">    :param float scale: An optional scaling factor to scale positions</span>
<span class="sd">    :param tuple center: An optional center position. This is a 2 tuple of two</span>
<span class="sd">        ``float`` values for the center position</span>
<span class="sd">    :param float resolution: The compactness of the spiral layout returned.</span>
<span class="sd">        Lower values result in more compressed spiral layouts.</span>
<span class="sd">    :param bool equidistant: If true, nodes will be plotted equidistant from</span>
<span class="sd">        each other.</span>

<span class="sd">    :returns: The spiral layout of the graph.</span>
<span class="sd">    :rtype: Pos2DMapping</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Invalid Input Type </span><span class="si">%s</span><span class="s2"> for graph&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">graph</span><span class="p">))</span></div>


<span class="n">spiral_layout</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">PyDiGraph</span><span class="p">,</span> <span class="n">digraph_spiral_layout</span><span class="p">)</span>
<span class="n">spiral_layout</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">PyGraph</span><span class="p">,</span> <span class="n">graph_spiral_layout</span><span class="p">)</span>


<div class="viewcode-block" id="num_shortest_paths_unweighted"><a class="viewcode-back" href="../apiref/rustworkx.num_shortest_paths_unweighted.html#rustworkx.num_shortest_paths_unweighted">[docs]</a><span class="nd">@functools</span><span class="o">.</span><span class="n">singledispatch</span>
<span class="k">def</span> <span class="nf">num_shortest_paths_unweighted</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">source</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Get the number of unweighted shortest paths from a source node</span>

<span class="sd">    :param PyDiGraph graph: The graph to find the number of shortest paths on</span>
<span class="sd">    :param int source: The source node to find the shortest paths from</span>

<span class="sd">    :returns: A mapping of target node indices to the number of shortest paths</span>
<span class="sd">        from ``source`` to that node. If there is no path from ``source`` to</span>
<span class="sd">        a node in the graph that node will not be preset in the output mapping.</span>
<span class="sd">    :rtype: NodesCountMapping</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Invalid input type </span><span class="si">%s</span><span class="s2"> for graph&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">graph</span><span class="p">))</span></div>


<span class="n">num_shortest_paths_unweighted</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">PyDiGraph</span><span class="p">,</span> <span class="n">digraph_num_shortest_paths_unweighted</span><span class="p">)</span>
<span class="n">num_shortest_paths_unweighted</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">PyGraph</span><span class="p">,</span> <span class="n">graph_num_shortest_paths_unweighted</span><span class="p">)</span>


<div class="viewcode-block" id="betweenness_centrality"><a class="viewcode-back" href="../apiref/rustworkx.betweenness_centrality.html#rustworkx.betweenness_centrality">[docs]</a><span class="nd">@functools</span><span class="o">.</span><span class="n">singledispatch</span>
<span class="k">def</span> <span class="nf">betweenness_centrality</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">normalized</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">endpoints</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">parallel_threshold</span><span class="o">=</span><span class="mi">50</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Returns the betweenness centrality of each node in the graph.</span>

<span class="sd">    Betweenness centrality of a node :math:`v` is the sum of the</span>
<span class="sd">    fraction of all-pairs shortest paths that pass through :math`v`</span>

<span class="sd">    .. math::</span>

<span class="sd">       c_B(v) =\sum_{s,t \in V} \frac{\sigma(s, t|v)}{\sigma(s, t)}</span>

<span class="sd">    where :math:`V` is the set of nodes, :math:`\sigma(s, t)` is the number of</span>
<span class="sd">    shortest :math`(s, t)` paths, and :math:`\sigma(s, t|v)` is the number of</span>
<span class="sd">    those paths  passing through some  node :math:`v` other than :math:`s, t`.</span>
<span class="sd">    If :math:`s = t`, :math:`\sigma(s, t) = 1`, and if :math:`v \in {s, t}`,</span>
<span class="sd">    :math:`\sigma(s, t|v) = 0`</span>

<span class="sd">    The algorithm used in this function is based on:</span>

<span class="sd">    Ulrik Brandes, A Faster Algorithm for Betweenness Centrality.</span>
<span class="sd">    Journal of Mathematical Sociology 25(2):163-177, 2001.</span>

<span class="sd">    This function is multithreaded and will run in parallel if the number</span>
<span class="sd">    of nodes in the graph is above the value of ``parallel_threshold`` (it</span>
<span class="sd">    defaults to 50). If the function will be running in parallel the env var</span>
<span class="sd">    ``RAYON_NUM_THREADS`` can be used to adjust how many threads will be used.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    edge_betweenness_centrality</span>

<span class="sd">    :param PyDiGraph graph: The input graph</span>
<span class="sd">    :param bool normalized: Whether to normalize the betweenness scores by</span>
<span class="sd">        the number of distinct paths between all pairs of nodes.</span>
<span class="sd">    :param bool endpoints: Whether to include the endpoints of paths in</span>
<span class="sd">        path lengths used to compute the betweenness.</span>
<span class="sd">    :param int parallel_threshold: The number of nodes to calculate the</span>
<span class="sd">        the betweenness centrality in parallel at if the number of nodes in</span>
<span class="sd">        the graph is less than this value it will run in a single thread. The</span>
<span class="sd">        default value is 50</span>

<span class="sd">    :returns: A dictionary mapping each node index to its betweenness centrality.</span>
<span class="sd">    :rtype: dict</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Invalid input type </span><span class="si">%s</span><span class="s2"> for graph&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">graph</span><span class="p">))</span></div>


<span class="n">betweenness_centrality</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">PyDiGraph</span><span class="p">,</span> <span class="n">digraph_betweenness_centrality</span><span class="p">)</span>
<span class="n">betweenness_centrality</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">PyGraph</span><span class="p">,</span> <span class="n">graph_betweenness_centrality</span><span class="p">)</span>


<div class="viewcode-block" id="closeness_centrality"><a class="viewcode-back" href="../apiref/rustworkx.closeness_centrality.html#rustworkx.closeness_centrality">[docs]</a><span class="nd">@functools</span><span class="o">.</span><span class="n">singledispatch</span>
<span class="k">def</span> <span class="nf">closeness_centrality</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">wf_improved</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Compute the closeness centrality of each node in a graph object.</span>

<span class="sd">    The closeness centrality of a node :math:`u` is defined as the</span>
<span class="sd">    reciprocal of the average shortest path distance to :math:`u` over all</span>
<span class="sd">    :math:`n-1` reachable nodes in the graph. In it&#39;s general form this can</span>
<span class="sd">    be expressed as:</span>

<span class="sd">    .. math::</span>

<span class="sd">        C(u) = \frac{n - 1}{\sum_{v=1}^{n-1} d(v, u)},</span>

<span class="sd">    where:</span>

<span class="sd">      * :math:`d(v, u)` - the shortest-path distance between :math:`v` and</span>
<span class="sd">        :math:`u`</span>
<span class="sd">      * :math:`n` - the number of nodes that can reach :math:`u`.</span>

<span class="sd">    In the case of a graphs with more than one connected component there is</span>
<span class="sd">    an alternative improved formula that calculates the closeness centrality</span>
<span class="sd">    as &quot;a ratio of the fraction of actors in the group who are reachable, to</span>
<span class="sd">    the average distance&quot; [WF]_. This can be expressed as</span>

<span class="sd">    .. math::</span>

<span class="sd">        C_{WF}(u) = \frac{n-1}{N-1} \frac{n - 1}{\sum_{v=1}^{n-1} d(v, u)},</span>

<span class="sd">    where :math:`N` is the number of nodes in the graph. This alternative</span>
<span class="sd">    formula can be used with the ``wf_improved`` argument.</span>

<span class="sd">    :param graph: The input graph. Can either be a</span>
<span class="sd">        :class:`~retworkx.PyGraph` or :class:`~retworkx.PyDiGraph`.</span>
<span class="sd">    :param bool wf_improved: This is optional; the default is True. If True,</span>
<span class="sd">        scale by the fraction of nodes reachable.</span>

<span class="sd">    :returns: A dictionary mapping each node index to its closeness centrality.</span>
<span class="sd">    :rtype: dict</span>

<span class="sd">    .. [WF] Wasserman, S., &amp; Faust, K. (1994). Social Network Analysis:</span>
<span class="sd">      Methods and Applications (Structural Analysis in the Social Sciences).</span>
<span class="sd">      Cambridge: Cambridge University Press. doi:10.1017/CBO9780511815478</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Invalid input type </span><span class="si">%s</span><span class="s2"> for graph&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">graph</span><span class="p">))</span></div>


<span class="n">closeness_centrality</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">PyDiGraph</span><span class="p">,</span> <span class="n">digraph_closeness_centrality</span><span class="p">)</span>
<span class="n">closeness_centrality</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">PyGraph</span><span class="p">,</span> <span class="n">graph_closeness_centrality</span><span class="p">)</span>


<div class="viewcode-block" id="edge_betweenness_centrality"><a class="viewcode-back" href="../apiref/rustworkx.edge_betweenness_centrality.html#rustworkx.edge_betweenness_centrality">[docs]</a><span class="nd">@functools</span><span class="o">.</span><span class="n">singledispatch</span>
<span class="k">def</span> <span class="nf">edge_betweenness_centrality</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">normalized</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">parallel_threshold</span><span class="o">=</span><span class="mi">50</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Compute the edge betweenness centrality of all edges in a graph.</span>

<span class="sd">    Edge betweenness centrality of an edge :math:`e` is the sum of the</span>
<span class="sd">    fraction of all-pairs shortest paths that pass through :math`e`</span>

<span class="sd">    .. math::</span>

<span class="sd">       c_B(e) = \sum_{s,t \in V} \frac{\sigma(s, t|e)}{\sigma(s, t)}</span>

<span class="sd">    where :math:`V` is the set of nodes, :math:`\sigma(s, t)` is the</span>
<span class="sd">    number of shortest :math:`(s, t)`-paths, and :math:`\sigma(s, t|e)` is</span>
<span class="sd">    the number of those paths passing through edge :math:`e`.</span>

<span class="sd">    The above definition and the algorithm used in this function is based on:</span>

<span class="sd">    Ulrik Brandes, On Variants of Shortest-Path Betweenness Centrality</span>
<span class="sd">    and their Generic Computation. Social Networks 30(2):136-145, 2008.</span>

<span class="sd">    This function is multithreaded and will run in parallel if the number</span>
<span class="sd">    of nodes in the graph is above the value of ``parallel_threshold`` (it</span>
<span class="sd">    defaults to 50). If the function will be running in parallel the env var</span>
<span class="sd">    ``RAYON_NUM_THREADS`` can be used to adjust how many threads will be used.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    betweenness_centrality</span>

<span class="sd">    :param PyGraph graph: The input graph</span>
<span class="sd">    :param bool normalized: Whether to normalize the betweenness scores by the</span>
<span class="sd">        number of distinct paths between all pairs of nodes.</span>
<span class="sd">    :param int parallel_threshold: The number of nodes to calculate</span>
<span class="sd">        the edge betweenness centrality in parallel at if the number of nodes in</span>
<span class="sd">        the graph is less than this value it will run in a single thread. The</span>
<span class="sd">        default value is 50</span>

<span class="sd">    :returns: a read-only dict-like object whose keys are edges and values are the</span>
<span class="sd">        betweenness score for each node.</span>
<span class="sd">    :rtype: EdgeCentralityMapping</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Invalid input type </span><span class="si">%s</span><span class="s2"> for graph&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">graph</span><span class="p">))</span></div>


<span class="n">edge_betweenness_centrality</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">PyDiGraph</span><span class="p">,</span> <span class="n">digraph_edge_betweenness_centrality</span><span class="p">)</span>
<span class="n">edge_betweenness_centrality</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">PyGraph</span><span class="p">,</span> <span class="n">graph_edge_betweenness_centrality</span><span class="p">)</span>


<div class="viewcode-block" id="eigenvector_centrality"><a class="viewcode-back" href="../apiref/rustworkx.eigenvector_centrality.html#rustworkx.eigenvector_centrality">[docs]</a><span class="nd">@functools</span><span class="o">.</span><span class="n">singledispatch</span>
<span class="k">def</span> <span class="nf">eigenvector_centrality</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">weight_fn</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">default_weight</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">max_iter</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">1e-6</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute the eigenvector centrality of a graph.</span>

<span class="sd">    For details on the eigenvector centrality refer to:</span>

<span class="sd">    Phillip Bonacich. “Power and Centrality: A Family of Measures.”</span>
<span class="sd">    American Journal of Sociology 92(5):1170–1182, 1986</span>
<span class="sd">    &lt;https://doi.org/10.1086/228631&gt;</span>

<span class="sd">    This function uses a power iteration method to compute the eigenvector</span>
<span class="sd">    and convergence is not guaranteed. The function will stop when `max_iter`</span>
<span class="sd">    iterations is reached or when the computed vector between two iterations</span>
<span class="sd">    is smaller than the error tolerance multiplied by the number of nodes.</span>
<span class="sd">    The implementation of this algorithm is based on the NetworkX</span>
<span class="sd">    `eigenvector_centrality() &lt;https://networkx.org/documentation/stable/reference/algorithms/generated/networkx.algorithms.centrality.eigenvector_centrality.html&gt;`__</span>
<span class="sd">    function.</span>

<span class="sd">    In the case of multigraphs the weights of any parallel edges will be</span>
<span class="sd">    summed when computing the eigenvector centrality.</span>

<span class="sd">    :param graph: Graph to be used. Can either be a</span>
<span class="sd">        :class:`~rustworkx.PyGraph` or :class:`~rustworkx.PyDiGraph`.</span>
<span class="sd">    :param weight_fn: An optional input callable that will be passed the edge&#39;s</span>
<span class="sd">        payload object and is expected to return a `float` weight for that edge.</span>
<span class="sd">        If this is not specified ``default_weight`` will be used as the weight</span>
<span class="sd">        for every edge in ``graph``</span>
<span class="sd">    :param float default_weight: If ``weight_fn`` is not set the default weight</span>
<span class="sd">        value to use for the weight of all edges</span>
<span class="sd">    :param int max_iter: The maximum number of iterations in the power method. If</span>
<span class="sd">        not specified a default value of 100 is used.</span>
<span class="sd">    :param float tol: The error tolerance used when checking for convergence in the</span>
<span class="sd">        power method. If this is not specified default value of 1e-6 is used.</span>

<span class="sd">    :returns: a read-only dict-like object whose keys are the node indices and values are the</span>
<span class="sd">         centrality score for that node.</span>
<span class="sd">    :rtype: CentralityMapping</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Invalid input type </span><span class="si">%s</span><span class="s2"> for graph&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">graph</span><span class="p">))</span></div>


<span class="n">eigenvector_centrality</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">PyDiGraph</span><span class="p">,</span> <span class="n">digraph_eigenvector_centrality</span><span class="p">)</span>
<span class="n">eigenvector_centrality</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">PyGraph</span><span class="p">,</span> <span class="n">graph_eigenvector_centrality</span><span class="p">)</span>


<div class="viewcode-block" id="katz_centrality"><a class="viewcode-back" href="../apiref/rustworkx.katz_centrality.html#rustworkx.katz_centrality">[docs]</a><span class="nd">@functools</span><span class="o">.</span><span class="n">singledispatch</span>
<span class="k">def</span> <span class="nf">katz_centrality</span><span class="p">(</span>
    <span class="n">graph</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">beta</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">weight_fn</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">default_weight</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">max_iter</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">1e-6</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute the Katz centrality of a graph.</span>

<span class="sd">    For details on the Katz centrality refer to:</span>

<span class="sd">    Leo Katz. “A New Status Index Derived from Sociometric Index.”</span>
<span class="sd">    Psychometrika 18(1):39–43, 1953</span>
<span class="sd">    &lt;https://link.springer.com/content/pdf/10.1007/BF02289026.pdf&gt;</span>

<span class="sd">    This function uses a power iteration method to compute the eigenvector</span>
<span class="sd">    and convergence is not guaranteed. The function will stop when `max_iter`</span>
<span class="sd">    iterations is reached or when the computed vector between two iterations</span>
<span class="sd">    is smaller than the error tolerance multiplied by the number of nodes.</span>
<span class="sd">    The implementation of this algorithm is based on the NetworkX</span>
<span class="sd">    `katz_centrality() &lt;https://networkx.org/documentation/stable/reference/algorithms/generated/networkx.algorithms.centrality.katz_centrality.html&gt;`__</span>
<span class="sd">    function.</span>

<span class="sd">    In the case of multigraphs the weights of any parallel edges will be</span>
<span class="sd">    summed when computing the Katz centrality.</span>

<span class="sd">    :param graph: Graph to be used. Can either be a</span>
<span class="sd">        :class:`~rustworkx.PyGraph` or :class:`~rustworkx.PyDiGraph`.</span>
<span class="sd">    :param float alpha: Attenuation factor. If this is not specified default value of 0.1 is used.</span>
<span class="sd">    :param float | dict beta: Immediate neighbourhood weights. If a float is provided, the neighbourhood</span>
<span class="sd">        weight is used for all nodes. If a dictionary is provided, it must contain all node indices.</span>
<span class="sd">        If beta is not specified, a default value of 1.0 is used.</span>
<span class="sd">    :param weight_fn: An optional input callable that will be passed the edge&#39;s</span>
<span class="sd">        payload object and is expected to return a `float` weight for that edge.</span>
<span class="sd">        If this is not specified ``default_weight`` will be used as the weight</span>
<span class="sd">        for every edge in ``graph``</span>
<span class="sd">    :param float default_weight: If ``weight_fn`` is not set the default weight</span>
<span class="sd">        value to use for the weight of all edges</span>
<span class="sd">    :param int max_iter: The maximum number of iterations in the power method. If</span>
<span class="sd">        not specified a default value of 100 is used.</span>
<span class="sd">    :param float tol: The error tolerance used when checking for convergence in the</span>
<span class="sd">        power method. If this is not specified default value of 1e-6 is used.</span>

<span class="sd">    :returns: a read-only dict-like object whose keys are the node indices and values are the</span>
<span class="sd">         centrality score for that node.</span>
<span class="sd">    :rtype: CentralityMapping</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Invalid input type </span><span class="si">%s</span><span class="s2"> for graph&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">graph</span><span class="p">))</span></div>


<span class="n">katz_centrality</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">PyDiGraph</span><span class="p">,</span> <span class="n">digraph_katz_centrality</span><span class="p">)</span>
<span class="n">katz_centrality</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">PyGraph</span><span class="p">,</span> <span class="n">graph_katz_centrality</span><span class="p">)</span>


<div class="viewcode-block" id="vf2_mapping"><a class="viewcode-back" href="../apiref/rustworkx.vf2_mapping.html#rustworkx.vf2_mapping">[docs]</a><span class="nd">@functools</span><span class="o">.</span><span class="n">singledispatch</span>
<span class="k">def</span> <span class="nf">vf2_mapping</span><span class="p">(</span>
    <span class="n">first</span><span class="p">,</span>
    <span class="n">second</span><span class="p">,</span>
    <span class="n">node_matcher</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">edge_matcher</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">id_order</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">subgraph</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">induced</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">call_limit</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return an iterator over all vf2 mappings between two graphs.</span>

<span class="sd">    This funcion will run the vf2 algorithm used from</span>
<span class="sd">    :func:`~rustworkx.is_isomorphic` and :func:`~rustworkx.is_subgraph_isomorphic`</span>
<span class="sd">    but instead of returning a boolean it will return an iterator over all possible</span>
<span class="sd">    mapping of node ids found from ``first`` to ``second``. If the graphs are not</span>
<span class="sd">    isomorphic then the iterator will be empty. A simple example that retrieves</span>
<span class="sd">    one mapping would be::</span>

<span class="sd">            graph_a = rustworkx.generators.path_graph(3)</span>
<span class="sd">            graph_b = rustworkx.generators.path_graph(2)</span>
<span class="sd">            vf2 = rustworkx.vf2_mapping(graph_a, graph_b, subgraph=True)</span>
<span class="sd">            try:</span>
<span class="sd">                mapping = next(vf2)</span>
<span class="sd">            except StopIteration:</span>
<span class="sd">                pass</span>

<span class="sd">    :param first: The first graph to find the mapping for</span>
<span class="sd">    :param second: The second graph to find the mapping for</span>
<span class="sd">    :param node_matcher: An optional python callable object that takes 2</span>
<span class="sd">        positional arguments, one for each node data object in either graph.</span>
<span class="sd">        If the return of this function evaluates to True then the nodes</span>
<span class="sd">        passed to it are viewed as matching.</span>
<span class="sd">    :param edge_matcher: A python callable object that takes 2 positional</span>
<span class="sd">        one for each edge data object. If the return of this</span>
<span class="sd">        function evaluates to True then the edges passed to it are viewed</span>
<span class="sd">        as matching.</span>
<span class="sd">    :param bool id_order: If set to ``False`` this function will use a</span>
<span class="sd">        heuristic matching order based on [VF2]_ paper. Otherwise it will</span>
<span class="sd">        default to matching the nodes in order specified by their ids.</span>
<span class="sd">    :param bool subgraph: If set to ``True`` the function will return the</span>
<span class="sd">        subgraph isomorphic found between the graphs.</span>
<span class="sd">    :param bool induced: If set to ``True`` this function will check the existence</span>
<span class="sd">        of a node-induced subgraph of first isomorphic to second graph.</span>
<span class="sd">        Default: ``True``.</span>
<span class="sd">    :param int call_limit: An optional bound on the number of states that VF2</span>
<span class="sd">        algorithm visits while searching for a solution. If it exceeds this limit,</span>
<span class="sd">        the algorithm will stop. Default: ``None``.</span>

<span class="sd">    :returns: An iterator over dicitonaries of node indices from ``first`` to node</span>
<span class="sd">        indices in ``second`` representing the mapping found.</span>
<span class="sd">    :rtype: Iterable[NodeMap]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Invalid Input Type </span><span class="si">%s</span><span class="s2"> for graph&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">first</span><span class="p">))</span></div>


<span class="n">vf2_mapping</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">PyDiGraph</span><span class="p">,</span> <span class="n">digraph_vf2_mapping</span><span class="p">)</span>
<span class="n">vf2_mapping</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">PyGraph</span><span class="p">,</span> <span class="n">graph_vf2_mapping</span><span class="p">)</span>


<div class="viewcode-block" id="union"><a class="viewcode-back" href="../apiref/rustworkx.union.html#rustworkx.union">[docs]</a><span class="nd">@functools</span><span class="o">.</span><span class="n">singledispatch</span>
<span class="k">def</span> <span class="nf">union</span><span class="p">(</span>
    <span class="n">first</span><span class="p">,</span>
    <span class="n">second</span><span class="p">,</span>
    <span class="n">merge_nodes</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">merge_edges</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return a new graph by forming a union from two input graph objects</span>

<span class="sd">    The algorithm in this function operates in three phases:</span>

<span class="sd">    1. Add all the nodes from  ``second`` into ``first``. operates in</span>
<span class="sd">    :math:`\\mathcal{O}(n_2)`, with :math:`n_2` being number of nodes in</span>
<span class="sd">    ``second``.</span>
<span class="sd">    2. Merge nodes from ``second`` over ``first`` given that:</span>

<span class="sd">       - The ``merge_nodes`` is ``True``. operates in :math:`\\mathcal{O}(n_1 n_2)`,</span>
<span class="sd">         with :math:`n_1` being the number of nodes in ``first`` and :math:`n_2`</span>
<span class="sd">         the number of nodes in ``second``</span>
<span class="sd">       - The respective node in ``second`` and ``first`` share the same</span>
<span class="sd">         weight/data payload.</span>

<span class="sd">    3. Adds all the edges from ``second`` to ``first``. If the ``merge_edges``</span>
<span class="sd">       parameter is ``True`` and the respective edge in ``second`` and</span>
<span class="sd">       ``first`` share the same weight/data payload they will be merged together.</span>

<span class="sd">    :param first: The first graph object</span>
<span class="sd">    :param second: The second graph object</span>
<span class="sd">    :param bool merge_nodes: If set to ``True`` nodes will be merged between</span>
<span class="sd">        ``second`` and ``first`` if the weights are equal. Default: ``False``.</span>
<span class="sd">    :param bool merge_edges: If set to ``True`` edges will be merged between</span>
<span class="sd">        ``second`` and ``first`` if the weights are equal. Default: ``False``.</span>

<span class="sd">    :returns: A new graph object that is the union of ``second`` and</span>
<span class="sd">        ``first``. It&#39;s worth noting the weight/data payload objects are</span>
<span class="sd">        passed by reference from ``first`` and ``second`` to this new object.</span>
<span class="sd">    :rtype: :class:`~rustworkx.PyGraph` or :class:`~rustworkx.PyDiGraph`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Invalid Input Type </span><span class="si">%s</span><span class="s2"> for graph&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">first</span><span class="p">))</span></div>


<span class="n">union</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">PyDiGraph</span><span class="p">,</span> <span class="n">digraph_union</span><span class="p">)</span>
<span class="n">union</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">PyGraph</span><span class="p">,</span> <span class="n">graph_union</span><span class="p">)</span>


<span class="nd">@functools</span><span class="o">.</span><span class="n">singledispatch</span>
<span class="k">def</span> <span class="nf">tensor_product</span><span class="p">(</span>
    <span class="n">first</span><span class="p">,</span>
    <span class="n">second</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return a new graph by forming the tensor product</span>
<span class="sd">    from two input graph objects</span>

<span class="sd">    :param first: The first graph object</span>
<span class="sd">    :param second: The second graph object</span>

<span class="sd">    :returns: A new graph object that is the tensor product of ``second`` and</span>
<span class="sd">        ``first``. It&#39;s worth noting the weight/data payload objects are</span>
<span class="sd">        passed by reference from ``first`` and ``second`` to this new object.</span>
<span class="sd">        A read-only dictionary of the product of nodes is also returned. The keys</span>
<span class="sd">        are a tuple where the first element is a node of the first graph and the</span>
<span class="sd">        second element is a node of the second graph, and the values are the map</span>
<span class="sd">        of those elements to node indices in the product graph. For example::</span>

<span class="sd">            {</span>
<span class="sd">                (0, 0): 0,</span>
<span class="sd">                (0, 1): 1,</span>
<span class="sd">            }</span>

<span class="sd">    :rtype: Tuple[:class:`~rustworkx.PyGraph` or :class:`~rustworkx.PyDiGraph`,</span>
<span class="sd">        :class:`~rustworkx.ProductNodeMap`]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Invalid Input Type </span><span class="si">%s</span><span class="s2"> for graph&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">first</span><span class="p">))</span>


<span class="n">tensor_product</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">PyDiGraph</span><span class="p">,</span> <span class="n">digraph_tensor_product</span><span class="p">)</span>
<span class="n">tensor_product</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">PyGraph</span><span class="p">,</span> <span class="n">graph_tensor_product</span><span class="p">)</span>


<div class="viewcode-block" id="cartesian_product"><a class="viewcode-back" href="../apiref/rustworkx.cartesian_product.html#rustworkx.cartesian_product">[docs]</a><span class="nd">@functools</span><span class="o">.</span><span class="n">singledispatch</span>
<span class="k">def</span> <span class="nf">cartesian_product</span><span class="p">(</span>
    <span class="n">first</span><span class="p">,</span>
    <span class="n">second</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return a new graph by forming the cartesian product</span>
<span class="sd">    from two input graph objects</span>

<span class="sd">    :param first: The first graph object</span>
<span class="sd">    :param second: The second graph object</span>

<span class="sd">    :returns: A new graph object that is the union of ``second`` and</span>
<span class="sd">        ``first``. It&#39;s worth noting the weight/data payload objects are</span>
<span class="sd">        passed by reference from ``first`` and ``second`` to this new object.</span>
<span class="sd">        A read-only dictionary of the product of nodes is also returned. The keys</span>
<span class="sd">        are a tuple where the first element is a node of the first graph and the</span>
<span class="sd">        second element is a node of the second graph, and the values are the map</span>
<span class="sd">        of those elements to node indices in the product graph. For example::</span>

<span class="sd">            {</span>
<span class="sd">                (0, 0): 0,</span>
<span class="sd">                (0, 1): 1,</span>
<span class="sd">            }</span>

<span class="sd">    :rtype: Tuple[:class:`~rustworkx.PyGraph` or :class:`~rustworkx.PyDiGraph`,</span>
<span class="sd">        :class:`~rustworkx.ProductNodeMap`]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Invalid Input Type </span><span class="si">%s</span><span class="s2"> for graph&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">first</span><span class="p">))</span></div>


<span class="n">cartesian_product</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">PyDiGraph</span><span class="p">,</span> <span class="n">digraph_cartesian_product</span><span class="p">)</span>
<span class="n">cartesian_product</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">PyGraph</span><span class="p">,</span> <span class="n">graph_cartesian_product</span><span class="p">)</span>


<div class="viewcode-block" id="bfs_search"><a class="viewcode-back" href="../apiref/rustworkx.bfs_search.html#rustworkx.bfs_search">[docs]</a><span class="nd">@functools</span><span class="o">.</span><span class="n">singledispatch</span>
<span class="k">def</span> <span class="nf">bfs_search</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">visitor</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Breadth-first traversal of a directed/undirected graph.</span>

<span class="sd">    The pseudo-code for the BFS algorithm is listed below, with the annotated</span>
<span class="sd">    event points, for which the given visitor object will be called with the</span>
<span class="sd">    appropriate method.</span>

<span class="sd">    ::</span>

<span class="sd">        BFS(G, s)</span>
<span class="sd">          for each vertex u in V</span>
<span class="sd">              color[u] := WHITE</span>
<span class="sd">          end for</span>
<span class="sd">          color[s] := GRAY</span>
<span class="sd">          EQUEUE(Q, s)                             discover vertex s</span>
<span class="sd">          while (Q != Ø)</span>
<span class="sd">              u := DEQUEUE(Q)</span>
<span class="sd">              for each vertex v in Adj[u]          (u,v) is a tree edge</span>
<span class="sd">                  if (color[v] = WHITE)</span>
<span class="sd">                      color[v] = GRAY</span>
<span class="sd">                  else                             (u,v) is a non - tree edge</span>
<span class="sd">                      if (color[v] = GRAY)         (u,v) has a gray target</span>
<span class="sd">                          ...</span>
<span class="sd">                      else if (color[v] = BLACK)   (u,v) has a black target</span>
<span class="sd">                          ...</span>
<span class="sd">              end for</span>
<span class="sd">              color[u] := BLACK                    finish vertex u</span>
<span class="sd">          end while</span>

<span class="sd">    If an exception is raised inside the callback function, the graph traversal</span>
<span class="sd">    will be stopped immediately. You can exploit this to exit early by raising a</span>
<span class="sd">    :class:`~rustworkx.visit.StopSearch` exception, in which case the search function</span>
<span class="sd">    will return but without raising back the exception. You can also prune part of</span>
<span class="sd">    the search tree by raising :class:`~rustworkx.visit.PruneSearch`.</span>

<span class="sd">    In the following example we keep track of the tree edges:</span>

<span class="sd">    .. jupyter-execute::</span>

<span class="sd">        import rustworkx as rx</span>
<span class="sd">        from rustworkx.visit import BFSVisitor</span>


<span class="sd">        class TreeEdgesRecorder(BFSVisitor):</span>

<span class="sd">            def __init__(self):</span>
<span class="sd">                self.edges = []</span>

<span class="sd">            def tree_edge(self, edge):</span>
<span class="sd">                self.edges.append(edge)</span>

<span class="sd">        graph = rx.PyDiGraph()</span>
<span class="sd">        graph.extend_from_edge_list([(1, 3), (0, 1), (2, 1), (0, 2)])</span>
<span class="sd">        vis = TreeEdgesRecorder()</span>
<span class="sd">        rx.bfs_search(graph, [0], vis)</span>
<span class="sd">        print(&#39;Tree edges:&#39;, vis.edges)</span>

<span class="sd">    .. note::</span>

<span class="sd">        Graph can **not** be mutated while traversing.</span>

<span class="sd">    :param graph: The graph to be used. This can be a :class:`~rustworkx.PyGraph`</span>
<span class="sd">        or a :class:`~rustworkx.PyDiGraph`</span>
<span class="sd">    :param List[int] source: An optional list of node indices to use as the starting</span>
<span class="sd">        nodes for the breadth-first search. If this is not specified then a source</span>
<span class="sd">        will be chosen arbitrarly and repeated until all components of the</span>
<span class="sd">        graph are searched.</span>
<span class="sd">    :param visitor: A visitor object that is invoked at the event points inside the</span>
<span class="sd">        algorithm. This should be a subclass of :class:`~rustworkx.visit.BFSVisitor`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Invalid Input Type </span><span class="si">%s</span><span class="s2"> for graph&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">graph</span><span class="p">))</span></div>


<span class="n">bfs_search</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">PyDiGraph</span><span class="p">,</span> <span class="n">digraph_bfs_search</span><span class="p">)</span>
<span class="n">bfs_search</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">PyGraph</span><span class="p">,</span> <span class="n">graph_bfs_search</span><span class="p">)</span>


<div class="viewcode-block" id="dfs_search"><a class="viewcode-back" href="../apiref/rustworkx.dfs_search.html#rustworkx.dfs_search">[docs]</a><span class="nd">@functools</span><span class="o">.</span><span class="n">singledispatch</span>
<span class="k">def</span> <span class="nf">dfs_search</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">visitor</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Depth-first traversal of a directed/undirected graph.</span>

<span class="sd">    The pseudo-code for the DFS algorithm is listed below, with the annotated</span>
<span class="sd">    event points, for which the given visitor object will be called with the</span>
<span class="sd">    appropriate method.</span>

<span class="sd">    ::</span>

<span class="sd">        DFS(G)</span>
<span class="sd">          for each vertex u in V</span>
<span class="sd">              color[u] := WHITE                 initialize vertex u</span>
<span class="sd">          end for</span>
<span class="sd">          time := 0</span>
<span class="sd">          call DFS-VISIT(G, source)             start vertex s</span>

<span class="sd">        DFS-VISIT(G, u)</span>
<span class="sd">          color[u] := GRAY                      discover vertex u</span>
<span class="sd">          for each v in Adj[u]                  examine edge (u,v)</span>
<span class="sd">              if (color[v] = WHITE)             (u,v) is a tree edge</span>
<span class="sd">                  all DFS-VISIT(G, v)</span>
<span class="sd">              else if (color[v] = GRAY)         (u,v) is a back edge</span>
<span class="sd">              ...</span>
<span class="sd">             else if (color[v] = BLACK)         (u,v) is a cross or forward edge</span>
<span class="sd">             ...</span>
<span class="sd">          end for</span>
<span class="sd">          color[u] := BLACK                     finish vertex u</span>

<span class="sd">    If an exception is raised inside the callback function, the graph traversal</span>
<span class="sd">    will be stopped immediately. You can exploit this to exit early by raising a</span>
<span class="sd">    :class:`~rustworkx.visit.StopSearch` exception. You can also prune part of the</span>
<span class="sd">    search tree by raising :class:`~rustworkx.visit.PruneSearch`.</span>

<span class="sd">    In the following example we keep track of the tree edges:</span>

<span class="sd">    .. jupyter-execute::</span>

<span class="sd">           import rustworkx as rx</span>
<span class="sd">           from rustworkx.visit import DFSVisitor</span>

<span class="sd">           class TreeEdgesRecorder(DFSVisitor):</span>

<span class="sd">               def __init__(self):</span>
<span class="sd">                   self.edges = []</span>

<span class="sd">               def tree_edge(self, edge):</span>
<span class="sd">                   self.edges.append(edge)</span>

<span class="sd">           graph = rx.PyGraph()</span>
<span class="sd">           graph.extend_from_edge_list([(1, 3), (0, 1), (2, 1), (0, 2)])</span>
<span class="sd">           vis = TreeEdgesRecorder()</span>
<span class="sd">           rx.dfs_search(graph, [0], vis)</span>
<span class="sd">           print(&#39;Tree edges:&#39;, vis.edges)</span>

<span class="sd">    .. note::</span>

<span class="sd">        Graph can *not* be mutated while traversing.</span>

<span class="sd">    :param PyGraph graph: The graph to be used.</span>
<span class="sd">    :param List[int] source: An optional list of node indices to use as the starting</span>
<span class="sd">        nodes for the depth-first search. If this is not specified then a source</span>
<span class="sd">        will be chosen arbitrarly and repeated until all components of the</span>
<span class="sd">        graph are searched.</span>
<span class="sd">    :param visitor: A visitor object that is invoked at the event points inside the</span>
<span class="sd">        algorithm. This should be a subclass of :class:`~rustworkx.visit.DFSVisitor`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Invalid Input Type </span><span class="si">%s</span><span class="s2"> for graph&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">graph</span><span class="p">))</span></div>


<span class="n">dfs_search</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">PyDiGraph</span><span class="p">,</span> <span class="n">digraph_dfs_search</span><span class="p">)</span>
<span class="n">dfs_search</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">PyGraph</span><span class="p">,</span> <span class="n">graph_dfs_search</span><span class="p">)</span>


<div class="viewcode-block" id="dijkstra_search"><a class="viewcode-back" href="../apiref/rustworkx.dijkstra_search.html#rustworkx.dijkstra_search">[docs]</a><span class="nd">@functools</span><span class="o">.</span><span class="n">singledispatch</span>
<span class="k">def</span> <span class="nf">dijkstra_search</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">weight_fn</span><span class="p">,</span> <span class="n">visitor</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Dijkstra traversal of a graph.</span>

<span class="sd">    The pseudo-code for the Dijkstra algorithm is listed below, with the annotated</span>
<span class="sd">    event points, for which the given visitor object will be called with the</span>
<span class="sd">    appropriate method.</span>

<span class="sd">    ::</span>

<span class="sd">        DIJKSTRA(G, source, weight)</span>
<span class="sd">          for each vertex u in V</span>
<span class="sd">              d[u] := infinity</span>
<span class="sd">              p[u] := u</span>
<span class="sd">          end for</span>
<span class="sd">          d[source] := 0</span>
<span class="sd">          INSERT(Q, source)</span>
<span class="sd">          while (Q != Ø)</span>
<span class="sd">              u := EXTRACT-MIN(Q)                         discover vertex u</span>
<span class="sd">              for each vertex v in Adj[u]                 examine edge (u,v)</span>
<span class="sd">                  if (weight[(u,v)] + d[u] &lt; d[v])        edge (u,v) relaxed</span>
<span class="sd">                      d[v] := weight[(u,v)] + d[u]</span>
<span class="sd">                      p[v] := u</span>
<span class="sd">                      DECREASE-KEY(Q, v)</span>
<span class="sd">                  else                                    edge (u,v) not relaxed</span>
<span class="sd">                      ...</span>
<span class="sd">                  if (d[v] was originally infinity)</span>
<span class="sd">                      INSERT(Q, v)</span>
<span class="sd">              end for                                     finish vertex u</span>
<span class="sd">          end while</span>

<span class="sd">    If an exception is raised inside the callback function, the graph traversal</span>
<span class="sd">    will be stopped immediately. You can exploit this to exit early by raising a</span>
<span class="sd">    :class:`~rustworkx.visit.StopSearch` exception, in which case the search function</span>
<span class="sd">    will return but without raising back the exception. You can also prune part of the</span>
<span class="sd">    search tree by raising :class:`~rustworkx.visit.PruneSearch`.</span>

<span class="sd">    .. note::</span>

<span class="sd">        Graph can **not** be mutated while traversing.</span>

<span class="sd">    :param graph: The graph to be used. This can be a :class:`~rustworkx.PyGraph`</span>
<span class="sd">        or a :class:`~rustworkx.PyDiGraph`.</span>
<span class="sd">    :param List[int] source: An optional list of node indices to use as the starting nodes</span>
<span class="sd">        for the dijkstra search. If this is not specified then a source</span>
<span class="sd">        will be chosen arbitrarly and repeated until all components of the</span>
<span class="sd">        graph are searched.</span>
<span class="sd">    :param weight_fn: An optional weight function for an edge. It will accept</span>
<span class="sd">        a single argument, the edge&#39;s weight object and will return a float which</span>
<span class="sd">        will be used to represent the weight/cost of the edge. If not specified,</span>
<span class="sd">        a default value of cost ``1.0`` will be used for each edge.</span>
<span class="sd">    :param visitor: A visitor object that is invoked at the event points inside the</span>
<span class="sd">        algorithm. This should be a subclass of :class:`~rustworkx.visit.DijkstraVisitor`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Invalid Input Type </span><span class="si">%s</span><span class="s2"> for graph&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">graph</span><span class="p">))</span></div>


<span class="n">dijkstra_search</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">PyDiGraph</span><span class="p">,</span> <span class="n">digraph_dijkstra_search</span><span class="p">)</span>
<span class="n">dijkstra_search</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">PyGraph</span><span class="p">,</span> <span class="n">graph_dijkstra_search</span><span class="p">)</span>


<div class="viewcode-block" id="bellman_ford_shortest_paths"><a class="viewcode-back" href="../apiref/rustworkx.bellman_ford_shortest_paths.html#rustworkx.bellman_ford_shortest_paths">[docs]</a><span class="nd">@functools</span><span class="o">.</span><span class="n">singledispatch</span>
<span class="k">def</span> <span class="nf">bellman_ford_shortest_paths</span><span class="p">(</span>
    <span class="n">graph</span><span class="p">,</span>
    <span class="n">source</span><span class="p">,</span>
    <span class="n">target</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">weight_fn</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">default_weight</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
    <span class="n">as_undirected</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Find the shortest path from a node</span>

<span class="sd">    This function will generate the shortest path from a source node using</span>
<span class="sd">    the Bellman-Ford algorithm wit the SPFA heuristic.</span>

<span class="sd">    :param graph: The input graph to use. Can either be a</span>
<span class="sd">        :class:`~rustworkx.PyGraph` or :class:`~rustworkx.PyDiGraph`</span>
<span class="sd">    :param int source: The node index to find paths from</span>
<span class="sd">    :param int target: An optional target to find a path to</span>
<span class="sd">    :param weight_fn: An optional weight function for an edge. It will accept</span>
<span class="sd">        a single argument, the edge&#39;s weight object and will return a float</span>
<span class="sd">        which will be used to represent the weight/cost of the edge</span>
<span class="sd">    :param float default_weight: If ``weight_fn`` isn&#39;t specified this optional</span>
<span class="sd">        float value will be used for the weight/cost of each edge.</span>
<span class="sd">    :param bool as_undirected: If set to true the graph will be treated as</span>
<span class="sd">        undirected for finding the shortest path. This only works with a</span>
<span class="sd">        :class:`~rustworkx.PyDiGraph` input for ``graph``</span>

<span class="sd">    :return: A read-only dictionary of paths. The keys are destination node indices</span>
<span class="sd">        and the dict values are lists of node indices making the path.</span>
<span class="sd">    :rtype: PathMapping</span>

<span class="sd">    :raises: :class:`~rustworkx.NegativeCycle`: when there is a negative cycle and the shortest</span>
<span class="sd">        path is not defined</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Invalid Input Type </span><span class="si">%s</span><span class="s2"> for graph&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">graph</span><span class="p">))</span></div>


<span class="n">bellman_ford_shortest_paths</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">PyDiGraph</span><span class="p">,</span> <span class="n">digraph_bellman_ford_shortest_paths</span><span class="p">)</span>
<span class="n">bellman_ford_shortest_paths</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">PyGraph</span><span class="p">,</span> <span class="n">graph_bellman_ford_shortest_paths</span><span class="p">)</span>


<div class="viewcode-block" id="bellman_ford_shortest_path_lengths"><a class="viewcode-back" href="../apiref/rustworkx.bellman_ford_shortest_path_lengths.html#rustworkx.bellman_ford_shortest_path_lengths">[docs]</a><span class="nd">@functools</span><span class="o">.</span><span class="n">singledispatch</span>
<span class="k">def</span> <span class="nf">bellman_ford_shortest_path_lengths</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">edge_cost_fn</span><span class="p">,</span> <span class="n">goal</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute the lengths of the shortest paths for a graph object using</span>
<span class="sd">    the Bellman-Ford algorithm with the SPFA heuristic.</span>

<span class="sd">    :param graph: The input graph to use. Can either be a</span>
<span class="sd">        :class:`~rustworkx.PyGraph` or :class:`~rustworkx.PyDiGraph`</span>
<span class="sd">    :param int node: The node index to use as the source for finding the</span>
<span class="sd">        shortest paths from</span>
<span class="sd">    :param edge_cost_fn: A python callable that will take in 1 parameter, an</span>
<span class="sd">        edge&#39;s data object and will return a float that represents the</span>
<span class="sd">        cost/weight of that edge. It can be negative.</span>
<span class="sd">    :param int goal: An optional node index to use as the end of the path.</span>
<span class="sd">        When specified the output dictionary will only have a single entry with</span>
<span class="sd">        the length of the shortest path to the goal node.</span>

<span class="sd">    :returns: A read-only dictionary of the shortest paths from the provided node</span>
<span class="sd">        where the key is the node index of the end of the path and the value is the</span>
<span class="sd">        cost/sum of the weights of path</span>
<span class="sd">    :rtype: PathLengthMapping</span>

<span class="sd">    :raises: :class:`~rustworkx.NegativeCycle`: when there is a negative cycle and the shortest</span>
<span class="sd">        path is not defined</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Invalid Input Type </span><span class="si">%s</span><span class="s2"> for graph&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">graph</span><span class="p">))</span></div>


<span class="n">bellman_ford_shortest_path_lengths</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">PyDiGraph</span><span class="p">,</span> <span class="n">digraph_bellman_ford_shortest_path_lengths</span><span class="p">)</span>
<span class="n">bellman_ford_shortest_path_lengths</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">PyGraph</span><span class="p">,</span> <span class="n">graph_bellman_ford_shortest_path_lengths</span><span class="p">)</span>


<div class="viewcode-block" id="all_pairs_bellman_ford_path_lengths"><a class="viewcode-back" href="../apiref/rustworkx.all_pairs_bellman_ford_path_lengths.html#rustworkx.all_pairs_bellman_ford_path_lengths">[docs]</a><span class="nd">@functools</span><span class="o">.</span><span class="n">singledispatch</span>
<span class="k">def</span> <span class="nf">all_pairs_bellman_ford_path_lengths</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">edge_cost_fn</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;For each node in the graph, calculates the lengths of the shortest paths to all others.</span>

<span class="sd">    This function will generate the shortest path lengths from all nodes in the</span>
<span class="sd">    graph using the Bellman-Ford algorithm. This function is multithreaded and will</span>
<span class="sd">    launch a thread pool with threads equal to the number of CPUs by</span>
<span class="sd">    default. You can tune the number of threads with the ``RAYON_NUM_THREADS``</span>
<span class="sd">    environment variable. For example, setting ``RAYON_NUM_THREADS=4`` would</span>
<span class="sd">    limit the thread pool to 4 threads.</span>

<span class="sd">    :param graph: The input graph to use. Can either be a</span>
<span class="sd">        :class:`~rustworkx.PyGraph` or :class:`~rustworkx.PyDiGraph`</span>
<span class="sd">    :param edge_cost_fn: A callable object that acts as a weight function for</span>
<span class="sd">        an edge. It will accept a single positional argument, the edge&#39;s weight</span>
<span class="sd">        object and will return a float which will be used to represent the</span>
<span class="sd">        weight/cost of the edge</span>

<span class="sd">    :return: A read-only dictionary of path lengths. The keys are the source</span>
<span class="sd">        node indices and the values are a dict of the target node and the</span>
<span class="sd">        length of the shortest path to that node. For example::</span>

<span class="sd">            {</span>
<span class="sd">                0: {1: 2.0, 2: 2.0},</span>
<span class="sd">                1: {2: 1.0},</span>
<span class="sd">                2: {0: 1.0},</span>
<span class="sd">            }</span>

<span class="sd">    :rtype: AllPairsPathLengthMapping</span>

<span class="sd">    :raises: :class:`~rustworkx.NegativeCycle`: when there is a negative cycle and the shortest</span>
<span class="sd">        path is not defined</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Invalid Input Type </span><span class="si">%s</span><span class="s2"> for graph&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">graph</span><span class="p">))</span></div>


<span class="n">all_pairs_bellman_ford_path_lengths</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">PyDiGraph</span><span class="p">,</span> <span class="n">digraph_all_pairs_bellman_ford_path_lengths</span><span class="p">)</span>
<span class="n">all_pairs_bellman_ford_path_lengths</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">PyGraph</span><span class="p">,</span> <span class="n">graph_all_pairs_bellman_ford_path_lengths</span><span class="p">)</span>


<div class="viewcode-block" id="all_pairs_bellman_ford_shortest_paths"><a class="viewcode-back" href="../apiref/rustworkx.all_pairs_bellman_ford_shortest_paths.html#rustworkx.all_pairs_bellman_ford_shortest_paths">[docs]</a><span class="nd">@functools</span><span class="o">.</span><span class="n">singledispatch</span>
<span class="k">def</span> <span class="nf">all_pairs_bellman_ford_shortest_paths</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">edge_cost_fn</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;For each node in the graph, finds the shortest paths to all others.</span>

<span class="sd">    This function will generate the shortest path from all nodes in the graph</span>
<span class="sd">    using the Bellman-Ford algorithm. This function is multithreaded and will run</span>
<span class="sd">    launch a thread pool with threads equal to the number of CPUs by default.</span>
<span class="sd">    You can tune the number of threads with the ``RAYON_NUM_THREADS``</span>
<span class="sd">    environment variable. For example, setting ``RAYON_NUM_THREADS=4`` would</span>
<span class="sd">    limit the thread pool to 4 threads.</span>

<span class="sd">    :param graph: The input graph to use. Can either be a</span>
<span class="sd">        :class:`~rustworkx.PyGraph` or :class:`~rustworkx.PyDiGraph`</span>
<span class="sd">    :param edge_cost_fn: A callable object that acts as a weight function for</span>
<span class="sd">        an edge. It will accept a single positional argument, the edge&#39;s weight</span>
<span class="sd">        object and will return a float which will be used to represent the</span>
<span class="sd">        weight/cost of the edge</span>

<span class="sd">    :return: A read-only dictionary of paths. The keys are source node</span>
<span class="sd">        indices and the values are a dict of target node indices and a list</span>
<span class="sd">        of node indices making the path. For example::</span>

<span class="sd">            {</span>
<span class="sd">                0: {1: [0, 1],  2: [0, 1, 2]},</span>
<span class="sd">                1: {2: [1, 2]},</span>
<span class="sd">                2: {0: [2, 0]},</span>
<span class="sd">            }</span>

<span class="sd">    :rtype: AllPairsPathMapping</span>

<span class="sd">    :raises: :class:`~rustworkx.NegativeCycle`: when there is a negative cycle and the shortest</span>
<span class="sd">        path is not defined</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Invalid Input Type </span><span class="si">%s</span><span class="s2"> for graph&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">graph</span><span class="p">))</span></div>


<span class="n">all_pairs_bellman_ford_shortest_paths</span><span class="o">.</span><span class="n">register</span><span class="p">(</span>
    <span class="n">PyDiGraph</span><span class="p">,</span> <span class="n">digraph_all_pairs_bellman_ford_shortest_paths</span>
<span class="p">)</span>
<span class="n">all_pairs_bellman_ford_shortest_paths</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">PyGraph</span><span class="p">,</span> <span class="n">graph_all_pairs_bellman_ford_shortest_paths</span><span class="p">)</span>


<div class="viewcode-block" id="node_link_json"><a class="viewcode-back" href="../apiref/rustworkx.node_link_json.html#rustworkx.node_link_json">[docs]</a><span class="nd">@functools</span><span class="o">.</span><span class="n">singledispatch</span>
<span class="k">def</span> <span class="nf">node_link_json</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">graph_attrs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">node_attrs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">edge_attrs</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Generate a JSON object representing a graph in a node-link format</span>

<span class="sd">    :param graph: The graph to generate the JSON for. Can either be a</span>
<span class="sd">        :class:`~retworkx.PyGraph` or :class:`~retworkx.PyDiGraph`.</span>
<span class="sd">    :param str path: An optional path to write the JSON output to. If specified</span>
<span class="sd">        the function will not return anything and instead will write the JSON</span>
<span class="sd">        to the file specified.</span>
<span class="sd">    :param graph_attrs: An optional callable that will be passed the</span>
<span class="sd">        :attr:`~.PyGraph.attrs` attribute of the graph and is expected to</span>
<span class="sd">        return a dictionary of string keys to string values representing the</span>
<span class="sd">        graph attributes. This dictionary will be included as attributes in</span>
<span class="sd">        the output JSON. If anything other than a dictionary with string keys</span>
<span class="sd">        and string values is returned an exception will be raised.</span>
<span class="sd">    :param node_attrs: An optional callable that will be passed the node data</span>
<span class="sd">        payload for each node in the graph and is expected to return a</span>
<span class="sd">        dictionary of string keys to string values representing the data payload.</span>
<span class="sd">        This dictionary will be used as the ``data`` field for each node.</span>
<span class="sd">    :param edge_attrs:  An optional callable that will be passed the edge data</span>
<span class="sd">        payload for each node in the graph and is expected to return a</span>
<span class="sd">        dictionary of string keys to string values representing the data payload.</span>
<span class="sd">        This dictionary will be used as the ``data`` field for each edge.</span>

<span class="sd">    :returns: Either the JSON string for the payload or ``None`` if ``path`` is specified</span>
<span class="sd">    :rtype: str</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Invalid Input Type </span><span class="si">%s</span><span class="s2"> for graph&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">graph</span><span class="p">))</span></div>


<span class="n">node_link_json</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">PyDiGraph</span><span class="p">,</span> <span class="n">digraph_node_link_json</span><span class="p">)</span>
<span class="n">node_link_json</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">PyGraph</span><span class="p">,</span> <span class="n">graph_node_link_json</span><span class="p">)</span>


<div class="viewcode-block" id="longest_simple_path"><a class="viewcode-back" href="../apiref/rustworkx.longest_simple_path.html#rustworkx.longest_simple_path">[docs]</a><span class="nd">@functools</span><span class="o">.</span><span class="n">singledispatch</span>
<span class="k">def</span> <span class="nf">longest_simple_path</span><span class="p">(</span><span class="n">graph</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return a longest simple path in the graph</span>

<span class="sd">    This function searches computes all pairs of all simple paths and returns</span>
<span class="sd">    a path of the longest length from that set. It is roughly equivalent to</span>
<span class="sd">    running something like::</span>

<span class="sd">        from rustworkx import all_pairs_all_simple_paths</span>

<span class="sd">        max((y.values for y in all_pairs_all_simple_paths(graph).values()), key=lambda x: len(x))</span>

<span class="sd">    but this function will be more efficient than using ``max()`` as the search</span>
<span class="sd">    is evaluated in parallel before returning to Python. In the case of multiple</span>
<span class="sd">    paths of the same maximum length being present in the graph only one will be</span>
<span class="sd">    provided. There are no guarantees on which of the multiple longest paths</span>
<span class="sd">    will be returned (as it is determined by the parallel execution order). This</span>
<span class="sd">    is a tradeoff to improve runtime performance. If a stable return is required</span>
<span class="sd">    in such case consider using the ``max()`` equivalent above instead.</span>

<span class="sd">    This function is multithreaded and will launch a thread pool with threads</span>
<span class="sd">    equal to the number of CPUs by default. You can tune the number of threads</span>
<span class="sd">    with the ``RAYON_NUM_THREADS`` environment variable. For example, setting</span>
<span class="sd">    ``RAYON_NUM_THREADS=4`` would limit the thread pool to 4 threads.</span>

<span class="sd">    :param PyGraph graph: The graph to find the longest path in</span>

<span class="sd">    :returns: A sequence of node indices that represent the longest simple graph</span>
<span class="sd">        found in the graph. If the graph is empty ``None`` will be returned instead.</span>
<span class="sd">    :rtype: NodeIndices</span>
<span class="sd">    &quot;&quot;&quot;</span></div>


<span class="n">longest_simple_path</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">PyDiGraph</span><span class="p">,</span> <span class="n">digraph_longest_simple_path</span><span class="p">)</span>
<span class="n">longest_simple_path</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">PyGraph</span><span class="p">,</span> <span class="n">graph_longest_simple_path</span><span class="p">)</span>


<div class="viewcode-block" id="isolates"><a class="viewcode-back" href="../apiref/rustworkx.isolates.html#rustworkx.isolates">[docs]</a><span class="nd">@functools</span><span class="o">.</span><span class="n">singledispatch</span>
<span class="k">def</span> <span class="nf">isolates</span><span class="p">(</span><span class="n">graph</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return a list of isolates in a graph object</span>

<span class="sd">    An isolate is a node without any neighbors meaning it has a degree of 0. For</span>
<span class="sd">    directed graphs this means the in-degree and out-degree are both 0.</span>

<span class="sd">    :param graph: The input graph to find isolates in</span>
<span class="sd">    :returns: A list of node indices for isolates in the graph</span>
<span class="sd">    :rtype: NodeIndices</span>
<span class="sd">    &quot;&quot;&quot;</span></div>


<span class="n">isolates</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">PyDiGraph</span><span class="p">,</span> <span class="n">digraph_isolates</span><span class="p">)</span>
<span class="n">isolates</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">PyGraph</span><span class="p">,</span> <span class="n">graph_isolates</span><span class="p">)</span>


<div class="viewcode-block" id="two_color"><a class="viewcode-back" href="../apiref/rustworkx.two_color.html#rustworkx.two_color">[docs]</a><span class="nd">@functools</span><span class="o">.</span><span class="n">singledispatch</span>
<span class="k">def</span> <span class="nf">two_color</span><span class="p">(</span><span class="n">graph</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute a two-coloring of a directed graph</span>

<span class="sd">    If a two coloring is not possible for the input graph (meaning it is not</span>
<span class="sd">    bipartite), ``None`` is returned.</span>

<span class="sd">    :param graph: The graph to find the coloring for</span>
<span class="sd">    :returns: If a coloring is possible return a dictionary of node indices to the color as an integer (0 or 1)</span>
<span class="sd">    :rtype: dict</span>
<span class="sd">    &quot;&quot;&quot;</span></div>


<span class="n">two_color</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">PyDiGraph</span><span class="p">,</span> <span class="n">digraph_two_color</span><span class="p">)</span>
<span class="n">two_color</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">PyGraph</span><span class="p">,</span> <span class="n">graph_two_color</span><span class="p">)</span>


<div class="viewcode-block" id="is_bipartite"><a class="viewcode-back" href="../apiref/rustworkx.is_bipartite.html#rustworkx.is_bipartite">[docs]</a><span class="nd">@functools</span><span class="o">.</span><span class="n">singledispatch</span>
<span class="k">def</span> <span class="nf">is_bipartite</span><span class="p">(</span><span class="n">graph</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Determine if a given graph is bipartite</span>

<span class="sd">    :param graph: The graph to check if it&#39;s bipartite</span>
<span class="sd">    :returns: ``True`` if the graph is bipartite and ``False`` if it is not</span>
<span class="sd">    :rtype: bool</span>
<span class="sd">    &quot;&quot;&quot;</span></div>


<span class="n">is_bipartite</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">PyDiGraph</span><span class="p">,</span> <span class="n">digraph_is_bipartite</span><span class="p">)</span>
<span class="n">is_bipartite</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">PyGraph</span><span class="p">,</span> <span class="n">graph_is_bipartite</span><span class="p">)</span>


<div class="viewcode-block" id="floyd_warshall_successor_and_distance"><a class="viewcode-back" href="../apiref/rustworkx.floyd_warshall_successor_and_distance.html#rustworkx.floyd_warshall_successor_and_distance">[docs]</a><span class="nd">@functools</span><span class="o">.</span><span class="n">singledispatch</span>
<span class="k">def</span> <span class="nf">floyd_warshall_successor_and_distance</span><span class="p">(</span>
    <span class="n">graph</span><span class="p">,</span>
    <span class="n">weight_fn</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">default_weight</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
    <span class="n">parallel_threshold</span><span class="o">=</span><span class="mi">300</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Find all-pairs shortest path lengths using Floyd&#39;s algorithm.</span>

<span class="sd">    Floyd&#39;s algorithm is used for finding shortest paths in dense graphs</span>
<span class="sd">    or graphs with negative weights (where Dijkstra&#39;s algorithm fails).</span>

<span class="sd">    This function is multithreaded and will launch a pool with threads equal</span>
<span class="sd">    to the number of CPUs by default if the number of nodes in the graph is</span>
<span class="sd">    above the value of ``parallel_threshold`` (it defaults to 300).</span>
<span class="sd">    You can tune the number of threads with the ``RAYON_NUM_THREADS``</span>
<span class="sd">    environment variable. For example, setting ``RAYON_NUM_THREADS=4`` would</span>
<span class="sd">    limit the thread pool to 4 threads if parallelization was enabled.</span>

<span class="sd">    :param PyDiGraph graph: The directed graph to run Floyd&#39;s algorithm on</span>
<span class="sd">    :param weight_fn: A callable object (function, lambda, etc) which</span>
<span class="sd">        will be passed the edge object and expected to return a ``float``. This</span>
<span class="sd">        tells rustworkx/rust how to extract a numerical weight as a ``float``</span>
<span class="sd">        for edge object. Some simple examples are::</span>

<span class="sd">            floyd_warshall_successor_and_distance(graph, weight_fn=lambda _: 1)</span>

<span class="sd">        to return a weight of 1 for all edges. Also:</span>

<span class="sd">            floyd_warshall_successor_and_distance(graph, weight_fn=float)</span>

<span class="sd">        to cast the edge object as a float as the weight.</span>
<span class="sd">    :param as_undirected: If set to true each directed edge will be treated as</span>
<span class="sd">        bidirectional/undirected.</span>
<span class="sd">    :param int parallel_threshold: The number of nodes to execute</span>
<span class="sd">        the algorithm in parallel at. It defaults to 300, but this can</span>
<span class="sd">        be tuned</span>

<span class="sd">    :returns: A tuple of two matrices.</span>
<span class="sd">        First one is a matrix of shortest path distances between nodes. If there is no</span>
<span class="sd">        path between two nodes then the corresponding matrix entry will be</span>
<span class="sd">        ``np.inf``.</span>
<span class="sd">        Second one is a matrix of **next** nodes for given source and target. If there is no</span>
<span class="sd">        path between two nodes then the corresponding matrix entry will be the same as</span>
<span class="sd">        a target node. To reconstruct the shortest path among nodes::</span>

<span class="sd">            def reconstruct_path(source, target, successors):</span>
<span class="sd">                path = []</span>
<span class="sd">                if source == target:</span>
<span class="sd">                    return path</span>
<span class="sd">                curr = source</span>
<span class="sd">                while curr != target:</span>
<span class="sd">                    path.append(curr)</span>
<span class="sd">                    curr = successors[curr, target]</span>
<span class="sd">                path.append(target)</span>
<span class="sd">                return path</span>

<span class="sd">    :rtype: (numpy.ndarray, numpy.ndarray)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Invalid Input Type </span><span class="si">%s</span><span class="s2"> for graph&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">graph</span><span class="p">))</span></div>


<span class="n">floyd_warshall_successor_and_distance</span><span class="o">.</span><span class="n">register</span><span class="p">(</span>
    <span class="n">PyDiGraph</span><span class="p">,</span> <span class="n">digraph_floyd_warshall_successor_and_distance</span>
<span class="p">)</span>
<span class="n">floyd_warshall_successor_and_distance</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">PyGraph</span><span class="p">,</span> <span class="n">graph_floyd_warshall_successor_and_distance</span><span class="p">)</span>


<div class="viewcode-block" id="all_shortest_paths"><a class="viewcode-back" href="../apiref/rustworkx.all_shortest_paths.html#rustworkx.all_shortest_paths">[docs]</a><span class="nd">@functools</span><span class="o">.</span><span class="n">singledispatch</span>
<span class="k">def</span> <span class="nf">all_shortest_paths</span><span class="p">(</span>
    <span class="n">graph</span><span class="p">,</span>
    <span class="n">source</span><span class="p">,</span>
    <span class="n">target</span><span class="p">,</span>
    <span class="n">weight_fn</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">default_weight</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
    <span class="n">as_undirected</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Find all shortest paths between two nodes</span>

<span class="sd">    This function will generate all possible shortest paths from a source node to a</span>
<span class="sd">    target using Dijkstra&#39;s algorithm.</span>

<span class="sd">    :param graph: The input graph to find the shortest paths for</span>
<span class="sd">    :param int source: The node index to find paths from</span>
<span class="sd">    :param int target: A target to find paths to</span>
<span class="sd">    :param weight_fn: An optional weight function for an edge. It will accept</span>
<span class="sd">        a single argument, the edge&#39;s weight object and will return a float which</span>
<span class="sd">        will be used to represent the weight/cost of the edge</span>
<span class="sd">    :param float default_weight: If ``weight_fn`` isn&#39;t specified this optional</span>
<span class="sd">        float value will be used for the weight/cost of each edge.</span>

<span class="sd">    :return: List of paths. Each paths are lists of node indices,</span>
<span class="sd">        starting at ``source`` and ending at ``target``.</span>
<span class="sd">    :rtype: list</span>
<span class="sd">    :raises ValueError: when an edge weight with NaN or negative value</span>
<span class="sd">        is provided.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Invalid Input Type </span><span class="si">%s</span><span class="s2"> for graph&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">graph</span><span class="p">))</span></div>


<span class="n">all_shortest_paths</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">PyDiGraph</span><span class="p">,</span> <span class="n">digraph_all_shortest_paths</span><span class="p">)</span>
<span class="n">all_shortest_paths</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">PyGraph</span><span class="p">,</span> <span class="n">graph_all_shortest_paths</span><span class="p">)</span>
</pre></div>
        </article>
      </div>
      <footer>
        <div class="related-pages">
          
          
        </div>
        <div class="bottom-of-page">
          <div class="left-details">
            <div class="copyright">
                Copyright &#169; 2021, rustworkx Contributors
            </div>
            Made with <a href="https://www.sphinx-doc.org/">Sphinx</a> and <a class="muted-link" href="https://pradyunsg.me">@pradyunsg</a>'s
            
            <a href="https://github.com/pradyunsg/furo">Furo</a>
            
          </div>
          <div class="right-details">
            
          </div>
        </div>
        
      </footer>
    </div>
    <aside class="toc-drawer no-toc">
      
      
      
    </aside>
  </div>
</div><script src="../_static/jquery.js?v=5d32c60e"></script>
    <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js?v=75e7b761"></script>
    <script src="../_static/doctools.js?v=888ff710"></script>
    <script src="../_static/sphinx_highlight.js?v=4825356b"></script>
    <script src="../_static/thebelab-helper.js"></script>
    <script src="../_static/scripts/qiskit-sphinx-theme.js?v=4d77b8ca"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@jupyter-widgets/html-manager@^1.0.1/dist/embed-amd.js"></script>
    </body>
</html>